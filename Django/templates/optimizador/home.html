{% extends '../layout/layout.html' %}

{% block content %}
<style>
    .gated { cursor: not-allowed !important; }
    .gated input, .gated button, .gated select { cursor: not-allowed !important; }
    /* Cursor X roja usando SVG data URI */
    .cursor-x { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24'><line x1='4' y1='4' x2='20' y2='20' stroke='red' stroke-width='3'/><line x1='20' y1='4' x2='4' y2='20' stroke='red' stroke-width='3'/></svg>") 12 12, not-allowed !important; }
    /* Aviso fijo para generación de PDF: no ocupa espacio en layout */
    #toastGenerandoPdf { position: fixed; right: 16px; bottom: 16px; z-index: 2000; display: none; }
</style>
<div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-24">
    <h6 class="fw-semibold mb-0">Optimizador de Materiales</h6>
    <button class="btn btn-sm btn-primary d-inline-flex align-items-center gap-1" onclick="nuevoProyecto()" title="Iniciar un proyecto en blanco">
        <i class="ri-add-line"></i>
        <span>Nuevo Proyecto</span>
    </button>
</div>

<!-- 1. Información del Proyecto -->
<div class="card mb-24">
    <div class="card-body">
        <div class="row g-3">
            <div class="col-md-4">
                <label class="form-label">Cliente</label>
                <div class="position-relative">
                    <input type="text" class="form-control" 
                           id="clienteInput" list="clientesDatalist" 
                           placeholder="Escribe al menos 3 letras para buscar cliente..."
                           onkeyup="manejarSeleccionCliente(); generarNombreProyecto();" 
                           oninput="buscarClientesDB(this.value)"
                           autocomplete="off">
                    <!-- Datalist dinámico con clientes desde BD -->
                    <datalist id="clientesDatalist"></datalist>
                </div>
            </div>
            <div class="col-md-2">
                <label class="form-label">RUT</label>
                <input type="text" class="form-control" 
                       id="rutCliente" placeholder="12.345.678-9" maxlength="12" 
                       oninput="formatearRUT(this)" disabled>
            </div>
            <div class="col-md-2">
                <label class="form-label">ID del proyecto</label>
                <input type="text" class="form-control" id="folioProyecto" placeholder="—" disabled>
            </div>
            <div class="col-md-4">
                <label class="form-label">Nombre del proyecto</label>
                <input type="text" class="form-control" 
                       id="nombreProyecto" placeholder="Se generará automáticamente">
            </div>
        </div>
    </div>
</div>

<!-- 2. Selección de Tablero -->
<div class="card mb-24">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h6 class="card-title mb-0">
            <span class="badge bg-secondary me-2">2</span>
            Selección de Tablero
        </h6>
        <small class="text-muted">Unidad: milímetros</small>
    </div>
    <div class="card-body">
        <!-- Pestañas de Material con botón editar -->
        <div class="mb-3 d-flex justify-content-between align-items-end">
            <ul class="nav nav-tabs" id="materialTabs" role="tablist">
                <li class="nav-item" role="presentation">
            <button class="nav-link active" id="material1-tab" data-bs-toggle="tab" data-bs-target="#material1" 
                type="button" role="tab" ondblclick="duplicarMaterial(1)" title="Doble clic para duplicar material">
                        Material 1
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="add-material-tab" onclick="agregarMaterial()">
                        <i class="fas fa-plus"></i> Agregar Material
                    </button>
                </li>
            </ul>
            <!-- Botón editar medidas -->
            <button class="btn btn-sm btn-outline-warning" onclick="habilitarEdicionDimensiones(1)">
                <i class="fas fa-edit"></i> <span id="btnEditText1">Editar medidas</span>
            </button>
        </div>

        <!-- Contenido de Pestañas -->
        <div class="tab-content" id="materialTabsContent">
            <div class="tab-pane fade show active" id="material1" role="tabpanel">
                <!-- Selección de tablero y medidas en la misma línea -->
                <div class="mb-3">
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label class="form-label">Seleccionar tablero</label>
                            <select class="form-select" id="tableroSelect1" onchange="cargarDimensionesTablero(1)">
                                <option value="">Seleccionar tablero...</option>
                                {# Agrupar materiales por tipo y mostrar dimensiones como ancho × alto #}
                                {% regroup tableros by tipo as grupos_tipos %}
                                {% for group in grupos_tipos %}
                                    <optgroup label="{{ group.list.0.get_tipo_display }}">
                                        {% for m in group.list %}
                                            <option value="{{ m.id }}" data-ancho="{{ m.ancho }}" data-alto="{{ m.largo }}" data-precio_m2="{{ m.precio_m2 }}" data-espesor="{{ m.espesor }}" data-tipo="{{ m.get_tipo_display }}" data-codigo="{{ m.codigo }}">
                                                {{ m.nombre }} ({{ m.ancho }}×{{ m.largo }})
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Ancho (mm)</label>
                            <input type="number" class="form-control" 
                                   id="ancho1" value="1830" disabled>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Alto (mm)</label>
                            <input type="number" class="form-control" 
                                   id="alto1" value="2500" disabled>
                        </div>
                    </div>
                </div>

                <!-- Tapacanto y configuraciones -->
                <div class="mb-4" style="border-bottom: 1px dashed #dee2e6; padding-bottom: .5rem;">
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label class="form-label">Tapacanto</label>
                            <select class="form-select" id="tapacantoSelect1">
                                <option value="">Seleccionar tapacanto...</option>
                                {% for t in tapacantos %}
                                    <option value="{{ t.id }}" data-ancho="{{ t.ancho }}" data-espesor="{{ t.espesor }}" data-precio_metro="{{ t.precio_metro }}" data-codigo="{{ t.codigo }}">{{ t.nombre }} {{ t.color }} ({{ t.ancho }}×{{ t.espesor }} mm)</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">Margen</label>
                            <input type="number" class="form-control" 
                                   id="margenX1" value="10" disabled oninput="try{document.getElementById('margenY1').value=this.value;}catch(_e){}">
                        </div>
                        <div class="col-md-2 d-none">
                            <label class="form-label">Margen Y</label>
                            <input type="number" class="form-control" 
                                   id="margenY1" value="10" disabled>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">Kerf sierra</label>
                            <input type="number" class="form-control" 
                                   id="desperdicioSierra1" value="3" disabled>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <!-- 3. Dimensiones de piezas (mismo segmento, dentro de la tarjeta) -->
        <div class="mt-4">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">
                    <span class="badge bg-secondary me-2">3</span>
                    Dimensiones de piezas
                </h6>
                <div class="d-flex align-items-center flex-wrap gap-2">
                    <div class="input-group input-group-sm" style="width: 240px;">
                        <span class="input-group-text">Filas totales</span>
                        <input type="number" class="form-control" id="cantidadFilasHome" value="1" min="1" max="200" title="Cantidad total de filas de piezas">
                        <button class="btn btn-success" onclick="agregarFilasHome()" id="btnAgregarFila" title="Fijar la cantidad total de filas">Fijar filas</button>
                    </div>
                    <input type="file" id="importPiezasFile" accept=".csv" class="d-none">
                    <button class="btn btn-outline-warning btn-sm" onclick="document.getElementById('importPiezasFile').click()">
                        <i class="fas fa-file-excel"></i> Importar
                    </button>
                    <button class="btn btn-outline-info btn-sm" onclick="cargarEjemplo()">
                        <i class="fas fa-download"></i> Cargar ejemplo
                    </button>
                    <button class="btn btn-outline-danger btn-sm" onclick="limpiarTodo()">
                        <i class="fas fa-trash"></i> Limpiar
                    </button>
                </div>
            </div>
            <div class="p-0">
                <!-- Tabla de piezas -->
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead class="table-secondary">
                            <tr>
                                <th style="width: 50px; max-width: 50px; min-width: 50px; text-align: center;">Nº</th>
                                <th style="width: 110px; max-width: 110px; min-width: 110px; text-align: center;">Cant.</th>
                                <th style="min-width: 150px;">Pieza</th>
                                <th style="width: 120px; max-width: 120px; min-width: 120px; text-align: center;">Ancho</th>
                                <th style="width: 120px; max-width: 120px; min-width: 120px; text-align: center;">Alto</th>
                                <th style="width: 50px; max-width: 50px; min-width: 50px; text-align: center;">
                                    V.L.
                                    <div class="form-check d-inline-block ms-1 align-middle" title="Marcar/Desmarcar veta libre en todas las piezas">
                                        <input id="vetaLibreMaster" class="form-check-input" type="checkbox" onchange="toggleVetaLibreTodos(this.checked)">
                                    </div>
                                </th>
                                <th style="width: 180px; max-width: 180px; min-width: 180px; text-align: center;">
                                    Tapacanto
                                    <div class="form-check d-inline-block ms-1 align-middle" title="Aplicar tapacanto en todos los lados a todas las piezas">
                                        <input id="tapacantoMaster" class="form-check-input" type="checkbox" onchange="toggleTapacantoTodos(this.checked)">
                                    </div>
                                </th>
                                <th style="width: 50px; max-width: 50px; min-width: 50px; text-align: center;"></th>
                            </tr>
                        </thead>
                        <tbody id="piezasTableBody">
                            <tr>
                                <td>1</td>
                                <td>
                                    <input type="number" class="form-control form-control-sm" 
                                           value="1" min="1">
                                </td>
                                <td>
                                    <input type="text" class="form-control form-control-sm" 
                                           value="Pieza 1"
                                           placeholder="Nombre de la pieza"
                                           data-es-predeterminado="true"
                                           onfocus="manejarFocoPieza(this)"
                                           onblur="manejarBlurPieza(this)">
                                </td>
                                <td>
                                    <input type="number" class="form-control form-control-sm" 
                                           placeholder="600">
                                </td>
                                <td>
                                    <input type="number" class="form-control form-control-sm" 
                                           placeholder="400">
                                </td>
                                <td class="text-center">
                                    <input type="checkbox" class="form-check-input veta-checkbox" onchange="updateVetaLibreMaster()">
                                </td>
                                <td>
                                    <div class="tapacanto-controls">
                                        <!-- Botón para todos los lados con cuadrado oscuro -->
                                        <button type="button" class="btn-tapacanto btn-all" 
                                                onclick="toggleTapacantoAll(this)" title="Tapacanto en todos los lados">
                                            <i class="ri-stop-fill"></i>
                                        </button>
                                        <!-- Botones direccionales con flechas en círculos -->
                                        <button type="button" class="btn-tapacanto btn-direction" 
                                                onclick="toggleTapacantoDirection(this, 'arriba')" title="Tapacanto Superior">
                                            <i class="ri-arrow-up-circle-fill"></i>
                                        </button>
                                        <button type="button" class="btn-tapacanto btn-direction" 
                                                onclick="toggleTapacantoDirection(this, 'derecha')" title="Tapacanto Derecho">
                                            <i class="ri-arrow-right-circle-fill"></i>
                                        </button>
                                        <button type="button" class="btn-tapacanto btn-direction" 
                                                onclick="toggleTapacantoDirection(this, 'abajo')" title="Tapacanto Inferior">
                                            <i class="ri-arrow-down-circle-fill"></i>
                                        </button>
                                        <button type="button" class="btn-tapacanto btn-direction" 
                                                onclick="toggleTapacantoDirection(this, 'izquierda')" title="Tapacanto Izquierdo">
                                            <i class="ri-arrow-left-circle-fill"></i>
                                        </button>
                                    </div>
                                </td>
                                <td class="text-center">
                                    <button class="btn-delete" onclick="eliminarFila(this)" title="Eliminar pieza">
                                        <i class="ri-delete-bin-2-fill"></i>
                                    </button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Pie de tabla con área clickeable para agregar -->
                <div class="table-add-row border-top" onclick="agregarFilaRapida()" title="Haz clic aquí para agregar una nueva pieza">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <tbody>
                                <tr class="add-row-hover">
                                    <td width="60" class="text-center"></td>
                                    <td width="30"></td>
                                    <td class="text-muted small">Haz clic aquí para agregar una nueva pieza</td>
                                    <td width="40"></td>
                                    <td width="40"></td>
                                    <td width="60"></td>
                                    <td width="200"></td>
                                    <td width="60"></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Botón Optimizar abajo del segmento de piezas -->
<div class="my-3 text-end">
    <button class="btn btn-primary" onclick="optimizarPiezas()">
        <i class="fas fa-magic"></i> Optimizar
    </button>
    <button id="btnDescargarPDF" class="btn btn-outline-secondary ms-2" onclick="descargarPDF()">
        <i class="ri-file-download-line"></i> PDF
    </button>
    <span id="alertaGating" class="ms-3 text-danger small" style="display:none;"></span>
</div>

<!-- Toast: Generando PDF (no desplaza el layout) -->
<div id="toastGenerandoPdf" class="alert alert-secondary shadow-sm py-2 px-3">
    <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
    Generando PDF…
    <button type="button" class="btn-close ms-2" aria-label="Close" onclick="document.getElementById('toastGenerandoPdf').style.display='none'"></button>
 </div>

<!-- Resumen del proyecto (compacto, sin tarjetas) -->
<div id="resumenProyecto" class="mt-3" style="display:none;">
    <div class="p-3 border rounded bg-white mb-2">
        <div class="row gy-2 gx-3 align-items-center small">
            <div class="col-12 col-md-auto"><strong>Proyecto:</strong> <span id="resNombre"></span></div>
            <div class="col-12 col-md-auto"><strong>ID del proyecto:</strong> <span id="resFolio"></span></div>
            <div class="col-12 col-md-auto"><strong>Cliente:</strong> <span id="resCliente"></span> <span class="text-secondary" id="resClienteRut"></span></div>
            <div class="col-12 col-md-auto"><strong>Material:</strong> <span id="resMaterial"></span></div>
            <div class="col-12 col-md-auto"><strong>Dimensiones:</strong> <span class="text-secondary"><span id="resDim"></span></span></div>
            <div class="col-12 col-md-auto"><strong>Márgenes:</strong> <span id="resMargenes">—</span></div>
            <div class="col-12 col-md-auto"><strong>Kerf:</strong> <span id="resKerf">—</span></div>
            <div class="col-12 col-md-auto"><strong>Aprovechamiento:</strong> <span id="resAprovech">—</span></div>
            <div class="col-12 col-md-auto"><strong>Área total:</strong> <span id="resArea">—</span></div>
            <div class="col-12 col-md-auto"><strong>Sobrantes m²:</strong> <span id="resSobrantes">—</span></div>
            <div class="col-12 col-md-auto"><strong>Tapacanto:</strong> <span id="resTapacanto">—</span></div>
            <div class="col-12 col-md-auto d-none" id="wrapResTapML"><strong>ML Tapacanto:</strong> <span id="resTapML">—</span></div>
        </div>
    </div>
</div>

<!-- Área de resultados de optimización -->
<div id="resultadosOptimizacion" class="mt-3" style="display: none;">
    <!-- Barra de estadísticas compacta -->
    <div class="bg-light p-3 rounded mb-3 border">
        <div class="row align-items-center">
            <div class="col-auto">
                <h6 class="mb-0 text-primary">
                    <i class="fas fa-magic"></i> Resultado
                </h6>
            </div>
            <div class="col-auto">
                <span class="badge bg-primary me-2">
                    Tableros usados: <strong id="tablerosUsados">0</strong>
                </span>
            </div>
            <div class="col-auto">
                <span class="badge bg-success me-2">
                    Aprovechamiento: <strong id="aprovechamiento">0%</strong>
                </span>
            </div>
            <div class="col-auto">
                <span class="badge bg-warning me-2">
                    Desperdicio: <strong id="desperdicio">0 mm²</strong>
                </span>
            </div>
            <div class="col-auto">
                <span class="badge bg-info me-2">
                    Tapacantos: <strong id="tapacantos">0 m</strong>
                </span>
            </div>
            <div class="col-auto ms-auto">
                <button id="btnModoManual" type="button" class="btn btn-sm btn-outline-secondary d-none" title="Oculto" disabled>
                    Modo manual: <span id="lblModoManual">Próximamente</span>
                </button>
                <button id="btnGuardarManual" type="button" class="btn btn-sm btn-success ms-2 d-none" title="Oculto" onclick="guardarPosicionManual()">
                    Guardar manual
                </button>
                <button id="btnRestaurarLayout" type="button" class="btn btn-sm btn-outline-warning ms-2 d-none" title="Oculto" onclick="restaurarLayout()">
                    Restaurar
                </button>
            </div>
        </div>
    </div>
    
    <!-- Visualización de tableros -->
    <div id="visualizacionTableros" class="bg-light p-3 rounded fade">
        <!-- Aquí se generarán los SVG de los tableros -->
    </div>
</div>

<script>
    let contadorMateriales = 1;
    let contadorPiezas = 1;
    let clientesCache = [];
    let clienteSeleccionado = null;
    const MSG_TABLERO_REQ = 'Seleccione un tablero para habilitar esta acción';
    const MSG_TAPACANTO_REQ = 'Seleccione un tapacanto para habilitar esta acción';
    // Estado por material (pestaña): piezas y último resultado
    const materialState = {}; // { [index]: { piezas: [...], resultado: {...} } }
    let _dirty = false; // cambios sin optimizar en el material/proyecto actual
    let activeMaterialIndex = 1;
    // Visualización manual
    let modoManual = false;
    let currentTablerosVis = [];
    let dragState = null; // {g, startX, startY}

    // Aplica configuración (tablero, medidas, márgenes, kerf y tapacanto) a una pestaña de material
    function applyConfigToTab(tabIndex){
        try{
            const state = materialState[tabIndex] || {};
            const cfgm = state && state.configuracion_material ? state.configuracion_material : null;
            const resu = state && state.resultado ? state.resultado : {};

            // Tablero por id o por código
            const sel = document.getElementById(`tableroSelect${tabIndex}`);
            if (sel){
                if (cfgm && cfgm.material_id){ sel.value = String(cfgm.material_id); try{ sel.dispatchEvent(new Event('change')); }catch(_e){} }
                else {
                    const codigo = (cfgm && cfgm.material_codigo) || (resu && resu.material && resu.material.codigo) || '';
                    if (codigo){
                        const opt = Array.from(sel.options).find(o=> (o.dataset && (o.dataset.codigo||o.dataset.code)) === String(codigo));
                        if (opt){ sel.value = opt.value; try{ sel.dispatchEvent(new Event('change')); }catch(_e){} }
                    }
                }
            }

            // Dimensiones y parámetros (preferir config; fallback a resultado)
            const aw = document.getElementById(`ancho${tabIndex}`);
            const ah = document.getElementById(`alto${tabIndex}`);
            const mx = document.getElementById(`margenX${tabIndex}`);
            const my = document.getElementById(`margenY${tabIndex}`);
            const ds = document.getElementById(`desperdicioSierra${tabIndex}`);
            if (aw){
                if (cfgm && cfgm.ancho_custom!=null) aw.value = cfgm.ancho_custom;
                else if (resu && resu.material && resu.material.ancho_usado!=null) aw.value = resu.material.ancho_usado;
            }
            if (ah){
                if (cfgm && cfgm.largo_custom!=null) ah.value = cfgm.largo_custom;
                else if (resu && resu.material && resu.material.largo_usado!=null) ah.value = resu.material.largo_usado;
            }
            if (mx){
                if (cfgm && cfgm.margen_x!=null) mx.value = cfgm.margen_x;
                else if (resu && resu.margenes && resu.margenes.margen_x!=null) mx.value = resu.margenes.margen_x;
            }
            if (my){
                if (cfgm && cfgm.margen_y!=null) my.value = cfgm.margen_y;
                else if (resu && resu.margenes && resu.margenes.margen_y!=null) my.value = resu.margenes.margen_y;
            }
            if (ds){
                if (cfgm && cfgm.desperdicio_sierra!=null) ds.value = cfgm.desperdicio_sierra;
                else if (resu && resu.desperdicio_sierra!=null) ds.value = resu.desperdicio_sierra;
            }

            // Tapacanto por código
            try{
                const selTap = document.getElementById(`tapacantoSelect${tabIndex}`);
                if (selTap){
                    const code = (cfgm && cfgm.tapacanto_codigo) || (resu && resu.tapacanto && resu.tapacanto.codigo) || '';
                    if (code){
                        const opt = Array.from(selTap.options).find(o=> (o.dataset && (o.dataset.codigo||o.dataset.code)) === String(code));
                        if (opt){ selTap.value = opt.value; try{ selTap.dispatchEvent(new Event('change')); }catch(_e){} }
                    }
                }
            }catch(__e){}

            // Ajustar visual dependiente del tablero
            try{ cargarDimensionesTablero(tabIndex); }catch(___e){}
        }catch(e){ console.warn('applyConfigToTab falló para pestaña', tabIndex, e); }
    }

    // Construye estructura de visualización desde un resultado de backend (mRes)
    function construirVisualizacionDesdeBackend(mRes){
        try{
            if (!mRes) return [];
            const mX = (mRes.margenes && typeof mRes.margenes.margen_x === 'number') ? mRes.margenes.margen_x : ((mRes.config && typeof mRes.config.margen_x==='number')?mRes.config.margen_x:0);
            const mY = (mRes.margenes && typeof mRes.margenes.margen_y === 'number') ? mRes.margenes.margen_y : ((mRes.config && typeof mRes.config.margen_y==='number')?mRes.config.margen_y:0);
            const tablerosBackend = Array.isArray(mRes.tableros) ? mRes.tableros : [];
            // Numeración global por tipo (nombre + dimensiones normalizadas) para i/j
            const _typeTotals = new Map();
            tablerosBackend.forEach(t=>{
                (t.piezas||[]).forEach(p=>{
                    const a = parseInt(p.ancho||p.width||0,10); const l = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                    const k = `${(p.nombre||'').trim()}|${Math.min(a,l)}x${Math.max(a,l)}`;
                    _typeTotals.set(k, (_typeTotals.get(k)||0) + 1);
                });
            });
            const _typeRunning = new Map();
            const tb = tablerosBackend.map((t, idx)=>{
                const anchoOriginal = (t.ancho || mRes.tablero_ancho_original || 0);
                const altoOriginal = (t.largo || mRes.tablero_largo_original || 0);
                const effW = Math.max(0, anchoOriginal - 2*mX);
                const effH = Math.max(0, altoOriginal - 2*mY);
                return {
                    numero: (idx+1),
                    ancho: anchoOriginal,
                    alto: altoOriginal,
                    margenOriginal: Math.max(mX,mY),
                    anchoUtil: effW,
                    altoUtil: effH,
                    kerf: (typeof mRes.desperdicio_sierra === 'number' ? mRes.desperdicio_sierra : (mRes.config && typeof mRes.config.kerf === 'number' ? mRes.config.kerf : 0)),
                    piezas: (Array.isArray(t.piezas)? t.piezas.map(p=>{
                        const aN = parseInt(p.ancho||p.width||0,10); const lN = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                        const k = `${(p.nombre||'').trim()}|${Math.min(aN,lN)}x${Math.max(aN,lN)}`;
                        const run = (_typeRunning.get(k)||0) + 1; _typeRunning.set(k, run);
                        const tot = _typeTotals.get(k)||run;
                        const px = (p.x!=null? parseFloat(p.x) : 0); const py = (p.y!=null? parseFloat(p.y) : 0);
                        const candA = {x:px, y:py}; const candB = {x:px - mX, y:py - mY};
                        const fits = (c)=> c.x >= -1 && c.y >= -1 && (c.x + aN) <= effW + 1 && (c.y + lN) <= effH + 1;
                        const use = fits(candB) ? candB : (fits(candA) ? candA : candB);
                        return { nombre:p.nombre, x:use.x, y:use.y, ancho:aN, alto:lN, rotada:!!p.rotada, indiceUnidad:run, totalUnidades:tot, tapacantos:(typeof p.tapacantos==='object' && !Array.isArray(p.tapacantos))?p.tapacantos:{arriba:false,derecha:false,abajo:false,izquierda:false} };
                    }) : []),
                    getAprovechamiento(){ return (t.eficiencia_tablero!=null) ? t.eficiencia_tablero : (mRes.eficiencia||0); }
                };
            });
            return tb;
        }catch(e){ console.warn('construirVisualizacionDesdeBackend falló:', e); return []; }
    }
    function getActiveMaterialIndex(){
        const activeTab = document.querySelector('#materialTabs button.nav-link.active');
        if (!activeTab) return 1;
        const m = activeTab.id && activeTab.id.match(/material(\d+)-tab/);
        return m ? parseInt(m[1],10) : 1;
    }

    function piezasFromDOM(){
        // Reutiliza recopilarPiezasDeTabla() pero mapea a objetos planos
        const piezasClase = recopilarPiezasDeTabla();
        return piezasClase.map(p=>({
            cantidad: p.cantidad,
            nombre: p.nombre,
            ancho: p.ancho,
            alto: p.alto,
            veta_libre: !!p.vetaLibre,
            tapacantos: p.tapacantos
        }));
    }

    // Marcar estado sucio ante cambios relevantes
    document.addEventListener('input', (e)=>{
        const t = e.target;
        if (!t || !t.id) return;
        if (t.closest('#piezasTableBody') ||
            t.id.startsWith('ancho') || t.id.startsWith('alto') ||
            t.id.startsWith('margenX') || t.id.startsWith('desperdicioSierra') ||
            t.id.startsWith('tableroSelect') || t.id.startsWith('tapacantoSelect') ||
            t.id === 'clienteInput' || t.id === 'nombreProyecto'){
            _dirty = true;
        }
    }, true);

    function hayResultadoOptimizado(){
        const idx = getActiveMaterialIndex();
        return !!(materialState[idx] && materialState[idx].resultado);
    }

    function limpiarProyectoCompleto(){
        try{
            // limpiar datos de cabecera
            ['clienteInput','rutCliente','folioProyecto','nombreProyecto'].forEach(id=>{ const el=document.getElementById(id); if (el) el.value=''; });
            const res = document.getElementById('resultadosOptimizacion'); if (res){ res.style.display='none'; res.removeAttribute('data-proyecto-id'); res.innerHTML=''; }
            const resumen = document.getElementById('resumenProyecto'); if (resumen){ resumen.style.display='none'; resumen.removeAttribute('data-proyecto-id'); }
        }catch(_e){}
        // Resetear pestañas a solo Material 1
        try{
            const tabsUL = document.getElementById('materialTabs');
            if (tabsUL){
                // eliminar todas las tabs de material excepto la 1 y dejar el botón agregar
                const items = tabsUL.querySelectorAll('li.nav-item');
                items.forEach((li, i)=>{
                    const btn = li.querySelector('button.nav-link');
                    if (btn && btn.id !== 'material1-tab' && btn.id !== 'add-material-tab'){ li.remove(); }
                });
            }
            const content = document.getElementById('materialTabsContent');
            if (content){
                const panes = content.querySelectorAll('.tab-pane');
                panes.forEach((p,i)=>{ if (p.id !== 'material1'){ p.remove(); } });
                // reset de campos del material 1
                ['ancho1','alto1','margenX1','desperdicioSierra1'].forEach(id=>{ const el=document.getElementById(id); if (el) el.value=''; });
                const s1 = document.getElementById('tableroSelect1'); if (s1) s1.selectedIndex = 0;
                const s2 = document.getElementById('tapacantoSelect1'); if (s2) s2.selectedIndex = 0;
                contadorMateriales = 1;
            }
            // tabla piezas
            const tbody = document.getElementById('piezasTableBody'); if (tbody){ tbody.innerHTML=''; contadorPiezas = 0; agregarFilaRapida(); }
        }catch(_e){}
        for (const k in materialState){ delete materialState[k]; }
        _dirty = false; window._resetResultado = true;
    }

    function nuevoProyecto(){
        if (hayResultadoOptimizado()){
            limpiarProyectoCompleto();
            return;
        }
        if (_dirty){
            if (!confirm('Hay cambios sin optimizar. ¿Deseas descartarlos y empezar un proyecto nuevo?')) return;
        }
        limpiarProyectoCompleto();
    }

    function renderPiezasToDOM(piezas){
        const tbody = document.getElementById('piezasTableBody');
        tbody.innerHTML = '';
        contadorPiezas = 0;
        if (!piezas || !piezas.length){
            // Crear una fila base
            agregarFilaRapida();
            return;
        }
        piezas.forEach(p=>{
            agregarFilaConDatos(p.cantidad||1, p.nombre||'', p.ancho||0, p.alto||0, '');
            // aplicar veta y tapacantos
            const tr = document.querySelector('#piezasTableBody tr:last-child');
            const cb = tr.querySelector('td:nth-child(6) input[type="checkbox"]');
            if (cb) cb.checked = !!p.veta_libre;
            const buttons = tr.querySelectorAll('.btn-tapacanto');
            // reset
            buttons.forEach(b=>b.classList.remove('active','btn-primary'));
            if (p.tapacantos){
                const dirs = ['arriba','derecha','abajo','izquierda'];
                const map = {arriba:0, derecha:1, abajo:2, izquierda:3};
                dirs.forEach(dir=>{
                    if (p.tapacantos[dir]){
                        const btn = tr.querySelector(`.btn-direction[onclick*="'${dir}'"]`);
                        if (btn){ btn.classList.add('active','btn-primary'); btn.classList.remove('btn-tapacanto'); }
                    }
                });
                if (dirs.every(d=>p.tapacantos[d])){
                    const all = tr.querySelector('.btn-all');
                    if (all){ all.classList.add('active','btn-primary'); all.classList.remove('btn-tapacanto'); }
                }
            }
        });
        updateVetaLibreMaster();
    }

    // Escuchar cambios de pestaña para guardar/cargar estado
    document.addEventListener('DOMContentLoaded', ()=>{
        const tabs = document.querySelectorAll('#materialTabs button.nav-link');
        tabs.forEach(btn=>{
            btn.addEventListener('shown.bs.tab', (ev)=>{
                const prevIndex = activeMaterialIndex;
                // Guardar del anterior
                if (prevIndex){
                    materialState[prevIndex] = materialState[prevIndex]||{};
                    materialState[prevIndex].piezas = piezasFromDOM();
                }
                // Activar nuevo
                activeMaterialIndex = getActiveMaterialIndex();
                const state = materialState[activeMaterialIndex];
                renderPiezasToDOM(state && state.piezas ? state.piezas : []);
                // Aplicar configuración a la pestaña activa
                applyConfigToTab(activeMaterialIndex);
                // Si hay resultado guardado para este material, re-renderizarlo
                try{
                    const cont = document.getElementById('visualizacionTableros');
                    if (state && state.resultado && Array.isArray(state.resultado.tableros)){
                        const tb = construirVisualizacionDesdeBackend(state.resultado);
                        if (tb && tb.length){
                            if (cont && cont.dataset){ delete cont.dataset.locked; }
                            window.__allowReRender = true;
                            generarVisualizacion(tb);
                            window.__allowReRender = false;
                            if (cont && cont.dataset){ cont.dataset.locked = '1'; }
                        }
                    } else {
                        if (cont){ cont.innerHTML=''; cont.removeAttribute('data-locked'); }
                    }
                }catch(_e){
                    const cont = document.getElementById('visualizacionTableros');
                    if (cont){ cont.innerHTML=''; cont.removeAttribute('data-locked'); }
                }
            });
        });
        // Estado inicial
        activeMaterialIndex = getActiveMaterialIndex();
        materialState[activeMaterialIndex] = materialState[activeMaterialIndex]||{ piezas: piezasFromDOM() };
    });

    function getCsrfToken(){
        const cookie = document.cookie.split('; ').find(r=> r.startsWith('csrftoken='));
        if (cookie) return cookie.split('=')[1];
        const meta = document.querySelector('input[name=csrfmiddlewaretoken], meta[name=csrf-token]');
        return meta ? (meta.value || meta.content) : '';
    }

    // Toggle modo manual en DOMContentLoaded (deshabilitado temporalmente)
    document.addEventListener('DOMContentLoaded', ()=>{
        const btn = document.getElementById('btnModoManual');
        if (btn){
            btn.addEventListener('click', ()=>{
                if (btn.hasAttribute('disabled')){
                    if (typeof flashNotice === 'function'){
                        flashNotice('Modo manual en desarrollo. Próximamente disponible.');
                    }
                    return;
                }
                modoManual = !modoManual;
                const lbl = document.getElementById('lblModoManual');
                if (lbl) lbl.textContent = modoManual ? 'ON' : 'OFF';
                document.querySelectorAll('#visualizacionTableros svg .piece-group').forEach(g=>{
                    g.style.cursor = modoManual ? 'move' : 'default';
                });
            });
        }
    });

    // Manejar selección de cliente desde datalist
    function manejarSeleccionCliente() {
        const clienteInput = document.getElementById('clienteInput');
        const rutInput = document.getElementById('rutCliente');
        const clienteValue = clienteInput.value.trim();
        
        // Solo procesar si tiene al menos 3 caracteres o es una selección exacta
        if (clienteValue.length < 3 && clienteValue !== '[NUEVO CLIENTE]') {
            // Resetear estado para búsquedas muy cortas
            rutInput.disabled = false;
            rutInput.value = '';
            clienteSeleccionado = null;
            generarNombreProyecto();
            return;
        }
        
    // Buscar si el valor coincide con alguna opción del datalist
        const datalist = document.getElementById('clientesDatalist');
        const options = datalist.querySelectorAll('option');
        
        let clienteEncontrado = false;
        
        options.forEach(option => {
            if (option.value === clienteValue) {
                clienteEncontrado = true;
                
                if (option.dataset.id) {
                    // Cliente existente seleccionado desde BD
                    const rut = option.dataset.rut;
                    const id = option.dataset.id;
                    const organizacion = option.dataset.organizacion;
                    const email = option.dataset.email;
                    const telefono = option.dataset.telefono;
                    
                    rutInput.value = rut;
                    rutInput.disabled = true;
                    clienteSeleccionado = {
                        id: id,
                        nombre: clienteValue,
                        rut: rut,
                        organizacion: organizacion,
                        email: email,
                        telefono: telefono
                    };
                    
                    console.log('Cliente seleccionado desde BD:', clienteSeleccionado);
                } else {
                    // No es un cliente existente (opción de sugerencia), permitir crear
                    rutInput.disabled = false;
                    clienteSeleccionado = null;
                }
            }
        });
        
        // Si no se encontró coincidencia exacta, es texto libre (nuevo cliente)
        if (!clienteEncontrado && clienteValue.length >= 3) {
            rutInput.disabled = false;
            if (rutInput.value && rutInput.disabled) {
                rutInput.value = ''; // Limpiar RUT si era un cliente anterior
            }
            clienteSeleccionado = null;
        }
    }

    // Buscar clientes en la base de datos (solo a partir de 2 caracteres) y mostrar [NUEVO CLIENTE] solo si no hay coincidencias
    let timeoutId = null;
    function buscarClientesDB(query) {
        const queryTrimmed = query.trim();
        
        // Cancelar búsqueda anterior si existe
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        
        // Solo buscar si tiene al menos 2 caracteres (más ágil)
        if (queryTrimmed.length < 2) {
            // Limpiar datalist completamente
            const datalist = document.getElementById('clientesDatalist');
            datalist.innerHTML = '';
            // También limpiamos estado seleccionado
            clienteSeleccionado = null;
            return;
        }
        
        // Implementar debounce para evitar muchas requests
        timeoutId = setTimeout(() => {
            // Usamos el endpoint general (core) para evitar conflictos de nombre
            fetch(`{% url 'buscar_clientes_ajax' %}?q=${encodeURIComponent(queryTrimmed)}`)
                .then(response => response.json())
                .then(data => {
                    const lista = Array.isArray(data.clientes) ? data.clientes : [];
                    actualizarDatalistClientes(lista);
                })
                .catch(error => {
                    console.error('Error al buscar clientes:', error);
                });
        }, 200); // Debounce más rápido
    }
    
    function actualizarDatalistClientes(clientes) {
        const datalist = document.getElementById('clientesDatalist');
        // Limpiar
        datalist.innerHTML = '';
        // Agregar clientes encontrados
        clientes.forEach(cliente => {
            const option = document.createElement('option');
            option.value = cliente.nombre;
            option.setAttribute('data-rut', cliente.rut);
            option.setAttribute('data-id', cliente.id);
            option.setAttribute('data-organizacion', cliente.organizacion);
            option.setAttribute('data-email', cliente.email);
            option.setAttribute('data-telefono', cliente.telefono);
            
            // Texto descriptivo
            let texto = `${cliente.nombre} - ${cliente.rut}`;
            if (cliente.organizacion) {
                texto += ` (${cliente.organizacion})`;
            }
            option.textContent = texto;
            
            datalist.appendChild(option);
        });
        // Si no hay coincidencias, ofrecer crear nuevo explícitamente
        if (!clientes || clientes.length === 0) {
            const option = document.createElement('option');
            option.value = '[NUEVO CLIENTE]';
            option.textContent = 'Agregar nuevo cliente';
            datalist.appendChild(option);
        }
    }

    // Generar nombre del proyecto automáticamente (pero mantener editable)
    function generarNombreProyecto() {
        const clienteNombre = document.getElementById('clienteInput').value;
        const nombreProyectoInput = document.getElementById('nombreProyecto');
        const fecha = new Date().toLocaleDateString('es-CL');
        
        // Solo auto-llenar si el campo está vacío o tiene el placeholder/valor automático anterior
        if (clienteNombre && (!nombreProyectoInput.value || 
            nombreProyectoInput.value === nombreProyectoInput.placeholder ||
            nombreProyectoInput.value.includes(' - '))) {
            nombreProyectoInput.value = `${clienteNombre} - ${fecha}`;
        }
    }

    // Formatear RUT automáticamente mientras se escribe
    function formatearRUT(input) {
        // Obtener solo números y la letra K/k
        let valor = input.value.replace(/[^0-9kK]/g, '');
        
        // Convertir k minúscula a mayúscula
        valor = valor.replace(/k/g, 'K');
        
        // Aplicar formato si tiene al menos 2 caracteres
        if (valor.length >= 2) {
            // Separar el dígito verificador (último carácter)
            const cuerpo = valor.slice(0, -1);
            const dv = valor.slice(-1);
            
            // Formatear el cuerpo con puntos cada 3 dígitos desde la derecha
            const cuerpoFormateado = cuerpo.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            
            // Combinar con guión antes del dígito verificador
            valor = cuerpoFormateado + '-' + dv;
        }
        
        // Actualizar el valor del input
        input.value = valor;
    }

    // Cargar dimensiones del tablero seleccionado
    function cargarDimensionesTablero(materialId) {
        const tableroSelect = document.getElementById(`tableroSelect${materialId}`);
        const selectedOption = tableroSelect.selectedOptions[0];
        
        if (selectedOption && selectedOption.value) {
            const a = parseFloat(selectedOption.dataset.ancho||'0');
            const b = parseFloat(selectedOption.dataset.alto||'0');
            const mayor = Math.max(a,b); const menor = Math.min(a,b);
            document.getElementById(`ancho${materialId}`).value = mayor;
            document.getElementById(`alto${materialId}`).value = menor;
            validarTodasLasPiezasContraTablero();
            // Si cambió el tablero, permitir que al optimizar se repinte
            try{ const contVis = document.getElementById('visualizacionTableros'); if (contVis && contVis.dataset) delete contVis.dataset.locked; }catch(_e){}
        }
    }

    // Habilitar edición solo de dimensiones, márgenes y desperdicio
    function habilitarEdicionDimensiones(materialId) {
        // Solo edita los campos de dimensiones, márgenes y desperdicio, NO el selector de tablero ni tapacanto
        const camposEditables = document.querySelectorAll(`
            #ancho${materialId}, 
            #alto${materialId}, 
            #margenX${materialId}, 
            #desperdicioSierra${materialId}
        `);
        
        const btnText = document.getElementById(`btnEditText${materialId}`);
        
        const isDisabled = camposEditables[0].disabled;
        
        camposEditables.forEach(input => {
            input.disabled = !isDisabled;
            if (!isDisabled) {
                input.classList.remove('border-warning');
            } else {
                input.classList.add('border-warning');
            }
        });
        
        btnText.textContent = isDisabled ? 'Guardar medidas' : 'Editar medidas';
    }

    // Agregar nueva pestaña de material
    function agregarMaterial() {
        // Confirmar si hay cambios sin optimizar en pestaña activa
        if (!hayResultadoOptimizado() && _dirty){
            const ok = confirm('Tienes cambios sin optimizar. ¿Deseas continuar y agregar otro material igualmente?');
            if (!ok) return;
        }
        contadorMateriales++;
        const tabsContainer = document.getElementById('materialTabs');
        const contentContainer = document.getElementById('materialTabsContent');
        
        // Crear nueva pestaña
        const newTab = document.createElement('li');
        newTab.className = 'nav-item';
        newTab.setAttribute('role', 'presentation');
        newTab.innerHTML = `
            <button class="nav-link" id="material${contadorMateriales}-tab" data-bs-toggle="tab" 
                    data-bs-target="#material${contadorMateriales}" type="button" role="tab" ondblclick="duplicarMaterial(${contadorMateriales})" title="Doble clic para duplicar material">
                Material ${contadorMateriales}
            </button>
        `;
        
        // Insertar antes del botón "Agregar Material"
        tabsContainer.insertBefore(newTab, tabsContainer.lastElementChild);
        
        // Crear contenido de la pestaña (clonar el contenido del material 1) evitando reemplazos masivos de '1'
        const base = document.getElementById('material1');
        const clone = base.cloneNode(true);
        // Ajustar IDs y for/targets específicos del nuevo índice
        const updateId = (el, attr) => {
            const v = el.getAttribute(attr);
            if (!v) return;
            const m = v.match(/^(.*?)(\d+)$/);
            if (m) el.setAttribute(attr, `${m[1]}${contadorMateriales}`);
        };
        clone.id = `material${contadorMateriales}`;
        // Actualizar elementos con id que terminan en número
        clone.querySelectorAll('[id]').forEach(el=> updateId(el, 'id'));
        // Actualizar labels for
        clone.querySelectorAll('label[for]').forEach(el=> updateId(el, 'for'));
        // Actualizar select targets de data-bs-target y aria-controls
        clone.querySelectorAll('[data-bs-target]').forEach(el=>{
            const val = el.getAttribute('data-bs-target');
            if (val && val.endsWith('1')) el.setAttribute('data-bs-target', `#material${contadorMateriales}`);
        });
        clone.querySelectorAll('[aria-controls]').forEach(el=>{
            const val = el.getAttribute('aria-controls');
            if (val && val.endsWith('1')) el.setAttribute('aria-controls', `material${contadorMateriales}`);
        });
        // Corregir handlers inline que usan el índice 1
        const fixInlineIndex = (selector, attr, fnName) => {
            clone.querySelectorAll(selector).forEach(el=>{
                const v = el.getAttribute(attr);
                if (!v) return;
                el.setAttribute(attr, v.replace(/\(\s*1\s*\)/, `(${contadorMateriales})`));
            });
        };
        fixInlineIndex("[onchange*='cargarDimensionesTablero(']", 'onchange', 'cargarDimensionesTablero');
        fixInlineIndex("[onclick*='habilitarEdicionDimensiones(']", 'onclick', 'habilitarEdicionDimensiones');
        // Limpiar valores de inputs de piezas para no arrastrar estado
        clone.querySelectorAll('table input, table select, table textarea').forEach(el=>{
            if (el.type === 'checkbox' || el.type === 'radio') el.checked = false; else el.value = '';
        });
        // Insertar en el contenedor
        const newContent = document.createElement('div');
        newContent.className = 'tab-pane fade';
        newContent.id = `material${contadorMateriales}`;
        newContent.setAttribute('role', 'tabpanel');
        newContent.innerHTML = clone.innerHTML;
        
        contentContainer.appendChild(newContent);
        
        // Activar la nueva pestaña
        const newTabBtn = document.getElementById(`material${contadorMateriales}-tab`);
        // Hook de cambio para guardar/restaurar estado por material
        newTabBtn.addEventListener('shown.bs.tab', ()=>{
            const prevIndex = activeMaterialIndex;
            if (prevIndex){
                materialState[prevIndex] = materialState[prevIndex]||{};
                materialState[prevIndex].piezas = piezasFromDOM();
            }
            activeMaterialIndex = getActiveMaterialIndex();
            const state = materialState[activeMaterialIndex];
            renderPiezasToDOM(state && state.piezas ? state.piezas : []);
            const cont = document.getElementById('visualizacionTableros');
            if (cont){ cont.innerHTML = ''; cont.removeAttribute('data-locked'); }
            // Aplicar configuración a la pestaña mostrada
            applyConfigToTab(activeMaterialIndex);
        });
        new bootstrap.Tab(newTabBtn).show();

        // Inicializar las dimensiones del nuevo material según el tablero seleccionado (si hay)
        try {
            const sel = document.getElementById(`tableroSelect${contadorMateriales}`);
            if (sel && sel.value) {
                cargarDimensionesTablero(contadorMateriales);
            } else {
                // Reiniciar a vacío para evitar arrastre visual
                const ax = document.getElementById(`ancho${contadorMateriales}`);
                const ay = document.getElementById(`alto${contadorMateriales}`);
                if (ax) ax.value = '';
                if (ay) ay.value = '';
            }
        } catch(_e) {}
    }

    // Toggle tapacanto direccional
    function toggleTapacanto(button, direccion) {
        // Requiere tapacanto seleccionado en la pestaña activa
        const matIdx = getActiveMaterialIndex();
        const sel = document.getElementById(`tapacantoSelect${matIdx}`);
        if (!sel || !sel.value) {
            button.classList.add('shake');
            setTimeout(()=> button.classList.remove('shake'), 400);
            return;
        }
        button.classList.toggle('active');
        
        // Opcional: cambiar color del botón activo
        if (button.classList.contains('active')) {
            button.classList.add('btn-primary');
            button.classList.remove('btn-tapacanto');
        } else {
            button.classList.remove('btn-primary');
            button.classList.add('btn-tapacanto');
        }
    }

    // Agregar fila rápida a la tabla
    function agregarFilaRapida() {
        contadorPiezas++;
        const tbody = document.getElementById('piezasTableBody');
        const newRow = document.createElement('tr');
        
        newRow.innerHTML = `
            <td>${contadorPiezas}</td>
            <td>
                <input type="number" class="form-control form-control-sm" 
                       value="1" min="1">
            </td>
            <td>
                <input type="text" class="form-control form-control-sm" 
                       value="Pieza ${contadorPiezas}" 
                       placeholder="Nombre de la pieza"
                       data-es-predeterminado="true"
                       onfocus="manejarFocoPieza(this)"
                       onblur="manejarBlurPieza(this)">
            </td>
            <td>
                <input type="number" class="form-control form-control-sm" 
                       placeholder="600">
            </td>
            <td>
                <input type="number" class="form-control form-control-sm" 
                       placeholder="400">
            </td>
            <td class="text-center">
                <input type="checkbox" class="form-check-input veta-checkbox" onchange="updateVetaLibreMaster()">
            </td>
            <td>
                <div class="tapacanto-controls">
                    <button type="button" class="btn-tapacanto btn-all" 
                            onclick="toggleTapacantoAll(this)" title="Tapacanto en todos los lados">
                        <i class="ri-stop-fill"></i>
                    </button>
                    <button type="button" class="btn-tapacanto btn-direction" 
                            onclick="toggleTapacantoDirection(this, 'arriba')" title="Tapacanto Superior">
                        <i class="ri-arrow-up-circle-fill"></i>
                    </button>
                    <button type="button" class="btn-tapacanto btn-direction" 
                            onclick="toggleTapacantoDirection(this, 'derecha')" title="Tapacanto Derecho">
                        <i class="ri-arrow-right-circle-fill"></i>
                    </button>
                    <button type="button" class="btn-tapacanto btn-direction" 
                            onclick="toggleTapacantoDirection(this, 'abajo')" title="Tapacanto Inferior">
                        <i class="ri-arrow-down-circle-fill"></i>
                    </button>
                    <button type="button" class="btn-tapacanto btn-direction" 
                            onclick="toggleTapacantoDirection(this, 'izquierda')" title="Tapacanto Izquierdo">
                        <i class="ri-arrow-left-circle-fill"></i>
                    </button>
                </div>
            </td>
            <td class="text-center">
                <button class="btn-delete" onclick="eliminarFila(this)" title="Eliminar pieza">
                    <i class="ri-delete-bin-2-fill"></i>
                </button>
            </td>
        `;
        
        tbody.appendChild(newRow);
        // Sincronizar maestro tras agregar
        updateVetaLibreMaster();
        updateTapacantoMaster();
        engancharValidacionFila(newRow);
        _dirty = true;
    }

    // Eliminar fila de la tabla
    function eliminarFila(button) {
        const row = button.closest('tr');
        row.remove();
        
        // Renumerar las filas
        const rows = document.querySelectorAll('#piezasTableBody tr');
        rows.forEach((row, index) => {
            row.cells[0].textContent = index + 1;
        });
        
        contadorPiezas = rows.length;
        // Sincronizar maestro tras eliminar
        updateVetaLibreMaster();
        updateTapacantoMaster();
        _dirty = true;
    }

    // Duplica la pestaña/material indicado copiando configuraciones y piezas si existen
    function duplicarMaterial(idx){
        const basePane = document.getElementById(`material${idx}`);
        if (!basePane){ return; }
        // Crear una nueva pestaña normal
        const prevCount = contadorMateriales;
        agregarMaterial();
        const nuevoIdx = contadorMateriales;
        // Copiar valores de configuración básicos
        const copiarVal = (pref) => {
            const src = document.getElementById(`${pref}${idx}`);
            const dst = document.getElementById(`${pref}${nuevoIdx}`);
            if (src && dst) dst.value = src.value;
        };
        ['ancho','alto','margenX','desperdicioSierra'].forEach(copiarVal);
        const selMatSrc = document.getElementById(`tableroSelect${idx}`);
        const selMatDst = document.getElementById(`tableroSelect${nuevoIdx}`);
        if (selMatSrc && selMatDst){ selMatDst.value = selMatSrc.value; try{ selMatDst.dispatchEvent(new Event('change')); }catch(_e){} }
        const selTapSrc = document.getElementById(`tapacantoSelect${idx}`);
        const selTapDst = document.getElementById(`tapacantoSelect${nuevoIdx}`);
        if (selTapSrc && selTapDst){ selTapDst.value = selTapSrc.value; }
        // Copiar piezas desde estado si hay; si no, desde DOM actual si duplicamos la activa
        let piezasBase = (materialState[idx] && Array.isArray(materialState[idx].piezas)) ? materialState[idx].piezas : null;
        if (!piezasBase && getActiveMaterialIndex() === idx){ piezasBase = piezasFromDOM(); }
        if (piezasBase){
            materialState[nuevoIdx] = materialState[nuevoIdx] || {};
            materialState[nuevoIdx].piezas = JSON.parse(JSON.stringify(piezasBase));
            renderPiezasToDOM(materialState[nuevoIdx].piezas);
        }
        _dirty = true;
        try{ if (typeof flashNotice === 'function') flashNotice('Material duplicado. Recuerda optimizar.'); }catch(_e){}
    }

    function agregarFilasHome(){
        // Gating: requiere tablero seleccionado
        const matIdx = getActiveMaterialIndex();
        const sel = document.getElementById(`tableroSelect${matIdx}`);
        if (!sel || !sel.value){
            flashNotice('Seleccione un tablero antes de fijar filas');
            return;
        }
        const deseadas = Math.max(1, Math.min(200, parseInt(document.getElementById('cantidadFilasHome').value)||1));
        const tbody = document.getElementById('piezasTableBody');
        const actuales = tbody.querySelectorAll('tr').length;
        if (actuales < deseadas){
            for(let i=0;i<(deseadas-actuales);i++) agregarFilaRapida();
        } else if (actuales > deseadas){
            for(let i=0;i<(actuales-deseadas);i++){
                const last = tbody.lastElementChild; if(last) last.remove();
            }
            // Renumerar
            [...tbody.querySelectorAll('tr')].forEach((row, idx)=>{ row.cells[0].textContent = idx+1; });
            contadorPiezas = deseadas;
        }
        _dirty = true;
    }

    // Avisos simples
    function flashNotice(msg){
        const el = document.getElementById('alertaGating');
        if(!el) return;
        el.textContent = msg; el.style.display='inline';
        setTimeout(()=>{ el.style.display='none'; }, 3000);
    }

    // Importar piezas desde CSV
    document.getElementById('importPiezasFile').addEventListener('change', async (e)=>{
        const file = e.target.files[0]; if(!file) return;
        const text = await file.text();
        // columnas: cantidad,nombre,ancho_mm,alto_mm,veta_libre,tapacantos
        const rows = text.split(/\r?\n/).filter(r=>r.trim());
        const header = rows.shift();
        const cols = (header||'').split(',').map(h=>h.trim().toLowerCase());
        const req = ['cantidad','nombre','ancho_mm','alto_mm'];
        const miss = req.filter(k=>!cols.includes(k));
        if(miss.length){ flashNotice('CSV inválido. Faltan columnas: '+miss.join(', ')); return; }
        const idx = Object.fromEntries(cols.map((c,i)=>[c,i]));
        rows.forEach(r=>{
            const p=r.split(','); if(!p.length) return;
            agregarFilaRapida();
            const tr = document.querySelector('#piezasTableBody tr:last-child');
            tr.querySelector('td:nth-child(2) input').value = parseInt(p[idx['cantidad']]||'1',10);
            tr.querySelector('td:nth-child(3) input').value = p[idx['nombre']]||'';
            tr.querySelector('td:nth-child(4) input').value = parseFloat(p[idx['ancho_mm']]||'');
            tr.querySelector('td:nth-child(5) input').value = parseFloat(p[idx['alto_mm']]||'');
            const veta = tr.querySelector('.veta-checkbox');
            if(veta && cols.includes('veta_libre')) veta.checked = (p[idx['veta_libre']]+''||'').trim()=='1';
            if(cols.includes('tapacantos')){
                const t = (p[idx['tapacantos']]||'').toLowerCase();
                const map = {arriba:'ri-arrow-up-circle-fill', derecha:'ri-arrow-right-circle-fill', abajo:'ri-arrow-down-circle-fill', izquierda:'ri-arrow-left-circle-fill'};
                Object.keys(map).forEach(dir=>{
                    if(t.includes('todos')||t.includes(dir)){
                        const icon = map[dir];
                        const btn = tr.querySelector(`.btn-direction i.${icon}`);
                        if(btn) btn.parentElement.classList.add('active','btn-primary');
                    }
                });
            }
            validarFila(tr);
        });
        flashNotice(`Importadas ${rows.length} filas`);
        _dirty = true;
    });

    // Validación de piezas contra tablero disponible
    function getDimensionesUtiles(){
        const ancho = parseFloat(document.getElementById('ancho1').value||'0');
        const alto = parseFloat(document.getElementById('alto1').value||'0');
        const mx = parseFloat(document.getElementById('margenX1').value||'0');
        const my = parseFloat(document.getElementById('margenY1').value||'0');
        return {ux: Math.max(0, ancho - 2*mx), uy: Math.max(0, alto - 2*my)};
    }
    function validarFila(tr){
        const {ux, uy} = getDimensionesUtiles();
        const wInput = tr.querySelector('td:nth-child(4) input');
        const hInput = tr.querySelector('td:nth-child(5) input');
        if(!wInput||!hInput) return;
        const w = parseFloat(wInput.value||'0');
        const h = parseFloat(hInput.value||'0');
        const veta = tr.querySelector('.veta-checkbox');
        const libre = veta ? veta.checked : false;

        // resetear estado visual
        wInput.classList.remove('is-invalid');
        hInput.classList.remove('is-invalid');

        let ok = false;
        if (libre) {
            const fitsNormal = (w <= ux && h <= uy);
            const fitsRotada = (h <= ux && w <= uy);
            ok = fitsNormal || fitsRotada;
            if (!ok) {
                // Elegir orientación con menor violación y marcar SOLO esos campos
                const violN_W = Math.max(0, w - ux);
                const violN_H = Math.max(0, h - uy);
                const sumN = violN_W + violN_H;
                const violR_W = Math.max(0, h - ux); // w mapeado a Y
                const violR_H = Math.max(0, w - uy); // h mapeado a X
                const sumR = violR_W + violR_H;
                if (sumN <= sumR) {
                    if (w > ux) wInput.classList.add('is-invalid');
                    if (h > uy) hInput.classList.add('is-invalid');
                } else {
                    // En rotada, el exceso de h se compara con ux y el de w con uy
                    if (h > ux) hInput.classList.add('is-invalid');
                    if (w > uy) wInput.classList.add('is-invalid');
                }
            }
        } else {
            ok = (w <= ux && h <= uy);
            if (!ok) {
                if (w > ux) wInput.classList.add('is-invalid');
                if (h > uy) hInput.classList.add('is-invalid');
            }
        }

        // Sólo señalizar en los campos de medida; no agregar badges que muevan el nombre
        const badge = tr.querySelector('.pieza-imposible');
        if (badge) badge.remove();
    }
    function engancharValidacionFila(tr){
        const w = tr.querySelector('td:nth-child(4) input');
        const h = tr.querySelector('td:nth-child(5) input');
        if(w) w.addEventListener('input', ()=>validarFila(tr));
        if(h) h.addEventListener('input', ()=>validarFila(tr));
    }
    function validarTodasLasPiezasContraTablero(){
        document.querySelectorAll('#piezasTableBody tr').forEach(tr=>validarFila(tr));
    }

    // Función para manejar el botón "todos los lados"
    function toggleTapacantoAll(button) {
        const fila = button.closest('tr');
        const selTap = document.getElementById(`tapacantoSelect${getActiveMaterialIndex()}`);
        if (!selTap || !selTap.value){
            if(button){ button.classList.add('shake'); setTimeout(()=>button.classList.remove('shake'),400); }
            flashNotice('Seleccione un tapacanto antes de marcar lados');
            return;
        }
        const botonesDireccionales = fila.querySelectorAll('.btn-direction');
        
        // Toggle del botón "todos"
        button.classList.toggle('active');
        
        if (button.classList.contains('active')) {
            // Si "todos" está activo, desactivar todos los direccionales
            botonesDireccionales.forEach(btn => btn.classList.remove('active'));
        }
        // Sincronizar maestro de tapacanto
        updateTapacantoMaster();
    }

    // Función para manejar los botones direccionales
    function toggleTapacantoDirection(button, direccion) {
        const fila = button.closest('tr');
        const botonTodos = fila.querySelector('.btn-all');
        // Bloquear si no hay tapacanto seleccionado
        const selTap = document.getElementById(`tapacantoSelect${getActiveMaterialIndex()}`);
        if (!selTap || !selTap.value){
            if(button){ button.classList.add('shake'); setTimeout(()=>button.classList.remove('shake'),400); }
            flashNotice('Seleccione un tapacanto antes de marcar lados');
            return;
        }
        
        // Toggle del botón direccional
        button.classList.toggle('active');
        
        // Si se activa cualquier direccional, desactivar el botón "todos"
        if (button.classList.contains('active')) {
            botonTodos.classList.remove('active');
        }
        
        // Verificar si todos los direccionales están desactivados para reactivar "todos"
        const botonesActivos = fila.querySelectorAll('.btn-direction.active');
        if (botonesActivos.length === 0) {
            // Opcional: podrías reactivar automáticamente "todos" si no hay ninguno seleccionado
            // botonTodos.classList.add('active');
        }

        // Mantener sincronizado el maestro de tapacanto
        updateTapacantoMaster();
    }

    // Función de optimización (placeholder)
    function optimizar() {
        alert('Función de optimización en desarrollo...');
        // Aquí se implementaría la lógica de optimización
    }

    // Función para cargar ejemplo (cliente + 2 materiales con piezas válidas)
    function cargarEjemplo() {
        console.log('Iniciando carga de ejemplo (cliente + 2 materiales)...');
        try {
            // 0) Cliente y proyecto de ejemplo
            try {
                const clienteInput = document.getElementById('clienteInput');
                const rutInput = document.getElementById('rutCliente');
                const nombreProyecto = document.getElementById('nombreProyecto');
                if (clienteInput) clienteInput.value = 'Cliente Ejemplo S.A.';
                if (rutInput) { rutInput.disabled = false; rutInput.value = '76.543.210-9'; }
                if (nombreProyecto && (!nombreProyecto.value || nombreProyecto.value === nombreProyecto.placeholder)) {
                    nombreProyecto.value = 'Proyecto de Ejemplo Doble Material';
                }
                // Refrescar resumen superior si existe
                const rc = document.getElementById('resCliente'); if (rc) rc.textContent = clienteInput ? clienteInput.value : '';
                const rr = document.getElementById('resClienteRut'); if (rr) rr.textContent = rutInput ? ` (${rutInput.value})` : '';
            } catch(_e) { console.warn('No se pudo precargar datos de cliente ejemplo:', _e); }

            // 1) Asegurar 2 materiales
            while (typeof contadorMateriales === 'number' && contadorMateriales < 2) {
                agregarMaterial();
            }

            // Helper para activar tab por índice
            const activarTab = (idx) => {
                const btn = document.getElementById(`material${idx}-tab`);
                if (btn && window.bootstrap && typeof bootstrap.Tab === 'function') {
                    new bootstrap.Tab(btn).show();
                } else if (btn) {
                    btn.click();
                }
            };

            // 2) Configurar material 1
            activarTab(1);
            limpiarTablaSinConfirmacion();
            const selMat1 = document.getElementById('tableroSelect1');
            if (!selMat1) throw new Error('Select tableroSelect1 no encontrado');
            const opt1 = selMat1.querySelector('option[value]:not([value=""])');
            if (opt1) selMat1.value = opt1.value;
            try { cargarDimensionesTablero(1); } catch(e){ console.warn('No se pudo cargar dimensiones del material 1:', e.message); }
            const piezasMat1 = [
                { cantidad: 2, pieza: 'Lateral', ancho: 700, alto: 400, descripcion: '' },
                { cantidad: 1, pieza: 'Base',    ancho: 800, alto: 500, descripcion: '' },
                { cantidad: 2, pieza: 'Repisa',  ancho: 700, alto: 300, descripcion: '' }
            ];
            piezasMat1.forEach(p => agregarFilaConDatos(p.cantidad, p.pieza, p.ancho, p.alto, p.descripcion));

            // 3) Configurar material 2
            activarTab(2);
            limpiarTablaSinConfirmacion();
            const selMat2 = document.getElementById('tableroSelect2');
            if (!selMat2) throw new Error('Select tableroSelect2 no encontrado');
            const opt2 = selMat2.querySelector('option[value]:not([value=""])');
            if (opt2) selMat2.value = opt2.value;
            try { cargarDimensionesTablero(2); } catch(e){ console.warn('No se pudo cargar dimensiones del material 2:', e.message); }
            const piezasMat2 = [
                { cantidad: 2, pieza: 'Puerta',  ancho: 500, alto: 900, descripcion: '' },
                { cantidad: 4, pieza: 'Frente',  ancho: 600, alto: 250, descripcion: '' },
                { cantidad: 1, pieza: 'Tapa',    ancho: 900, alto: 450, descripcion: '' }
            ];
            piezasMat2.forEach(p => agregarFilaConDatos(p.cantidad, p.pieza, p.ancho, p.alto, p.descripcion));

            // Volver a dejar activo el material 1
            activarTab(1);

            // 4) Resumen simple
            const total1 = piezasMat1.reduce((a,b)=> a + (b.cantidad||1), 0);
            const total2 = piezasMat2.reduce((a,b)=> a + (b.cantidad||1), 0);
            console.log('✅ Ejemplo cargado: Cliente + 2 materiales');
            alert(`✅ Ejemplo cargado\n\n• Cliente: Cliente Ejemplo S.A. (76.543.210-9)\n• Material 1: ${total1} unidades en ${piezasMat1.length} tipos\n• Material 2: ${total2} unidades en ${piezasMat2.length} tipos`);
        } catch (error) {
            console.error('Error general al cargar ejemplo:', error);
            alert('Error al cargar el ejemplo: ' + error.message + '. Revisa la consola para más detalles.');
        }
    }

    // Al cargar, bloquear UI si no hay tablero/tapacanto seleccionados (por pestaña activa)
    document.addEventListener('DOMContentLoaded', () => {
        const btnAdd = document.getElementById('btnAgregarFila');
        const tbody = document.getElementById('piezasTableBody');
        const addRowArea = document.querySelector('.table-add-row');
        const chkVetaMaster = document.getElementById('vetaLibreMaster');
        const chkTapMaster = document.getElementById('tapacantoMaster');

        const getActiveSelects = () => {
            const idx = getActiveMaterialIndex();
            return {
                tapSel: document.getElementById(`tapacantoSelect${idx}`),
                tableroSel: document.getElementById(`tableroSelect${idx}`) || document.getElementById('materialSelect')
            };
        };

        const actualizarBloqueoTabla = () => {
            const { tapSel, tableroSel } = getActiveSelects();
            // Permitir edición inmediata en modo edición de proyecto (cuando hay data-proyecto-id)
            const isEditMode = !!(document.getElementById('resultadosOptimizacion') && document.getElementById('resultadosOptimizacion').dataset && document.getElementById('resultadosOptimizacion').dataset.proyectoId);
            const ok = !!(tableroSel && (tableroSel.value || isEditMode));
            const inputFilas = document.getElementById('cantidadFilasHome');
            if (btnAdd) btnAdd.disabled = !ok;
            if (inputFilas) inputFilas.disabled = !ok;
            if (tbody) {
                tbody.style.pointerEvents = ok ? 'auto' : 'none';
                tbody.style.opacity = ok ? '1' : '0.6';
                tbody.classList.toggle('gated', !ok);
                tbody.classList.toggle('cursor-x', !ok);
                if (!ok) tbody.setAttribute('title', MSG_TABLERO_REQ); else tbody.removeAttribute('title');
            }
            if (addRowArea){
                addRowArea.style.pointerEvents = ok ? 'auto' : 'none';
                addRowArea.classList.toggle('gated', !ok);
                addRowArea.classList.toggle('cursor-x', !ok);
                addRowArea.setAttribute('title', ok ? '' : MSG_TABLERO_REQ);
            }
            if (chkVetaMaster){
                chkVetaMaster.disabled = !ok;
                chkVetaMaster.title = ok ? 'Marcar/Desmarcar veta libre en todas las piezas' : MSG_TABLERO_REQ;
            }
            if (chkTapMaster){
                chkTapMaster.disabled = !ok || !(tapSel && tapSel.value);
                chkTapMaster.title = (!ok) ? MSG_TABLERO_REQ : (tapSel && tapSel.value ? 'Aplicar tapacanto en todos los lados a todas las piezas' : MSG_TAPACANTO_REQ);
            }
        };
        const actualizarBotonesTap = () => {
            const { tapSel, tableroSel } = getActiveSelects();
            const habilitado = !!(tapSel && tapSel.value);
            document.querySelectorAll('.tapacanto-controls button').forEach(btn => {
                btn.disabled = !habilitado;
                btn.classList.toggle('disabled', !habilitado);
                btn.classList.toggle('gated', !habilitado);
                btn.title = habilitado ? (btn.title||'Tapacanto') : MSG_TAPACANTO_REQ;
            });
            const chkTapMaster2 = document.getElementById('tapacantoMaster');
            if (chkTapMaster2){
                const tableroOk = !!(tableroSel && tableroSel.value);
                chkTapMaster2.disabled = !tableroOk || !habilitado;
                chkTapMaster2.title = (!tableroOk) ? MSG_TABLERO_REQ : (habilitado ? 'Aplicar tapacanto en todos los lados a todas las piezas' : MSG_TAPACANTO_REQ);
            }
        };
        actualizarBloqueoTabla();
        actualizarBotonesTap();
        // Reaccionar globalmente a cambios en selects por pestaña
        document.addEventListener('change', (ev)=>{
            const el = ev.target;
            if (!el || !el.id) return;
            if (el.id.startsWith('tableroSelect') || el.id.startsWith('tapacantoSelect')){
                actualizarBloqueoTabla();
                actualizarBotonesTap();
            }
        });
    });
    // === Maestro Tapacanto ===
    function toggleTapacantoTodos(checked) {
        const filas = document.querySelectorAll('#piezasTableBody tr');
        filas.forEach(fila => {
            const botonTodos = fila.querySelector('.btn-all');
            const botonesDireccion = fila.querySelectorAll('.btn-direction');
            if (checked) {
                // Activar botón "todos" y desactivar direccionales
                if (botonTodos) botonTodos.classList.add('active');
                botonesDireccion.forEach(btn => btn.classList.remove('active'));
            } else {
                // Desactivar "todos" sin tocar direccionales (usuario decide)
                if (botonTodos) botonTodos.classList.remove('active');
            }
        });
        // Estado maestro real
        const master = document.getElementById('tapacantoMaster');
        if (master) master.checked = checked;
    }

    function updateTapacantoMaster() {
        const filas = document.querySelectorAll('#piezasTableBody tr');
        if (filas.length === 0) return;
        let allTodos = true;
        filas.forEach(fila => {
            const botonTodos = fila.querySelector('.btn-all');
            const dirs = fila.querySelectorAll('.btn-direction');
            const countActivos = Array.from(dirs).filter(d => d.classList.contains('active')).length;
            const filaConTodos = (botonTodos && botonTodos.classList.contains('active')) || countActivos === 4;
            if (!filaConTodos) allTodos = false;
        });
        const master = document.getElementById('tapacantoMaster');
        if (master) master.checked = allTodos;
    }

    // Función auxiliar para limpiar tabla sin confirmaciones
    function limpiarTablaSinConfirmacion() {
        console.log('Limpiando tabla...');
        // Resetear contador
        contadorPiezas = 1;
        
        // Limpiar la tabla manteniendo solo el encabezado
        const tbody = document.querySelector('.table tbody');
        if (tbody) {
            tbody.innerHTML = '';
            console.log('Tabla limpiada');
        } else {
            console.error('No se encontró el tbody de la tabla');
        }
    }

    // Función para validar nombre de pieza
    function validarNombrePieza(input, numeroPieza) {
        if (input.value.trim() === '') {
            input.value = `Pieza ${numeroPieza}`;
            input.setAttribute('data-es-predeterminado', 'true');
        }
    }

    // Función para manejar el foco en el campo de nombre
    function manejarFocoPieza(input) {
        const esPredeterminado = input.getAttribute('data-es-predeterminado') === 'true';
        if (esPredeterminado) {
            input.value = '';
            input.setAttribute('data-es-predeterminado', 'false');
        }
    }

    // Función para manejar cuando se pierde el foco
    function manejarBlurPieza(input) {
        const numeroPieza = obtenerNumeroPieza(input);
        if (input.value.trim() === '') {
            input.value = `Pieza ${numeroPieza}`;
            input.setAttribute('data-es-predeterminado', 'true');
        } else {
            input.setAttribute('data-es-predeterminado', 'false');
        }
    }

    // Función para detectar el número de pieza basado en la fila
    function obtenerNumeroPieza(input) {
        const fila = input.closest('tr');
        const numeroCell = fila.querySelector('td:first-child');
        return numeroCell ? numeroCell.textContent.trim() : '1';
    }

    // Función para limpiar todo
    function limpiarTodo() {
        if (!confirm('¿Limpiar piezas de la tabla actual?')) return;
        const tbody = document.querySelector('.table tbody');
        if (tbody) tbody.innerHTML = '';
        contadorPiezas = 0; agregarFilaRapida();
        _dirty = true; window._resetResultado = true;
    }

    // Función auxiliar para agregar fila con datos específicos
    function agregarFilaConDatos(cantidad, pieza, ancho, alto, descripcion) {
        const tbody = document.querySelector('.table tbody');
        
        if (!tbody) {
            console.error('No se encontró el tbody de la tabla');
            throw new Error('No se encontró la tabla para agregar piezas');
        }
        
        // Validar parámetros
        cantidad = cantidad || 1;
        // Asegurar que la numeración comience en 1 siempre
        if (typeof contadorPiezas !== 'number') contadorPiezas = 0;
        contadorPiezas++;
        pieza = pieza || `Pieza ${contadorPiezas}`;
        ancho = ancho || 0;
        alto = alto || 0;
        descripcion = descripcion || '';
        
        const nuevaFila = `
            <tr>
                <td class="text-center">${contadorPiezas}</td>
                <td>
                    <input type="number" class="form-control form-control-sm" 
                           value="${cantidad}" min="1" max="999">
                </td>
                <td>
                    <input type="text" class="form-control form-control-sm" 
                           value="${pieza}" placeholder="Nombre de la pieza"
                           data-es-predeterminado="${pieza.startsWith('Pieza ') ? 'true' : 'false'}"
                           onfocus="manejarFocoPieza(this)"
                           onblur="manejarBlurPieza(this)">
                </td>
                <td>
                    <input type="number" class="form-control form-control-sm" 
                           value="${ancho}" min="1" max="9999" placeholder="Ancho">
                </td>
                <td>
                    <input type="number" class="form-control form-control-sm" 
                           value="${alto}" min="1" max="9999" placeholder="Alto">
                </td>
                <td class="text-center">
                    <input type="checkbox" class="form-check-input">
                </td>
                <td class="text-center">
                    <div class="tapacanto-controls">
                        <button class="btn-tapacanto btn-all" onclick="toggleTapacantoAll(this)" title="Tapacanto en todos los lados">
                            <i class="ri-stop-fill"></i>
                        </button>
                        <button class="btn-tapacanto btn-direction" onclick="toggleTapacantoDirection(this, 'arriba')" title="Tapacanto Superior">
                            <i class="ri-arrow-up-circle-fill"></i>
                        </button>
                        <button class="btn-tapacanto btn-direction" onclick="toggleTapacantoDirection(this, 'derecha')" title="Tapacanto Derecho">
                            <i class="ri-arrow-right-circle-fill"></i>
                        </button>
                        <button class="btn-tapacanto btn-direction" onclick="toggleTapacantoDirection(this, 'abajo')" title="Tapacanto Inferior">
                            <i class="ri-arrow-down-circle-fill"></i>
                        </button>
                        <button class="btn-tapacanto btn-direction" onclick="toggleTapacantoDirection(this, 'izquierda')" title="Tapacanto Izquierdo">
                            <i class="ri-arrow-left-circle-fill"></i>
                        </button>
                    </div>
                </td>
                <td class="text-center">
                    <button class="btn-delete" onclick="eliminarFila(this)" title="Eliminar pieza">
                        <i class="ri-delete-bin-2-fill"></i>
                    </button>
                </td>
            </tr>
        `;
        
        tbody.insertAdjacentHTML('beforeend', nuevaFila);
        
        // Configurar listeners para los botones de tapacanto de la nueva fila
        const ultimaFila = tbody.lastElementChild;
        configurarBotonesTapacanto(ultimaFila);
    }

    // ===== SISTEMA DE OPTIMIZACIÓN =====

    // Clase para representar una pieza
    class Pieza {
        constructor(numero, cantidad, nombre, ancho, alto, vetaLibre, tapacantos) {
            this.numero = numero;
            this.cantidad = cantidad;
            this.nombre = nombre;
            this.ancho = ancho;
            this.alto = alto;
            this.vetaLibre = vetaLibre;
            this.tapacantos = tapacantos; // objeto con arriba, derecha, abajo, izquierda
            this.rotada = false;
            this.x = 0;
            this.y = 0;
            this.colocada = false;
            this.indiceUnidad = 1; // Para numeración (1/3, 2/3, etc.)
        }

        // Verificar si la pieza puede rotar (si tiene veta libre)
        puedeRotar() {
            return this.vetaLibre;
        }

        // Rotar pieza (intercambiar ancho y alto)
        rotar() {
            if (this.puedeRotar()) {
                [this.ancho, this.alto] = [this.alto, this.ancho];
                // También rotar los tapacantos
                const temp = this.tapacantos.arriba;
                this.tapacantos.arriba = this.tapacantos.izquierda;
                this.tapacantos.izquierda = this.tapacantos.abajo;
                this.tapacantos.abajo = this.tapacantos.derecha;
                this.tapacantos.derecha = temp;
                this.rotada = !this.rotada;
            }
        }

        // Obtener área de la pieza
        getArea() {
            return this.ancho * this.alto;
        }
    }

    // Clase para representar un tablero
    class Tablero {
        constructor(ancho, alto, margen = 10, kerf = 3) {
            this.ancho = ancho;
            this.alto = alto;
            this.margenOriginal = margen;
            this.kerf = kerf;
            this.anchoUtil = ancho - (2 * margen);
            this.altoUtil = alto - (2 * margen);
            this.piezas = [];
            this.numero = 1;
        }

        // Colocar pieza en coordenadas específicas si cabe (atajo para heurísticas)
        agregarPiezaEn(pieza, x, y) {
            if (this.piezaCabe(pieza, x, y)) {
                pieza.x = x;
                pieza.y = y;
                pieza.colocada = true;
                this.piezas.push(pieza);
                return true;
            }
            return false;
        }

        // Verificar si una pieza cabe en una posición específica (versión rápida)
        piezaCabe(pieza, x, y) {
            // Verificar límites del tablero
            if (x < 0 || y < 0 || x + pieza.ancho > this.anchoUtil || y + pieza.alto > this.altoUtil) {
                return false;
            }

            // Verificar colisiones de manera simple
            for (let otraPieza of this.piezas) {
                if (x < otraPieza.x + otraPieza.ancho + this.kerf &&
                    x + pieza.ancho + this.kerf > otraPieza.x &&
                    y < otraPieza.y + otraPieza.alto + this.kerf &&
                    y + pieza.alto + this.kerf > otraPieza.y) {
                    return false;
                }
            }

            return true;
        }

        // Obtener todas las posiciones posibles donde puede ir una pieza
        obtenerPosicionesPosibles(pieza) {
            const posiciones = [];
            
            // Posición inicial (0,0)
            if (this.piezaCabe(pieza, 0, 0)) {
                posiciones.push({ x: 0, y: 0, desperdicio: this.calcularDesperdicio(pieza, 0, 0) });
            }

            // Posiciones junto a piezas existentes
            for (let otraPieza of this.piezas) {
                const candidatos = [
                    // Derecha de la pieza existente
                    { x: otraPieza.x + otraPieza.ancho + this.kerf, y: otraPieza.y },
                    // Abajo de la pieza existente
                    { x: otraPieza.x, y: otraPieza.y + otraPieza.alto + this.kerf },
                    // Esquina inferior derecha
                    { x: otraPieza.x + otraPieza.ancho + this.kerf, y: otraPieza.y + otraPieza.alto + this.kerf }
                ];

                for (let pos of candidatos) {
                    if (this.piezaCabe(pieza, pos.x, pos.y)) {
                        pos.desperdicio = this.calcularDesperdicio(pieza, pos.x, pos.y);
                        posiciones.push(pos);
                    }
                }
            }

            // Ordenar por menor desperdicio
            return posiciones.sort((a, b) => a.desperdicio - b.desperdicio);
        }

        // Calcular el desperdicio potencial de colocar una pieza en una posición
        calcularDesperdicio(pieza, x, y) {
            // Calcular cuánto espacio queda inutilizable después de colocar la pieza
            const areaPieza = pieza.ancho * pieza.alto;
            const areaOcupada = this.piezas.reduce((sum, p) => sum + p.getArea(), 0) + areaPieza;
            const areaTotal = this.anchoUtil * this.altoUtil;
            
            // Penalizar posiciones que crean espacios pequeños difíciles de usar
            let penalizacion = 0;
            
            // Espacio a la derecha
            const espacioDerecha = this.anchoUtil - (x + pieza.ancho);
            if (espacioDerecha > 0 && espacioDerecha < 100) { // Espacios menores a 100mm son problemáticos
                penalizacion += espacioDerecha * 10;
            }
            
            // Espacio abajo
            const espacioAbajo = this.altoUtil - (y + pieza.alto);
            if (espacioAbajo > 0 && espacioAbajo < 100) {
                penalizacion += espacioAbajo * 10;
            }

            return (areaTotal - areaOcupada) + penalizacion;
        }

        // Verificar colisión entre piezas considerando kerf
        hayColision(pieza1, x1, y1, pieza2) {
            const margenKerf = this.kerf;
            
            // Coordenadas de la pieza1 en la nueva posición
            const x1_fin = x1 + pieza1.ancho;
            const y1_fin = y1 + pieza1.alto;
            
            // Coordenadas de la pieza2 (ya colocada)
            const x2_inicio = pieza2.x;
            const y2_inicio = pieza2.y;
            const x2_fin = pieza2.x + pieza2.ancho;
            const y2_fin = pieza2.y + pieza2.alto;
            
            // Verificar si hay solapamiento (incluyendo kerf)
            const solapamientoX = !(x1_fin + margenKerf <= x2_inicio || x1 >= x2_fin + margenKerf);
            const solapamientoY = !(y1_fin + margenKerf <= y2_inicio || y1 >= y2_fin + margenKerf);
            
            const hayColision = solapamientoX && solapamientoY;
            
            // Debug: log en caso de colisión
            if (hayColision) {
                console.log(`COLISIÓN DETECTADA: Pieza1 (${x1},${y1},${x1_fin},${y1_fin}) vs Pieza2 (${x2_inicio},${y2_inicio},${x2_fin},${y2_fin}) - Kerf:${margenKerf}`);
            }
            
            return hayColision;
        }

        // Encontrar la mejor posición con búsqueda exhaustiva mejorada
        encontrarPosicion(pieza) {
            // Si no hay piezas, empezar en esquina superior izquierda
            if (this.piezas.length === 0) {
                return this.piezaCabe(pieza, 0, 0) ? { x: 0, y: 0 } : null;
            }
            
            let mejorPosicion = null;
            let mejorPuntuacion = -Infinity;
            
            // 1. Buscar posiciones estratégicas (junto a otras piezas)
            const posicionesEstrategicas = this.obtenerPosicionesEstrategicas(pieza);
            
            for (let pos of posicionesEstrategicas) {
                if (this.piezaCabe(pieza, pos.x, pos.y)) {
                    const puntuacion = this.calcularPuntuacionEficiencia(pieza, pos.x, pos.y);
                    if (puntuacion > mejorPuntuacion) {
                        mejorPuntuacion = puntuacion;
                        mejorPosicion = { x: pos.x, y: pos.y };
                    }
                }
            }
            
            // 2. Si no hay buena posición estratégica, búsqueda sistemática refinada (con límite de iteraciones)
            if (!mejorPosicion || mejorPuntuacion < 100) {
                const pasoGrueso = Math.max(20, this.kerf * 2); // Paso más grande para velocidad
                const pasoFino = Math.max(5, Math.floor(this.kerf));
                const maxIteracionesGrueso = 400; // Límite de iteraciones gruesas
                const maxIteracionesFino = 200; // Límite de refinamiento
                let iterGrueso = 0;
                let iterFino = 0;

                // Búsqueda gruesa
                for (let y = 0; y <= this.altoUtil - pieza.alto; y += pasoGrueso) {
                    for (let x = 0; x <= this.anchoUtil - pieza.ancho; x += pasoGrueso) {
                        if (iterGrueso++ > maxIteracionesGrueso) break;
                        if (this.piezaCabe(pieza, x, y)) {
                            const puntuacion = this.calcularPuntuacionEficiencia(pieza, x, y);
                            if (puntuacion > mejorPuntuacion) {
                                mejorPuntuacion = puntuacion;
                                mejorPosicion = { x, y };
                            }
                        }
                    }
                    if (iterGrueso > maxIteracionesGrueso) break;
                }

                // Refinamiento alrededor de la mejor posición encontrada
                if (mejorPosicion) {
                    const x0 = Math.max(0, mejorPosicion.x - pasoGrueso);
                    const y0 = Math.max(0, mejorPosicion.y - pasoGrueso);
                    const x1 = Math.min(this.anchoUtil - pieza.ancho, mejorPosicion.x + pasoGrueso);
                    const y1 = Math.min(this.altoUtil - pieza.alto, mejorPosicion.y + pasoGrueso);

                    for (let y = y0; y <= y1; y += pasoFino) {
                        for (let x = x0; x <= x1; x += pasoFino) {
                            if (iterFino++ > maxIteracionesFino) break;
                            if (this.piezaCabe(pieza, x, y)) {
                                const puntuacion = this.calcularPuntuacionEficiencia(pieza, x, y);
                                if (puntuacion > mejorPuntuacion) {
                                    mejorPuntuacion = puntuacion;
                                    mejorPosicion = { x, y };
                                }
                            }
                        }
                        if (iterFino > maxIteracionesFino) break;
                    }
                }
            }
            
            return mejorPosicion;
        }
        
        // Obtener posiciones estratégicas más completas
        obtenerPosicionesEstrategicas(pieza) {
            const posiciones = [];
            
            // Para cada pieza existente, generar más posiciones candidatas
            for (let otraPieza of this.piezas) {
                const candidatos = [
                    // Posiciones básicas
                    { x: otraPieza.x + otraPieza.ancho + this.kerf, y: otraPieza.y }, // Derecha
                    { x: otraPieza.x, y: otraPieza.y + otraPieza.alto + this.kerf }, // Abajo
                    
                    // Posiciones de esquina
                    { x: otraPieza.x + otraPieza.ancho + this.kerf, y: otraPieza.y + otraPieza.alto + this.kerf },
                    
                    // Alineaciones con bordes del tablero
                    { x: 0, y: otraPieza.y }, // Alineado izquierda
                    { x: 0, y: otraPieza.y + otraPieza.alto + this.kerf }, // Izquierda abajo
                    { x: otraPieza.x, y: 0 }, // Alineado arriba
                    { x: otraPieza.x + otraPieza.ancho + this.kerf, y: 0 }, // Derecha arriba
                    
                    // Posiciones que forman rectángulos compactos
                    { x: otraPieza.x - pieza.ancho - this.kerf, y: otraPieza.y }, // Izquierda (si cabe)
                    { x: otraPieza.x, y: otraPieza.y - pieza.alto - this.kerf }, // Arriba (si cabe)
                ];
                
                // Agregar candidatos válidos
                for (let candidato of candidatos) {
                    if (candidato.x >= 0 && candidato.y >= 0 && 
                        candidato.x + pieza.ancho <= this.anchoUtil && 
                        candidato.y + pieza.alto <= this.altoUtil) {
                        posiciones.push(candidato);
                    }
                }
            }
            
            // Eliminar duplicados aproximados
            const posicionesUnicas = [];
            for (let pos of posiciones) {
                const esDuplicado = posicionesUnicas.some(p => 
                    Math.abs(p.x - pos.x) < this.kerf && Math.abs(p.y - pos.y) < this.kerf
                );
                if (!esDuplicado) {
                    posicionesUnicas.push(pos);
                }
            }
            
            return posicionesUnicas;
        }
        
        // Calcular puntuación de eficiencia avanzada para una posición
        calcularPuntuacionEficiencia(pieza, x, y) {
            let puntuacion = 0;
            
            // 1. COMPACTACIÓN: Bonus fuerte por proximidad a otras piezas
            let contactos = 0;
            let distanciaMinima = Infinity;
            
            for (let otraPieza of this.piezas) {
                const distancia = Math.sqrt(Math.pow(x - otraPieza.x, 2) + Math.pow(y - otraPieza.y, 2));
                distanciaMinima = Math.min(distanciaMinima, distancia);
                
                // Detectar contactos directos (compartir borde)
                const contactoVertical = (Math.abs(x - (otraPieza.x + otraPieza.ancho + this.kerf)) < 1 || 
                                        Math.abs((x + pieza.ancho + this.kerf) - otraPieza.x) < 1) &&
                                       !(y + pieza.alto < otraPieza.y || y > otraPieza.y + otraPieza.alto);
                                       
                const contactoHorizontal = (Math.abs(y - (otraPieza.y + otraPieza.alto + this.kerf)) < 1 || 
                                          Math.abs((y + pieza.alto + this.kerf) - otraPieza.y) < 1) &&
                                         !(x + pieza.ancho < otraPieza.x || x > otraPieza.x + otraPieza.ancho);
                
                if (contactoVertical || contactoHorizontal) {
                    contactos++;
                }
            }
            
            // Bonus muy alto por contactos directos (forma bloques compactos)
            puntuacion += contactos * 500;
            
            // Bonus por proximidad general
            if (distanciaMinima < Infinity) {
                puntuacion += 200 / (distanciaMinima + 1);
            }
            
            // 2. USO DE BORDES: Aprovecha esquinas y bordes del tablero
            const enBordeIzquierdo = x === 0;
            const enBordeSuperior = y === 0;
            const enBordeDerecho = x + pieza.ancho === this.anchoUtil;
            const enBordeInferior = y + pieza.alto === this.altoUtil;
            
            let bordesCubiertos = 0;
            if (enBordeIzquierdo) bordesCubiertos++;
            if (enBordeSuperior) bordesCubiertos++;
            if (enBordeDerecho) bordesCubiertos++;
            if (enBordeInferior) bordesCubiertos++;
            
            // Bonus escalado por cantidad de bordes tocados
            puntuacion += bordesCubiertos * 100;
            
            // Bonus extra por esquinas
            if ((enBordeIzquierdo || enBordeDerecho) && (enBordeSuperior || enBordeInferior)) {
                puntuacion += 200; // Esquina
            }
            
            // 3. ANTI-FRAGMENTACIÓN: Penalizar espacios residuales pequeños
            const espacioDerecha = this.anchoUtil - (x + pieza.ancho);
            const espacioAbajo = this.altoUtil - (y + pieza.alto);
            
            // Penalización progresiva por espacios pequeños
            if (espacioDerecha > 0 && espacioDerecha < 150) {
                puntuacion -= (150 - espacioDerecha) * 3;
            }
            if (espacioAbajo > 0 && espacioAbajo < 150) {
                puntuacion -= (150 - espacioAbajo) * 3;
            }
            
            // 4. FORMA DE DISTRIBUCIÓN: Bonus por mantener forma rectangular compacta
            const centroX = x + pieza.ancho / 2;
            const centroY = y + pieza.alto / 2;
            
            // Calcular centro de masa de las piezas existentes
            if (this.piezas.length > 0) {
                let sumX = 0, sumY = 0;
                for (let p of this.piezas) {
                    sumX += p.x + p.ancho / 2;
                    sumY += p.y + p.alto / 2;
                }
                const centroMasaX = sumX / this.piezas.length;
                const centroMasaY = sumY / this.piezas.length;
                
                // Bonus por mantener las piezas cerca del centro de masa (evita dispersión)
                const distanciaCentroMasa = Math.sqrt(
                    Math.pow(centroX - centroMasaX, 2) + Math.pow(centroY - centroMasaY, 2)
                );
                puntuacion += Math.max(0, 300 - distanciaCentroMasa * 0.5);
            }
            
            // 5. BONUS POR CREAR LÍNEAS RECTAS (facilita cortes)
            let lineasCreadas = 0;
            
            // Verificar si crea líneas horizontales
            for (let p of this.piezas) {
                if (Math.abs(p.y - y) < 1) lineasCreadas++;
                if (Math.abs((p.y + p.alto) - (y + pieza.alto)) < 1) lineasCreadas++;
            }
            
            // Verificar si crea líneas verticales
            for (let p of this.piezas) {
                if (Math.abs(p.x - x) < 1) lineasCreadas++;
                if (Math.abs((p.x + p.ancho) - (x + pieza.ancho)) < 1) lineasCreadas++;
            }
            
            puntuacion += lineasCreadas * 50;
            
            return puntuacion;
        }
        
        // Calcular bonus por compactación del tablero
        calcularBonusCompactacion(x, y, pieza) {
            let bonus = 0;
            
            // Verificar si la posición mantiene el tablero compacto
            const bordeIzquierdo = x === 0;
            const bordeSuperior = y === 0;
            const hayPiezaIzquierda = this.piezas.some(p => p.x + p.ancho + this.kerf === x && 
                                                           Math.abs(p.y - y) < this.kerf);
            const hayPiezaArriba = this.piezas.some(p => p.y + p.alto + this.kerf === y && 
                                                        Math.abs(p.x - x) < this.kerf);
            
            // Bonus por continuidad
            if (bordeIzquierdo || hayPiezaIzquierda) bonus += 100;
            if (bordeSuperior || hayPiezaArriba) bonus += 100;
            
            // Bonus extra si está en esquina o bien soportada
            if ((bordeIzquierdo || hayPiezaIzquierda) && (bordeSuperior || hayPiezaArriba)) {
                bonus += 200;
            }
            
            return bonus;
        }

        // Algoritmo Bottom-Left Fill original (mantenido para compatibilidad)
        encontrarPosicionBottomLeft(pieza) {
            let mejorPosicion = null;
            let menorY = this.altoUtil;
            let menorX = this.anchoUtil;

            // Incremento más pequeño para mayor precisión
            const paso = Math.max(1, Math.min(this.kerf, 5));

            // Buscar la posición más abajo y más a la izquierda posible
            for (let y = 0; y <= this.altoUtil - pieza.alto; y += paso) {
                for (let x = 0; x <= this.anchoUtil - pieza.ancho; x += paso) {
                    if (this.piezaCabe(pieza, x, y)) {
                        if (y < menorY || (y === menorY && x < menorX)) {
                            mejorPosicion = { x, y };
                            menorY = y;
                            menorX = x;
                            
                            // Si encontramos una posición en y=0, es la mejor posible para esa x
                            if (y === 0) break;
                        }
                    }
                }
                
                // Si encontramos una posición en la fila más baja, no necesitamos buscar más arriba
                if (mejorPosicion && mejorPosicion.y === y) break;
            }

            return mejorPosicion;
        }

        // Agregar pieza al tablero (versión rápida)
        agregarPieza(pieza) {
            const posicion = this.encontrarPosicion(pieza);
            if (posicion) {
                pieza.x = posicion.x;
                pieza.y = posicion.y;
                pieza.colocada = true;
                this.piezas.push(pieza);
                return true;
            }
            return false;
        }

        // Calcular aprovechamiento del tablero
        getAprovechamiento() {
            const areaUsada = this.piezas.reduce((sum, pieza) => sum + pieza.getArea(), 0);
            const areaTotal = this.anchoUtil * this.altoUtil;
            return (areaUsada / areaTotal) * 100;
        }

        // Calcular desperdicio
        getDesperdicio() {
            const areaUsada = this.piezas.reduce((sum, pieza) => sum + pieza.getArea(), 0);
            const areaTotal = this.anchoUtil * this.altoUtil;
            return areaTotal - areaUsada;
        }

        // Calcular área usada (para compatibilidad)
        calcularAreaUsada() {
            return this.piezas.reduce((sum, pieza) => sum + pieza.getArea(), 0);
        }
    }

    // Función principal de optimización  
    function optimizarPiezas() {
        console.log('=== INICIANDO OPTIMIZACIÓN ===');
        // Desbloquear visualización para permitir nuevo render con los cambios
        try{
            const contVis = document.getElementById('visualizacionTableros');
            if (contVis && contVis.dataset){ delete contVis.dataset.locked; }
        }catch(_e){}

        try {
            // Asegurar proyecto: si no existe en DOM, crearlo con datos mínimos
            const containerResultados = document.getElementById('resultadosOptimizacion');
            let proyectoId = containerResultados?.getAttribute('data-proyecto-id');
            if (!proyectoId) {
                const nombreProyecto = document.getElementById('nombreProyecto')?.value?.trim() || 'Proyecto sin nombre';
                const clienteRut = document.getElementById('rutCliente')?.value?.trim();
                const clienteNombre = document.getElementById('clienteInput')?.value?.trim();
                // Intentar obtener cliente_id del datalist
                let clienteId = null;
                const datalist = document.getElementById('clientesDatalist');
                if (datalist && clienteNombre) {
                    const opt = Array.from(datalist.querySelectorAll('option')).find(o => o.value === clienteNombre);
                    if (opt && opt.dataset.id) clienteId = opt.dataset.id;
                }

                // Si no hay clienteId pero hay nombre+RUT, crear cliente automáticamente
                const ensureProyecto = (cid) => {
                    // Construir configuración inicial mínima con material activo y piezas actuales
                    const activeTab = document.querySelector('#materialTabs button.nav-link.active');
                    let materialIndex = 1;
                    if (activeTab && activeTab.id) {
                        const m = activeTab.id.match(/material(\d+)-tab/);
                        if (m) materialIndex = parseInt(m[1],10);
                    }
                    const cfgInicial = {
                        materiales: [{
                            configuracion_material: {
                                material_id: (document.getElementById(`tableroSelect${materialIndex}`)?.value)||null,
                                ancho_custom: parseFloat(document.getElementById(`ancho${materialIndex}`)?.value||'0'),
                                largo_custom: parseFloat(document.getElementById(`alto${materialIndex}`)?.value||'0'),
                                margen_x: parseFloat(document.getElementById(`margenX${materialIndex}`)?.value||'0'),
                                margen_y: parseFloat(document.getElementById(`margenY${materialIndex}`)?.value||'0'),
                                desperdicio_sierra: parseFloat(document.getElementById(`desperdicioSierra${materialIndex}`)?.value||'0'),
                                tapacanto_codigo: (function(){
                                    const sel = document.getElementById(`tapacantoSelect${materialIndex}`);
                                    return sel && sel.value ? (sel.selectedOptions[0].dataset.codigo||'') : '';
                                })(),
                                tapacanto_nombre: (function(){
                                    const sel = document.getElementById(`tapacantoSelect${materialIndex}`);
                                    return sel && sel.value ? (sel.selectedOptions[0].textContent||'') : '';
                                })()
                            },
                            piezas: piezasFromDOM().map(p=>({
                                nombre: p.nombre,
                                ancho: p.ancho,
                                largo: p.alto,
                                cantidad: p.cantidad,
                                veta_libre: !!p.veta_libre,
                                tapacantos: p.tapacantos
                            }))
                        }]
                    };
                    const payload = { nombre: nombreProyecto, cliente_id: cid, configuracion: cfgInicial };
                    fetch('{% url "crear_proyecto_optimizacion" %}', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCsrfToken() },
                        body: JSON.stringify(payload)
                    }).then(r=>r.json()).then(res=>{
                        if (res && res.success) {
                            containerResultados.setAttribute('data-proyecto-id', res.proyecto_id);
                            try{ const resDiv = document.getElementById('resumenProyecto'); if (resDiv) resDiv.setAttribute('data-proyecto-id', String(res.proyecto_id)); }catch(_e){}
                            try{ const f = document.getElementById('folioProyecto'); if (f && res.folio){ f.value = res.folio; document.getElementById('resFolio').textContent = res.folio; } }catch(_e){}
                            setTimeout(()=> optimizarPiezas(), 50);
                        } else {
                            alert(res.message||'No se pudo crear el proyecto');
                        }
                    }).catch(err=>{
                        console.error('Error creando proyecto', err);
                        alert('Error creando el proyecto');
                    });
                };

                if (!clienteId && clienteNombre && clienteRut) {
                    fetch('{% url "crear_cliente_ajax" %}', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCsrfToken() },
                        body: JSON.stringify({ nombre: clienteNombre, rut: clienteRut })
                    }).then(r=>r.json()).then(res=>{
                        if (res && res.success && res.cliente && res.cliente.id) {
                            ensureProyecto(res.cliente.id);
                        } else {
                            alert((res && (res.mensaje||res.message)) || 'No se pudo crear el cliente automáticamente');
                        }
                    }).catch(err=>{
                        console.error('Error creando cliente', err);
                        alert('Error creando cliente');
                    });
                    return;
                }

                if (!clienteId) {
                    alert('Selecciona un cliente o ingresa Nombre y RUT válidos para crearlo automáticamente.');
                    return;
                }

                // Igual que arriba: enviar configuración inicial
                const activeTab2 = document.querySelector('#materialTabs button.nav-link.active');
                let materialIndex2 = 1;
                if (activeTab2 && activeTab2.id) {
                    const m2 = activeTab2.id.match(/material(\d+)-tab/);
                    if (m2) materialIndex2 = parseInt(m2[1],10);
                }
                const cfgInicial2 = {
                    materiales: [{
                        configuracion_material: {
                            material_id: (document.getElementById(`tableroSelect${materialIndex2}`)?.value)||null,
                            ancho_custom: parseFloat(document.getElementById(`ancho${materialIndex2}`)?.value||'0'),
                            largo_custom: parseFloat(document.getElementById(`alto${materialIndex2}`)?.value||'0'),
                            margen_x: parseFloat(document.getElementById(`margenX${materialIndex2}`)?.value||'0'),
                            margen_y: parseFloat(document.getElementById(`margenY${materialIndex2}`)?.value||'0'),
                            desperdicio_sierra: parseFloat(document.getElementById(`desperdicioSierra${materialIndex2}`)?.value||'0'),
                            tapacanto_codigo: (function(){
                                const sel = document.getElementById(`tapacantoSelect${materialIndex2}`);
                                return sel && sel.value ? (sel.selectedOptions[0].dataset.codigo||'') : '';
                            })(),
                            tapacanto_nombre: (function(){
                                const sel = document.getElementById(`tapacantoSelect${materialIndex2}`);
                                return sel && sel.value ? (sel.selectedOptions[0].textContent||'') : '';
                            })()
                        },
                        piezas: piezasFromDOM().map(p=>({
                            nombre: p.nombre,
                            ancho: p.ancho,
                            largo: p.alto,
                            cantidad: p.cantidad,
                            veta_libre: !!p.veta_libre,
                            tapacantos: p.tapacantos
                        }))
                    }]
                };
                const payload = { nombre: nombreProyecto, cliente_id: clienteId, configuracion: cfgInicial2 };
                fetch('{% url "crear_proyecto_optimizacion" %}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCsrfToken() },
                    body: JSON.stringify(payload)
                }).then(r=>r.json()).then(res=>{
                    if (res && res.success) {
                        containerResultados.setAttribute('data-proyecto-id', res.proyecto_id);
                        try{ const resDiv = document.getElementById('resumenProyecto'); if (resDiv) resDiv.setAttribute('data-proyecto-id', String(res.proyecto_id)); }catch(_e){}
                        try{ const f = document.getElementById('folioProyecto'); if (f && res.folio){ f.value = res.folio; document.getElementById('resFolio').textContent = res.folio; } }catch(_e){}
                        // Continuar optimización tras crear el proyecto
                        setTimeout(()=> optimizarPiezas(), 50);
                    } else {
                        alert(res.message||'No se pudo crear el proyecto');
                    }
                }).catch(err=>{
                    console.error('Error creando proyecto', err);
                    alert('Error creando el proyecto');
                });
                return; // esperar a que se cree el proyecto
            }
            // Obtener datos del material seleccionado
            const materialSelect = document.getElementById('materialSelect');
            if (!materialSelect || !materialSelect.value) {
                console.log('No hay material seleccionado, usando valores por defecto');
                // Continuar con valores por defecto si no hay material seleccionado
            }

            // Obtener dimensiones del tablero desde los inputs del usuario con validaciones
            const anchoElement = document.getElementById('ancho1');
            const altoElement = document.getElementById('alto1');
            const margenElement = document.getElementById('margenX1');
            const kerfElement = document.getElementById('desperdicioSierra1');

            const anchoTablero = anchoElement ? parseFloat(anchoElement.value) || 2440 : 2440;
            const altoTablero = altoElement ? parseFloat(altoElement.value) || 1830 : 1830;
            const margen = margenElement ? parseFloat(margenElement.value) || 10 : 10;
            const kerf = kerfElement ? parseFloat(kerfElement.value) || 3 : 3;

            console.log(`Parámetros: Tablero=${anchoTablero}x${altoTablero}mm, Margen=${margen}mm, Kerf=${kerf}mm`);

            // Recopilar piezas de la tabla
            console.log('Recopilando piezas...');
            const piezas = recopilarPiezasDeTabla();
            if (piezas.length === 0) {
                alert('No hay piezas para optimizar. Asegúrate de ingresar las dimensiones de las piezas.');
                return;
            }

            console.log('Expandiendo piezas...');
            // Expandir piezas según cantidad
            const piezasExpandidas = expandirPiezas(piezas);
            console.log(`Piezas expandidas: ${piezasExpandidas.length}`);

            // Agrupar piezas por dimensiones compatibles para minimizar retazos
            const piezasAgrupadasPorDimension = agruparPiezasPorDimensiones(piezasExpandidas);
            console.log('Piezas agrupadas por dimensiones compatibles para minimizar retazos...');

            console.log('Usando algoritmo optimizado para máximo aprovechamiento del tablero...');

            // Ejecutar optimización con agrupación por dimensiones
            console.log('Ejecutando optimización con agrupación por dimensiones...');
            const tiempoInicio = Date.now();
            
            // 1) Heurística rápida tipo estantes (FFDH/BFDH). 2 órdenes, elegir mejor. Fallback: agrupación
            const limiteTiempoMs = 4000; // presupuesto total ~4s
            const inicio = Date.now();
            
            // Clonar piezas para que cada intento no comparta estado (colocada, rotada, x, y)
            const clonarLista = (lista) => lista.map(p => {
                const cp = new Pieza(p.numero, 1, p.nombre, p.ancho, p.alto, p.vetaLibre, { ...p.tapacantos });
                cp.indiceUnidad = p.indiceUnidad; cp.totalUnidades = p.totalUnidades;
                return cp;
            });

            const ordenAltura = clonarLista([...piezasAgrupadasPorDimension].sort((a,b)=>Math.max(b.alto,b.ancho)-Math.max(a.alto,a.ancho)));
            const ordenAncho  = clonarLista([...piezasAgrupadasPorDimension].sort((a,b)=>Math.min(b.alto,b.ancho)-Math.min(a.alto,a.ancho)));

            const res1 = optimizarEstantesRapido(ordenAltura, anchoTablero, altoTablero, margen, kerf, inicio, limiteTiempoMs);
            const res2 = Date.now()-inicio < limiteTiempoMs 
                ? optimizarEstantesRapido(ordenAncho, anchoTablero, altoTablero, margen, kerf, inicio, limiteTiempoMs) 
                : null;
            
            let mejor = res1;
            const score = tbs => tbs ? calcularAprovechamientoTotal(tbs) - (tbs.length-1)*5 : -1e9; // penaliza más tableros
            if (res2 && score(res2) > score(mejor)) mejor = res2;
            
            let tableros = (mejor && score(mejor) > 0 && Date.now()-inicio < limiteTiempoMs)
                ? mejor
                : optimizarConAgrupacionDimensiones(piezasAgrupadasPorDimension, anchoTablero, altoTablero, margen, kerf);

            // Si no todas las piezas quedaron colocadas (especialmente sin veta libre), aplicar fallback completo
            const colocadas = tableros.reduce((sum, t) => sum + t.piezas.length, 0);
            if (colocadas < piezasExpandidas.length) {
                console.warn(`Quedaron ${piezasExpandidas.length - colocadas} piezas sin colocar con estantes. Usando estrategia de agrupación.`);
                tableros = optimizarConAgrupacionDimensiones(piezasAgrupadasPorDimension, anchoTablero, altoTablero, margen, kerf);
            }

            // Fase de compactación: intentar mover piezas de tableros posteriores a anteriores
            tableros = compactarTableros(tableros);

            // Reempacado global: si podemos mejorar (menos tableros o mejor aprovechamiento), adoptamos
            const tablerosReempaquetados = reempacarGlobal(tableros, anchoTablero, altoTablero, margen, kerf);
            if (tablerosReempaquetados) {
                const mejorPorCount = tablerosReempaquetados.length < tableros.length;
                const utilOriginal = calcularAprovechamientoTotal(tableros);
                const utilNuevo = calcularAprovechamientoTotal(tablerosReempaquetados);
                if (mejorPorCount || (tablerosReempaquetados.length === tableros.length && utilNuevo >= utilOriginal - 0.1)) {
                    tableros = tablerosReempaquetados;
                }
            }
            // Eliminar tableros vacíos y renumerar
            tableros = tableros.filter(t => t && Array.isArray(t.piezas) && t.piezas.length > 0);
            tableros.forEach((t, idx) => t.numero = idx + 1);

            const aprovechamiento = calcularAprovechamientoTotal(tableros);
            
            const tiempoTotal = ((Date.now() - tiempoInicio) / 1000).toFixed(1);
            console.log(`Resultado: ${tableros.length} tableros, ${aprovechamiento.toFixed(1)}% aprovechamiento en ${tiempoTotal}s`);

            console.log(`Optimización completada. Tableros generados: ${tableros.length}`);
            // Mostrar resultados
            mostrarResultados(tableros);

            // Enviar resultado al backend para guardar en el proyecto (material actual = pestaña activa)
            try {
                const activeTab = document.querySelector('#materialTabs button.nav-link.active');
                let materialIndex = 1;
                if (activeTab && activeTab.id) {
                    const m = activeTab.id.match(/material(\d+)-tab/);
                    if (m) materialIndex = parseInt(m[1],10);
                }
                // Bloquear PDF hasta que se actualice el folio/archivo en backend
                window._bloquearPDF = true;
                const btnPdf = document.querySelector('button.btn.btn-outline-secondary.ms-2[onclick="descargarPDF()"]') || document.querySelector('button[onclick="descargarPDF()"]');
                if (btnPdf){ btnPdf.disabled = true; btnPdf.style.cursor = 'progress'; }

                const payload = {
                    proyecto_id: document.getElementById('resultadosOptimizacion').getAttribute('data-proyecto-id'),
                    configuracion_material: {
                        material_id: (document.getElementById(`tableroSelect${materialIndex}`)?.value)||null,
                        ancho_custom: parseFloat(document.getElementById(`ancho${materialIndex}`)?.value||'0'),
                        largo_custom: parseFloat(document.getElementById(`alto${materialIndex}`)?.value||'0'),
                        margen_x: parseFloat(document.getElementById(`margenX${materialIndex}`)?.value||'0'),
                        margen_y: parseFloat(document.getElementById(`margenY${materialIndex}`)?.value||'0'),
                        desperdicio_sierra: parseFloat(document.getElementById(`desperdicioSierra${materialIndex}`)?.value||'0'),
                        tapacanto_codigo: (function(){
                            const sel = document.getElementById(`tapacantoSelect${materialIndex}`);
                            return sel && sel.value ? (sel.selectedOptions[0].dataset.codigo||'') : '';
                        })(),
                        tapacanto_nombre: (function(){
                            const sel = document.getElementById(`tapacantoSelect${materialIndex}`);
                            return sel && sel.value ? (sel.selectedOptions[0].textContent||'') : '';
                        })()
                    },
                    piezas: piezasFromDOM().map(p=>({
                        nombre: p.nombre,
                        ancho: p.ancho,
                        largo: p.alto,
                        cantidad: p.cantidad,
                        veta_libre: !!p.veta_libre,
                        tapacantos: p.tapacantos
                    })),
                    material_index: materialIndex,
                    resetear_resultado: !!window._resetResultado
                };
                fetch('{% url "optimizar_material" %}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCsrfToken() },
                    body: JSON.stringify(payload)
                }).then(r=>r.json()).then(res=>{
                    if (!res || !res.success) {
                        console.warn('No se pudo guardar/optimizar en backend:', res);
                        window._bloquearPDF = false;
                        const b = document.querySelector('button[onclick="descargarPDF()"]');
                        if (b){ b.disabled = false; b.style.cursor = ''; }
                        return;
                    }
                    try {
                        if (res.folio){
                            const f = document.getElementById('folioProyecto');
                            if (f){ f.value = res.folio; }
                            const rf = document.getElementById('resFolio');
                            if (rf){ rf.textContent = res.folio; }
                        }
                    } catch(_e) {}
                    // Desbloquear PDF tras breve espera para asegurar escritura del archivo
                    setTimeout(()=>{
                        window._bloquearPDF = false;
                        const b = document.querySelector('button[onclick="descargarPDF()"]');
                        if (b){ b.disabled = false; b.style.cursor = ''; }
                        // Mostrar toast no intrusivo sin mover botones
                        try {
                            const toast = document.getElementById('toastGenerandoPdf');
                            if (toast){
                                toast.style.display = 'block';
                                setTimeout(()=>{ toast.style.display = 'none'; }, 2000);
                            }
                        } catch(_e) {}
                    }, 800);
                    window._resetResultado = false;
                    _dirty = false;
                    try {
                        // Persistir en estado por pestaña
                        materialState[materialIndex] = materialState[materialIndex] || {};
                        materialState[materialIndex].resultado = res.resultado;
                        if (res.proyecto_id){
                            const resDiv = document.getElementById('resumenProyecto');
                            if (resDiv) resDiv.setAttribute('data-proyecto-id', String(res.proyecto_id));
                            const contRes = document.getElementById('resultadosOptimizacion');
                            if (contRes) contRes.setAttribute('data-proyecto-id', String(res.proyecto_id));
                        }
                        // Adaptar backend a formato esperado por crearSVGTablero
                        const mRes = res.resultado || {};
                        const mX = (mRes.margenes && typeof mRes.margenes.margen_x === 'number') ? mRes.margenes.margen_x : 0;
                        const mY = (mRes.margenes && typeof mRes.margenes.margen_y === 'number') ? mRes.margenes.margen_y : 0;
                        const margen = Math.max(mX, mY);
                        const tablerosBackend = Array.isArray(mRes.tableros) ? mRes.tableros : [];
                        // Numeración global por tipo (nombre + dimensiones normalizadas) para i/j
                        const _typeTotals = new Map();
                        tablerosBackend.forEach(t=>{
                            (t.piezas||[]).forEach(p=>{
                                const a = parseInt(p.ancho||p.width||0,10); const l = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                                const k = `${(p.nombre||'').trim()}|${Math.min(a,l)}x${Math.max(a,l)}`;
                                _typeTotals.set(k, (_typeTotals.get(k)||0) + 1);
                            });
                        });
                        const _typeRunning = new Map();
                        const tb = tablerosBackend.map((t, idx)=>({
                            numero: (idx+1),
                            ancho: (t.ancho || mRes.tablero_ancho_original || 0),
                            alto: (t.largo || mRes.tablero_largo_original || 0),
                            margenOriginal: margen,
                            anchoUtil: Math.max(0, (t.ancho || mRes.tablero_ancho_original || 0) - 2*mX),
                            altoUtil: Math.max(0, (t.largo || mRes.tablero_largo_original || 0) - 2*mY),
                            kerf: (typeof mRes.desperdicio_sierra === 'number' ? mRes.desperdicio_sierra : (mRes.config && typeof mRes.config.kerf === 'number' ? mRes.config.kerf : 0)),
                            piezas: (Array.isArray(t.piezas)? t.piezas.map(p=>{
                                const aN = parseInt(p.ancho||p.width||0,10); const lN = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                                const k = `${(p.nombre||'').trim()}|${Math.min(aN,lN)}x${Math.max(aN,lN)}`;
                                const run = (_typeRunning.get(k)||0) + 1; _typeRunning.set(k, run);
                                const tot = _typeTotals.get(k)||run;
                                  // Normalización de coordenadas: decidir si vienen relativas (candA) o absolutas (candB)
                                  const effW = Math.max(0, (t.ancho || mRes.tablero_ancho_original || 0) - 2*mX);
                                  const effH = Math.max(0, (t.largo || mRes.tablero_largo_original || 0) - 2*mY);
                                  const px = (p.x!=null? parseFloat(p.x) : 0); const py = (p.y!=null? parseFloat(p.y) : 0);
                                  const candA = {x:px, y:py};
                                  const candB = {x:px - mX, y:py - mY};
                                  const fits = (c)=> c.x >= -2 && c.y >= -2 && c.x + aN <= effW + 2 && c.y + lN <= effH + 2;
                                  const use = fits(candB) ? candB : (fits(candA) ? candA : candB);
                                return {
                                    nombre: p.nombre,
                                      x: use.x,
                                      y: use.y,
                                    ancho: aN,
                                    alto: lN,
                                    rotada: !!p.rotada,
                                    indiceUnidad: (p.indiceUnidad!=null? p.indiceUnidad : run),
                                    totalUnidades: (p.totalUnidades!=null? p.totalUnidades : tot),
                                    tapacantos: (typeof p.tapacantos==='object' && !Array.isArray(p.tapacantos)) ? p.tapacantos : {arriba:false,derecha:false,abajo:false,izquierda:false}
                                };
                            }) : []),
                            getAprovechamiento(){ return (t.eficiencia_tablero!=null) ? t.eficiencia_tablero : (mRes.eficiencia||0); }
                        }));
                        // Renderizar usando el layout optimizado del backend SOLO si no está bloqueada la visualización
                        (function(){
                            try{
                                // Forzar que la UI refleje SIEMPRE el layout del backend (mismo que el PDF)
                                const contVis = document.getElementById('visualizacionTableros');
                                if (contVis && contVis.dataset){ delete contVis.dataset.locked; }
                                window.__allowReRender = true;
                                generarVisualizacion(tb);
                                window.__allowReRender = false;
                                if (contVis && contVis.dataset){ contVis.dataset.locked = '1'; }
                            }catch(_e){ try{ generarVisualizacion(tb); }catch(__e){} }
                        })();
                        const cont = document.getElementById('resultadosOptimizacion');
                        if (cont) cont.style.display = 'block';
                        // Sincronizar proyecto activo en resumen y resultados
                        try{
                            if (res.proyecto_id){
                                const resDiv = document.getElementById('resumenProyecto');
                                if (resDiv) resDiv.setAttribute('data-proyecto-id', String(res.proyecto_id));
                                if (cont) cont.setAttribute('data-proyecto-id', String(res.proyecto_id));
                            }
                        }catch(_e){}
                        // Actualizar resumen desde backend
                        (function actualizarResumenDesdeBackend(){
                            try{
                                const totalTableros = (mRes.tableros||[]).length;
                                const aprovech = (typeof mRes.eficiencia === 'number') ? mRes.eficiencia : 0;
                                const areaTotalM2 = (typeof mRes.area_total === 'number') ? mRes.area_total : 0;
                                const areaUsadaM2 = (typeof mRes.area_utilizada === 'number') ? mRes.area_utilizada : 0;
                                const desperdicioM2 = Math.max(areaTotalM2 - areaUsadaM2, 0);
                                // Recalcular tapacanto total a partir de piezas
                                let tapMM = 0;
                                (mRes.tableros||[]).forEach(t=>{ (t.piezas||[]).forEach(p=>{
                                    const tc = (typeof p.tapacantos==='object' && !Array.isArray(p.tapacantos)) ? p.tapacantos : {};
                                    if (tc.arriba) tapMM += p.ancho;
                                    if (tc.derecha) tapMM += (p.largo!=null? p.largo : p.alto);
                                    if (tc.abajo) tapMM += p.ancho;
                                    if (tc.izquierda) tapMM += (p.largo!=null? p.largo : p.alto);
                                }); });
                                document.getElementById('tablerosUsados').textContent = totalTableros;
                                document.getElementById('aprovechamiento').textContent = `${aprovech.toFixed(1)}%`;
                                document.getElementById('desperdicio').textContent = `${desperdicioM2.toFixed(3)} m²`;
                                document.getElementById('tapacantos').textContent = `${(tapMM/1000).toFixed(1)} m`;
                            }catch(e){ console.warn('No se pudo actualizar resumen con backend', e); }
                        })();
                    } catch(e){
                        console.warn('Error al aplicar resultado del backend', e);
                    }
                }).catch(err=> console.warn('Error guardando/optimizando en backend', err));
            } catch(e){ console.warn('No se pudo enviar resultado al backend:', e); }
        } catch (error) {
            console.error('Error durante la optimización:', error);
            console.error('Stack trace:', error.stack);
            
            // Mensaje más amigable para el usuario
            let mensaje = 'Error durante la optimización. ';
            if (error.message.includes('null')) {
                mensaje += 'Verifica que todos los campos estén completados correctamente.';
            } else {
                mensaje += 'Por favor revisa los datos ingresados. Detalles: ' + error.message;
            }
            
            alert(mensaje);
        }
    }

    // Intenta reubicar piezas de tableros posteriores a anteriores para reducir cantidad de tableros
    function compactarTableros(tableros) {
        if (!Array.isArray(tableros) || tableros.length <= 1) return tableros;
        let huboMovimientos = true;
        let pasadas = 0;
        while (huboMovimientos && pasadas < 3) {
            huboMovimientos = false;
            pasadas++;
            for (let i = 1; i < tableros.length; i++) {
                const tableroActual = tableros[i];
                if (!tableroActual || !tableroActual.piezas || tableroActual.piezas.length === 0) continue;
                // Priorizar piezas delgadas/pequeñas primero
                const piezasOrdenadas = [...tableroActual.piezas].sort((a, b) => (a.ancho * a.alto) - (b.ancho * b.alto));
                for (const pieza of piezasOrdenadas) {
                    let reubicada = false;
                    for (let j = 0; j < i && !reubicada; j++) {
                        const destino = tableros[j];
                        if (!destino) continue;
                        if (destino.agregarPieza(pieza)) {
                            tableroActual.piezas = tableroActual.piezas.filter(p => p !== pieza);
                            reubicada = true; huboMovimientos = true; break;
                        }
                        if (pieza.puedeRotar && pieza.puedeRotar()) {
                            pieza.rotar();
                            if (destino.agregarPieza(pieza)) {
                                tableroActual.piezas = tableroActual.piezas.filter(p => p !== pieza);
                                reubicada = true; huboMovimientos = true; break;
                            } else {
                                pieza.rotar();
                            }
                        }
                    }
                }
            }
        }
        const filtrados = tableros.filter(t => t && t.piezas && t.piezas.length > 0);
        filtrados.forEach((t, idx) => t.numero = idx + 1);
        return filtrados;
    }

    // Reempacar todas las piezas si es posible mejorar distribución global
    function reempacarGlobal(tableros, anchoTablero, altoTablero, margen, kerf) {
        try {
            if (!Array.isArray(tableros) || tableros.length === 0) return null;
            // Aplanar y clonar todas las piezas
            const piezasTodas = [];
            tableros.forEach(t => {
                (t.piezas || []).forEach(p => {
                    const cp = new Pieza(p.numero, 1, p.nombre, p.ancho, p.alto, p.vetaLibre, { ...p.tapacantos });
                    cp.indiceUnidad = p.indiceUnidad || 1;
                    cp.totalUnidades = p.totalUnidades || 1;
                    cp.rotada = !!p.rotada; // conservar estado para símbolo ↻
                    piezasTodas.push(cp);
                });
            });
            if (piezasTodas.length === 0) return null;
            // Orden por agrupación de dimensiones (la función ya ordena por grupos y áreas)
            const piezasAgrupadas = agruparPiezasPorDimensiones(piezasTodas);
            const nuevos = optimizarConAgrupacionDimensiones(piezasAgrupadas, anchoTablero, altoTablero, margen, kerf);
            // Filtrar vacíos y renumerar
            const filtrados = nuevos.filter(t => t && t.piezas && t.piezas.length > 0);
            filtrados.forEach((t, idx) => t.numero = idx + 1);
            return filtrados;
        } catch (e) {
            console.warn('Reempacado global falló:', e);
            return null;
        }
    }



    // Recopilar piezas de la tabla HTML (función original mantenida para compatibilidad)
    function recopilarPiezasDeTabla() {
        const piezas = [];
        const filas = document.querySelectorAll('#piezasTableBody tr');
        console.log(`Encontradas ${filas.length} filas en la tabla`);
        
        filas.forEach((fila, index) => {
            const inputs = fila.querySelectorAll('input');
            console.log(`Fila ${index}: ${inputs.length} inputs encontrados`);
            
            if (inputs.length >= 5) {
                // Estructura: [cantidad, nombre, ancho, alto, vetaLibre]
                const cantidad = parseInt(inputs[0].value) || 1;
                const nombre = inputs[1].value.trim() || `Pieza ${index + 1}`;
                const ancho = parseInt(inputs[2].value) || 0;
                const alto = parseInt(inputs[3].value) || 0;
                const vetaLibre = inputs[4].checked || false;

                console.log(`Pieza ${index + 1}: ${nombre}, ${cantidad}x, ${ancho}x${alto}, vetaLibre: ${vetaLibre}`);

                if (ancho > 0 && alto > 0) {
                    // Obtener estado de tapacantos
                    const tapacantos = obtenerTapacantos(fila);
                    
                    const pieza = new Pieza(index + 1, cantidad, nombre, ancho, alto, vetaLibre, tapacantos);
                    piezas.push(pieza);
                } else {
                    console.log(`Pieza ${index + 1} omitida: dimensiones inválidas`);
                }
            } else {
                console.log(`Fila ${index} omitida: no suficientes inputs`);
            }
        });
        
        console.log(`Total piezas válidas: ${piezas.length}`);
        return piezas;
    }

    // Marcar/Desmarcar todas las casillas de V.L. (Veta Libre)
    function toggleVetaLibreTodos(checked) {
        const filas = document.querySelectorAll('#piezasTableBody tr');
        filas.forEach(fila => {
            const cb = fila.querySelector('td:nth-child(6) input[type="checkbox"]');
            if (cb) {
                cb.checked = checked;
                cb.classList.add('veta-checkbox');
            }
        });
        // Mantener maestro en estado real
        const master = document.getElementById('vetaLibreMaster');
        if (master) master.checked = checked;
    }

    // Sincroniza el maestro según el estado de todas las piezas
    function updateVetaLibreMaster() {
        // Tomar todos los checkboxes de la columna V.L. (6ta columna)
        const checks = document.querySelectorAll('#piezasTableBody tr td:nth-child(6) input[type="checkbox"]');
        if (!checks || checks.length === 0) return;
        let allChecked = true;
        checks.forEach(cb => { if (!cb.checked) allChecked = false; });
        const master = document.getElementById('vetaLibreMaster');
        if (master) master.checked = allChecked;
    }

    // Al crear filas nuevas, aseguremos que el checkbox tenga onchange para sync
    function configurarBotonesTapacanto(fila) {
        // función existente puede ya setear botones; añadimos el sync de V.L.
        const cb = fila.querySelector('td:nth-child(6) input[type="checkbox"]');
        if (cb) {
            cb.classList.add('veta-checkbox');
            cb.setAttribute('onchange', 'updateVetaLibreMaster()');
        }
    }

    // Obtener configuración de tapacantos de una fila
    function obtenerTapacantos(fila) {
        const botones = fila.querySelectorAll('.btn-tapacanto');
        const tapacantos = {
            arriba: false,
            derecha: false,
            abajo: false,
            izquierda: false
        };

        // Verificar botón "todos los lados"
        const botonTodos = fila.querySelector('.btn-all');
        if (botonTodos && botonTodos.classList.contains('active')) {
            tapacantos.arriba = true;
            tapacantos.derecha = true;
            tapacantos.abajo = true;
            tapacantos.izquierda = true;
        } else {
            // Verificar botones individuales
            const botonesDireccion = fila.querySelectorAll('.btn-direction');
            botonesDireccion.forEach(boton => {
                if (boton.classList.contains('active')) {
                    const direccion = boton.getAttribute('onclick').match(/'(\w+)'/);
                    if (direccion) {
                        tapacantos[direccion[1]] = true;
                    }
                }
            });
        }

        return tapacantos;
    }

    // Expandir piezas según cantidad
    function expandirPiezas(piezas) {
        const piezasExpandidas = [];
        
        piezas.forEach(pieza => {
            for (let i = 1; i <= pieza.cantidad; i++) {
                const piezaCopia = new Pieza(
                    pieza.numero,
                    1,
                    pieza.nombre,
                    pieza.ancho,
                    pieza.alto,
                    pieza.vetaLibre,
                    { ...pieza.tapacantos }
                );
                piezaCopia.indiceUnidad = i;
                piezaCopia.totalUnidades = pieza.cantidad;
                piezasExpandidas.push(piezaCopia);
            }
        });
        
        return piezasExpandidas;
    }



    // Optimización avanzada para máximo aprovechamiento (múltiples estrategias)
    function optimizarParaCorteCNC(piezasOrdenadas, anchoTablero, altoTablero, margen, kerf) {
        console.log('Probando múltiples estrategias para encontrar la mejor distribución...');
        
        // Probar diferentes estrategias y quedarse con la mejor
        const estrategias = [
            // Estrategia 1: Piezas grandes primero, orientación original
            () => optimizarConEstrategia(piezasOrdenadas, anchoTablero, altoTablero, margen, kerf, false),
            
            // Estrategia 2: Piezas grandes primero, con rotación automática
            () => optimizarConEstrategia(piezasOrdenadas, anchoTablero, altoTablero, margen, kerf, true),
            
            // Estrategia 3: Ordenar por dimensión más larga primero
            () => {
                const piezasReordenadas = [...piezasOrdenadas].sort((a, b) => {
                    const maxDimA = Math.max(a.ancho, a.alto);
                    const maxDimB = Math.max(b.ancho, b.alto);
                    return maxDimB - maxDimA;
                });
                return optimizarConEstrategia(piezasReordenadas, anchoTablero, altoTablero, margen, kerf, true);
            },
            
            // Estrategia 4: Optimización por densidad (área/perímetro)
            () => {
                const piezasReordenadas = [...piezasOrdenadas].sort((a, b) => {
                    const densidadA = a.getArea() / (2 * (a.ancho + a.alto));
                    const densidadB = b.getArea() / (2 * (b.ancho + b.alto));
                    return densidadB - densidadA;
                });
                return optimizarConEstrategia(piezasReordenadas, anchoTablero, altoTablero, margen, kerf, true);
            },
            
            // Estrategia 5: Piezas cuadradas/regulares primero
            () => {
                const piezasReordenadas = [...piezasOrdenadas].sort((a, b) => {
                    const ratioA = Math.max(a.ancho, a.alto) / Math.min(a.ancho, a.alto);
                    const ratioB = Math.max(b.ancho, b.alto) / Math.min(b.ancho, b.alto);
                    // Primero las más regulares (ratio más cercano a 1), luego por área
                    if (Math.abs(ratioA - ratioB) < 0.5) {
                        return b.getArea() - a.getArea();
                    }
                    return ratioA - ratioB;
                });
                return optimizarConEstrategia(piezasReordenadas, anchoTablero, altoTablero, margen, kerf, true);
            }
        ];
        
        let mejorSolucion = null;
        let mejorAprovechamiento = -1;
        let mejorEficiencia = -1;
        
        estrategias.forEach((estrategia, index) => {
            try {
                console.log(`Probando estrategia ${index + 1}...`);
                const tableros = estrategia();
                
                if (tableros && tableros.length > 0) {
                    const aprovechamientoTotal = calcularAprovechamientoTotal(tableros);
                    const eficiencia = aprovechamientoTotal / tableros.length; // Penalizar usar muchos tableros
                    
                    console.log(`Estrategia ${index + 1}: ${tableros.length} tableros, ${aprovechamientoTotal.toFixed(1)}% aprovechamiento, eficiencia: ${eficiencia.toFixed(1)}`);
                    
                    // Priorizar menos tableros con buen aprovechamiento
                    if (eficiencia > mejorEficiencia || 
                        (Math.abs(eficiencia - mejorEficiencia) < 5 && tableros.length < mejorSolucion?.length)) {
                        mejorEficiencia = eficiencia;
                        mejorAprovechamiento = aprovechamientoTotal;
                        mejorSolucion = tableros;
                        console.log(`✓ Nueva mejor solución encontrada!`);
                    }
                }
            } catch (error) {
                console.warn(`Error en estrategia ${index + 1}:`, error);
            }
        });
        
        if (mejorSolucion) {
            console.log(`Mejor solución: ${mejorSolucion.length} tableros con ${mejorAprovechamiento.toFixed(1)}% aprovechamiento`);
            
            // Renumerar tableros
            mejorSolucion.forEach((tablero, index) => {
                tablero.numero = index + 1;
            });
            
            return mejorSolucion;
        }
        
        // Fallback: estrategia simple si todas fallan
        console.warn('Usando estrategia de respaldo...');
        return optimizarConEstrategia(piezasOrdenadas, anchoTablero, altoTablero, margen, kerf, true);
    }
    
    // Optimizar con una estrategia específica mejorada
    function optimizarConEstrategia(piezasOrdenadas, anchoTablero, altoTablero, margen, kerf, permitirRotacion = true) {
        const tableros = [];
        let tableroActual = new Tablero(anchoTablero, altoTablero, margen, kerf);
        tableros.push(tableroActual);

        for (let pieza of piezasOrdenadas) {
            let colocada = false;
            let mejorTablero = null;
            let mejorPosicion = null;
            let mejorAprovechamiento = -1;
            let mejorRotacion = false;

            // Probar en todos los tableros existentes
            for (let tablero of tableros) {
                if (tablero.getAprovechamiento() < 98) { // Solo tableros con espacio
                    
                    // Probar orientación original
                    const posicion1 = tablero.encontrarPosicion(pieza);
                    if (posicion1) {
                        const aprovechamiento = calcularAprovechamientoPotencial(tablero, pieza);
                        if (aprovechamiento > mejorAprovechamiento) {
                            mejorAprovechamiento = aprovechamiento;
                            mejorTablero = tablero;
                            mejorPosicion = posicion1;
                            mejorRotacion = false;
                        }
                    }
                    
                    // Probar rotación si está permitida
                    if (permitirRotacion && pieza.puedeRotar()) {
                        pieza.rotar();
                        const posicion2 = tablero.encontrarPosicion(pieza);
                        if (posicion2) {
                            const aprovechamiento = calcularAprovechamientoPotencial(tablero, pieza);
                            if (aprovechamiento > mejorAprovechamiento) {
                                mejorAprovechamiento = aprovechamiento;
                                mejorTablero = tablero;
                                mejorPosicion = posicion2;
                                mejorRotacion = true;
                            }
                        }
                        pieza.rotar(); // Volver a orientación original
                    }
                }
            }

            // Colocar en la mejor posición encontrada
            if (mejorTablero && mejorPosicion) {
                if (mejorRotacion && pieza.puedeRotar()) {
                    pieza.rotar();
                }
                pieza.x = mejorPosicion.x;
                pieza.y = mejorPosicion.y;
                pieza.colocada = true;
                mejorTablero.piezas.push(pieza);
                colocada = true;
            }

            // Si no cabe en ningún tablero, crear uno nuevo
            if (!colocada) {
                tableroActual = new Tablero(anchoTablero, altoTablero, margen, kerf);
                tableroActual.numero = tableros.length + 1;
                tableros.push(tableroActual);
                
                if (tableroActual.agregarPieza(pieza)) {
                    colocada = true;
                } else if (permitirRotacion && pieza.puedeRotar()) {
                    pieza.rotar();
                    if (tableroActual.agregarPieza(pieza)) {
                        colocada = true;
                    } else {
                        pieza.rotar(); // Volver a orientación original
                    }
                }
            }

            if (!colocada) {
                console.warn(`No se pudo colocar: ${pieza.nombre} (${pieza.ancho}x${pieza.alto}mm)`);
            }
        }

        return tableros;
    }
    
    // Calcular aprovechamiento potencial si se coloca una pieza
    function calcularAprovechamientoPotencial(tablero, pieza) {
        const areaActual = tablero.calcularAreaUsada();
        const areaNueva = areaActual + pieza.getArea();
        const areaTotal = tablero.anchoUtil * tablero.altoUtil;
        return (areaNueva / areaTotal) * 100;
    }

    // Agrupar piezas por dimensiones compatibles para minimizar retazos
    function agruparPiezasPorDimensiones(piezas) {
        console.log('Analizando piezas para agrupar por dimensiones compatibles...');
        
        // Crear grupos de piezas con dimensiones similares/compatibles
        const grupos = [];
        const tolerancia = 10; // mm de tolerancia para considerar dimensiones similares
        
        // Identificar dimensiones únicas
        const dimensionesUnicas = new Map();
        
        piezas.forEach(pieza => {
            const dim1 = Math.min(pieza.ancho, pieza.alto);
            const dim2 = Math.max(pieza.ancho, pieza.alto);
            const clave = `${dim1}x${dim2}`;
            
            if (!dimensionesUnicas.has(clave)) {
                dimensionesUnicas.set(clave, []);
            }
            dimensionesUnicas.get(clave).push(pieza);
        });
        
        // Agrupar dimensiones compatibles
        const gruposCompatibles = [];
        const dimensionesProcesadas = new Set();
        
        for (let [clave1, piezas1] of dimensionesUnicas) {
            if (dimensionesProcesadas.has(clave1)) continue;
            
            const [dim1_1, dim2_1] = clave1.split('x').map(Number);
            const grupoCompatible = {
                dimensionPrincipal: Math.max(dim1_1, dim2_1),
                dimensionSecundaria: Math.min(dim1_1, dim2_1),
                piezas: [...piezas1],
                claves: [clave1]
            };
            
            dimensionesProcesadas.add(clave1);
            
            // Buscar otras dimensiones compatibles
            for (let [clave2, piezas2] of dimensionesUnicas) {
                if (dimensionesProcesadas.has(clave2)) continue;
                
                const [dim1_2, dim2_2] = clave2.split('x').map(Number);
                const maxDim2 = Math.max(dim1_2, dim2_2);
                const minDim2 = Math.min(dim1_2, dim2_2);
                
                // Compatibilidad: una dimensión igual o similar
                const compatiblePorDimension1 = Math.abs(grupoCompatible.dimensionPrincipal - maxDim2) <= tolerancia;
                const compatiblePorDimension2 = Math.abs(grupoCompatible.dimensionSecundaria - minDim2) <= tolerancia;
                const compatiblePorAlt1 = Math.abs(grupoCompatible.dimensionPrincipal - minDim2) <= tolerancia;
                const compatiblePorAlt2 = Math.abs(grupoCompatible.dimensionSecundaria - maxDim2) <= tolerancia;
                
                if (compatiblePorDimension1 || compatiblePorDimension2 || 
                    compatiblePorAlt1 || compatiblePorAlt2) {
                    grupoCompatible.piezas.push(...piezas2);
                    grupoCompatible.claves.push(clave2);
                    dimensionesProcesadas.add(clave2);
                }
            }
            
            gruposCompatibles.push(grupoCompatible);
        }
        
        // Ordenar grupos por potencial de aprovechamiento
        gruposCompatibles.sort((a, b) => {
            // Priorizar grupos con más piezas de dimensiones similares
            const pesoA = a.piezas.length * a.piezas.reduce((sum, p) => sum + p.getArea(), 0);
            const pesoB = b.piezas.length * b.piezas.reduce((sum, p) => sum + p.getArea(), 0);
            return pesoB - pesoA;
        });
        
        // Dentro de cada grupo, ordenar por área descendente
        gruposCompatibles.forEach(grupo => {
            grupo.piezas.sort((a, b) => b.getArea() - a.getArea());
        });
        
        // Crear lista final ordenada por grupos
        const piezasOrdenadas = [];
        gruposCompatibles.forEach((grupo, indiceGrupo) => {
            console.log(`Grupo ${indiceGrupo + 1}: ${grupo.claves.join(', ')} (${grupo.piezas.length} piezas)`);
            piezasOrdenadas.push(...grupo.piezas);
        });
        
        return piezasOrdenadas;
    }

    // Optimización especializada con agrupación por dimensiones (mejorada)
    function optimizarConAgrupacionDimensiones(piezasAgrupadas, anchoTablero, altoTablero, margen, kerf) {
        console.log('Optimizando con estrategia de agrupación por dimensiones...');
        
        const tableros = [];
        let tableroActual = new Tablero(anchoTablero, altoTablero, margen, kerf);
        tableros.push(tableroActual);
        
        for (let i = 0; i < piezasAgrupadas.length; i++) {
            const pieza = piezasAgrupadas[i];
            let colocada = false;
            
            console.log(`Procesando pieza ${i + 1}/${piezasAgrupadas.length}: ${pieza.nombre} (${pieza.ancho}x${pieza.alto}mm)`);
            
            // FASE 1: Intentar en TODOS los tableros existentes (no solo compatibles)
            let mejorOpcion = null;
            let mejorPuntuacion = -Infinity;
            
            for (let j = 0; j < tableros.length; j++) {
                const tablero = tableros[j];
                
                // Solo considerar tableros que no estén completamente llenos
                if (tablero.getAprovechamiento() < 98) {
                    
                    // Probar orientación original
                    const posicionOriginal = tablero.encontrarPosicion(pieza);
                    if (posicionOriginal) {
                        const puntuacionCompatibilidad = calcularCompatibilidadDimensional(tablero, pieza);
                        const puntuacionAprovechamiento = calcularAprovechamientoPotencial(tablero, pieza);
                        const puntuacionTotal = puntuacionCompatibilidad + puntuacionAprovechamiento * 2;
                        
                        if (puntuacionTotal > mejorPuntuacion) {
                            mejorPuntuacion = puntuacionTotal;
                            mejorOpcion = {
                                tablero: tablero,
                                posicion: posicionOriginal,
                                rotada: false,
                                puntuacion: puntuacionTotal
                            };
                        }
                    }
                    
                    // Probar rotación si es posible
                    if (pieza.puedeRotar()) {
                        pieza.rotar();
                        const posicionRotada = tablero.encontrarPosicion(pieza);
                        if (posicionRotada) {
                            const puntuacionCompatibilidad = calcularCompatibilidadDimensional(tablero, pieza);
                            const puntuacionAprovechamiento = calcularAprovechamientoPotencial(tablero, pieza);
                            const puntuacionTotal = puntuacionCompatibilidad + puntuacionAprovechamiento * 2;
                            
                            if (puntuacionTotal > mejorPuntuacion) {
                                mejorPuntuacion = puntuacionTotal;
                                mejorOpcion = {
                                    tablero: tablero,
                                    posicion: posicionRotada,
                                    rotada: true,
                                    puntuacion: puntuacionTotal
                                };
                            }
                        }
                        pieza.rotar(); // Volver a orientación original
                    }
                }
            }
            
            // FASE 2: Colocar en la mejor opción encontrada
            if (mejorOpcion && mejorOpcion.puntuacion > 0) {
                if (mejorOpcion.rotada && pieza.puedeRotar()) {
                    pieza.rotar();
                }
                
                pieza.x = mejorOpcion.posicion.x;
                pieza.y = mejorOpcion.posicion.y;
                pieza.colocada = true;
                mejorOpcion.tablero.piezas.push(pieza);
                colocada = true;
                
                console.log(`✓ Colocada en tablero ${mejorOpcion.tablero.numero} (puntuación: ${mejorOpcion.puntuacion.toFixed(1)})`);
            }
            
            // FASE 3: Solo crear nuevo tablero si realmente no cabe en ninguno
            if (!colocada) {
                // Último intento: probar en todos los tableros sin restricciones de puntuación
                for (let tablero of tableros) {
                    if (tablero.agregarPieza(pieza)) {
                        colocada = true;
                        console.log(`✓ Colocada en tablero ${tablero.numero} (último intento)`);
                        break;
                    } else if (pieza.puedeRotar()) {
                        pieza.rotar();
                        if (tablero.agregarPieza(pieza)) {
                            colocada = true;
                            console.log(`✓ Colocada rotada en tablero ${tablero.numero} (último intento)`);
                            break;
                        } else {
                            pieza.rotar(); // Volver a orientación original
                        }
                    }
                }
                
                // Crear nuevo tablero solo si absolutamente no cabe en ninguno
                if (!colocada) {
                    tableroActual = new Tablero(anchoTablero, altoTablero, margen, kerf);
                    tableroActual.numero = tableros.length + 1;
                    tableros.push(tableroActual);
                    
                    if (tableroActual.agregarPieza(pieza)) {
                        colocada = true;
                        console.log(`✓ Colocada en NUEVO tablero ${tableroActual.numero}`);
                    } else if (pieza.puedeRotar()) {
                        pieza.rotar();
                        if (tableroActual.agregarPieza(pieza)) {
                            colocada = true;
                            console.log(`✓ Colocada rotada en NUEVO tablero ${tableroActual.numero}`);
                        } else {
                            pieza.rotar();
                        }
                    }
                }
            }
            
            if (!colocada) {
                console.error(`❌ No se pudo colocar: ${pieza.nombre} (${pieza.ancho}x${pieza.alto}mm)`);
            }
        }
        
        // Mostrar estadísticas finales
        console.log(`\n=== RESUMEN FINAL ===`);
        tableros.forEach((tablero, index) => {
            const aprovechamiento = tablero.getAprovechamiento();
            console.log(`Tablero ${index + 1}: ${tablero.piezas.length} piezas, ${aprovechamiento.toFixed(1)}% aprovechamiento`);
            tablero.numero = index + 1;
        });
        
        return tableros;
    }
    
    // Calcular compatibilidad dimensional entre tablero y pieza nueva (mejorada)
    function calcularCompatibilidadDimensional(tablero, piezaNueva) {
        if (tablero.piezas.length === 0) return 200; // Tablero vacío tiene alta prioridad
        
        let puntuacion = 50; // Puntuación base para cualquier tablero con espacio
        const tolerancia = 20; // mm - aumentada para ser menos restrictivo
        
        // Analizar dimensiones de piezas existentes en el tablero
        for (let piezaExistente of tablero.piezas) {
            // Bonus alto por dimensiones iguales o muy similares
            if (Math.abs(piezaExistente.ancho - piezaNueva.ancho) <= 5) {
                puntuacion += 150; // Bonus muy alto por igualdad exacta
            } else if (Math.abs(piezaExistente.ancho - piezaNueva.ancho) <= tolerancia) {
                puntuacion += 80; // Bonus por similitud
            }
            
            if (Math.abs(piezaExistente.alto - piezaNueva.alto) <= 5) {
                puntuacion += 150; // Bonus muy alto por igualdad exacta
            } else if (Math.abs(piezaExistente.alto - piezaNueva.alto) <= tolerancia) {
                puntuacion += 80; // Bonus por similitud
            }
            
            // Bonus por dimensiones compatibles con rotación
            if (Math.abs(piezaExistente.ancho - piezaNueva.alto) <= tolerancia) {
                puntuacion += 60;
            }
            if (Math.abs(piezaExistente.alto - piezaNueva.ancho) <= tolerancia) {
                puntuacion += 60;
            }
            
            // Bonus por formar filas/columnas
            if (Math.abs(piezaExistente.alto - piezaNueva.alto) <= tolerancia) {
                puntuacion += 40; // Fila horizontal
            }
            if (Math.abs(piezaExistente.ancho - piezaNueva.ancho) <= tolerancia) {
                puntuacion += 40; // Columna vertical
            }
        }
        
        // Bonus por aprovechamiento actual del tablero (llenar tableros parciales)
        const aprovechamientoActual = tablero.getAprovechamiento();
        if (aprovechamientoActual > 30 && aprovechamientoActual < 85) {
            puntuacion += 100; // Bonus por llenar tableros parcialmente ocupados
        }
        
        // Penalización más suave por diversidad
        const dimensionesUnicas = new Set();
        tablero.piezas.forEach(p => {
            dimensionesUnicas.add(`${Math.min(p.ancho, p.alto)}x${Math.max(p.ancho, p.alto)}`);
        });
        
        if (dimensionesUnicas.size > 4) {
            puntuacion -= 30; // Penalización más suave
        }
        
        // Bonus por cantidad de piezas (prefiere llenar tableros existentes)
        puntuacion += Math.min(tablero.piezas.length * 10, 50);
        
        return Math.max(puntuacion, 10); // Puntuación mínima para evitar valores negativos
    }

    // Generar secuencia optimizada de cortes para CNC
    function generarSecuenciaCortes(tablero) {
        const piezas = tablero.piezas;
        if (piezas.length === 0) {
            return { cortesVerticales: 0, cortesHorizontales: 0, secuencia: [] };
        }

        // Identificar líneas de corte únicas
        const lineasVerticales = new Set();
        const lineasHorizontales = new Set();
        
        // Bordes del tablero
        lineasVerticales.add(0);
        lineasVerticales.add(tablero.anchoUtil);
        lineasHorizontales.add(0);
        lineasHorizontales.add(tablero.altoUtil);
        
        // Líneas de corte de las piezas
        piezas.forEach(pieza => {
            // Líneas verticales (izquierda y derecha de cada pieza)
            lineasVerticales.add(pieza.x);
            lineasVerticales.add(pieza.x + pieza.ancho);
            
            // Líneas horizontales (arriba y abajo de cada pieza)
            lineasHorizontales.add(pieza.y);
            lineasHorizontales.add(pieza.y + pieza.alto);
        });

        // Convertir a arrays ordenados
        const cortesVerticales = Array.from(lineasVerticales).sort((a, b) => a - b);
        const cortesHorizontales = Array.from(lineasHorizontales).sort((a, b) => a - b);

        // Generar secuencia de corte optimizada
        const secuencia = [];
        
        // Primero cortes verticales (de izquierda a derecha)
        for (let i = 1; i < cortesVerticales.length - 1; i++) {
            secuencia.push({
                tipo: 'vertical',
                posicion: cortesVerticales[i],
                desde: 0,
                hasta: tablero.altoUtil,
                orden: i
            });
        }
        
        // Luego cortes horizontales (de arriba a abajo)
        for (let i = 1; i < cortesHorizontales.length - 1; i++) {
            secuencia.push({
                tipo: 'horizontal', 
                posicion: cortesHorizontales[i],
                desde: 0,
                hasta: tablero.anchoUtil,
                orden: cortesVerticales.length - 2 + i
            });
        }

        return {
            cortesVerticales: cortesVerticales.length - 2, // Excluir bordes del tablero
            cortesHorizontales: cortesHorizontales.length - 2, // Excluir bordes del tablero
            secuencia: secuencia,
            lineasVerticales: cortesVerticales,
            lineasHorizontales: cortesHorizontales
        };
    }

    // Dibujar líneas de corte simplificadas
    function dibujarLineasCorte(svg, secuenciaCortes, tablero, offsetX, offsetY, escala) {
        const margenTablero = tablero.margenOriginal * escala;
        const lineasV = (secuenciaCortes && Array.isArray(secuenciaCortes.lineasVerticales)) ? secuenciaCortes.lineasVerticales : [];
        const lineasH = (secuenciaCortes && Array.isArray(secuenciaCortes.lineasHorizontales)) ? secuenciaCortes.lineasHorizontales : [];
        
        // Líneas de corte verticales (sutiles)
        lineasV.forEach((x) => {
            if (x > 0 && x < tablero.anchoUtil) {
                const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const xPos = offsetX + margenTablero + (x * escala);
                
                linea.setAttribute('x1', xPos);
                linea.setAttribute('y1', offsetY + margenTablero);
                linea.setAttribute('x2', xPos);
                linea.setAttribute('y2', offsetY + margenTablero + (tablero.altoUtil * escala));
                linea.setAttribute('stroke', '#95a5a6');
                linea.setAttribute('stroke-width', '1');
                linea.setAttribute('stroke-dasharray', '5,3');
                linea.setAttribute('opacity', '0.5');
                svg.appendChild(linea);
            }
        });
        
        // Líneas de corte horizontales (sutiles)
        lineasH.forEach((y) => {
            if (y > 0 && y < tablero.altoUtil) {
                const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const yPos = offsetY + margenTablero + (y * escala);
                
                linea.setAttribute('x1', offsetX + margenTablero);
                linea.setAttribute('y1', yPos);
                linea.setAttribute('x2', offsetX + margenTablero + (tablero.anchoUtil * escala));
                linea.setAttribute('y2', yPos);
                linea.setAttribute('stroke', '#95a5a6');
                linea.setAttribute('stroke-width', '1');
                linea.setAttribute('stroke-dasharray', '5,3');
                linea.setAttribute('opacity', '0.5');
                svg.appendChild(linea);
            }
        });
    }

    // Calcular aprovechamiento total de todos los tableros
    function calcularAprovechamientoTotal(tableros) {
        let areaTotal = 0;
        let areaUsada = 0;
        
        for (let tablero of tableros) {
            areaTotal += tablero.ancho * tablero.alto;
            areaUsada += tablero.calcularAreaUsada();
        }
        
        return areaTotal > 0 ? (areaUsada / areaTotal) * 100 : 0;
    }

    // Heurística rápida tipo estantes (FFDH/BFDH)
    function optimizarEstantesRapido(piezas, anchoTablero, altoTablero, margen, kerf, inicioTiempo, limiteMs) {
        const tableros = [];
        let tablero = new Tablero(anchoTablero, altoTablero, margen, kerf);
        tablero.numero = 1;
        tableros.push(tablero);

        // Un "estante" es una franja horizontal: y, altura, xActual
        let estantes = [{ y: 0, altura: 0, x: 0 }];

        // Escaneo con índice para poder saltar/traer piezas futuras al estante actual
        for (let i = 0; i < piezas.length; i++) {
            const piezaOriginal = piezas[i];
            if (piezaOriginal.colocada) continue;
            if (Date.now() - inicioTiempo > limiteMs) break; // time guard
            // Intentar sin y con rotación (si ayuda altura del estante)
            const variantes = [
                { w: piezaOriginal.ancho, h: piezaOriginal.alto, rot: false },
                ...(piezaOriginal.puedeRotar() ? [{ w: piezaOriginal.alto, h: piezaOriginal.ancho, rot: true }] : [])
            ];

            let colocada = false;
            // Intentar en estantes existentes (BFDH: mejor ajuste por altura)
            const estantesOrden = [...estantes].sort((a,b)=>a.altura-b.altura);
            for (const est of estantesOrden) {
                for (const v of variantes) {
                    if (v.h <= (est.altura || v.h)) {
                        // Si est.altura=0, inicia con altura de la primera pieza
                        const alturaEstante = Math.max(est.altura, v.h);
                        if (est.x + v.w <= tablero.anchoUtil && est.y + alturaEstante <= tablero.altoUtil) {
                            // Aplicar rotación si corresponde
                            if (v.rot) piezaOriginal.rotar();
                            if (!tablero.agregarPiezaEn(piezaOriginal, est.x, est.y)) {
                                if (v.rot) piezaOriginal.rotar();
                                continue;
                            }
                            // Actualizar estante
                            est.altura = alturaEstante;
                            est.x += v.w + kerf;
                            colocada = true;

                            // Rellenar estante con piezas de altura compatible (lookahead limitado)
                            rellenarEstanteRapido(piezas, tablero, est, alturaEstante, kerf, inicioTiempo, limiteMs);
                            break;
                        }
                    }
                }
                if (colocada) break;
            }

            // Si no cupo en estantes, abrir un nuevo estante debajo
            if (!colocada) {
                // encontrar y libre = máxima base de estantes + kerf
                const yNuevo = estantes.reduce((s,e)=>Math.max(s, e.y + (e.altura||0) + kerf), 0);
                // Altura mínima requerida (si no tiene veta libre, debe respetar su alto)
                const alturaMinReq = piezaOriginal.puedeRotar() ? Math.min(piezaOriginal.alto, piezaOriginal.ancho) : piezaOriginal.alto;
                // si no cabe en y, crear nuevo tablero
                if (yNuevo + alturaMinReq > tablero.altoUtil) {
                    tablero = new Tablero(anchoTablero, altoTablero, margen, kerf);
                    tablero.numero = tableros.length + 1;
                    tableros.push(tablero);
                    estantes = [{ y: 0, altura: 0, x: 0 }];
                }

                const est = { y: yNuevo, altura: 0, x: 0 };
                estantes.push(est);

                // probar variantes en nuevo estante
                let puesta = false;
                for (const v of variantes) {
                    if (v.w <= tablero.anchoUtil && v.h <= tablero.altoUtil - est.y) {
                        if (v.rot) piezaOriginal.rotar();
                        if (tablero.agregarPiezaEn(piezaOriginal, est.x, est.y)) {
                            est.altura = v.h;
                            est.x += v.w + kerf;
                            puesta = true; break;
                        }
                        if (v.rot) piezaOriginal.rotar();
                    }
                }
                if (!puesta) {
                    // Intentar abriendo un nuevo tablero y colocando como primera del estante
                    const nuevoTablero = new Tablero(anchoTablero, altoTablero, margen, kerf);
                    nuevoTablero.numero = tableros.length + 1;
                    tableros.push(nuevoTablero);
                    estantes = [{ y: 0, altura: 0, x: 0 }];
                    const estNuevo = estantes[0];
                    for (const v of variantes) {
                        if (v.w <= nuevoTablero.anchoUtil && v.h <= nuevoTablero.altoUtil) {
                            if (v.rot) piezaOriginal.rotar();
                            if (nuevoTablero.agregarPiezaEn(piezaOriginal, estNuevo.x, estNuevo.y)) {
                                estNuevo.altura = v.h;
                                estNuevo.x += v.w + kerf;
                                tablero = nuevoTablero;
                                puesta = true; break;
                            }
                            if (v.rot) piezaOriginal.rotar();
                        }
                    }
                    // Último recurso: método normal en el nuevo tablero
                    if (!puesta) {
                        if (nuevoTablero.agregarPieza(piezaOriginal)) {
                            tablero = nuevoTablero;
                            puesta = true;
                        } else if (piezaOriginal.puedeRotar && piezaOriginal.puedeRotar()) {
                            piezaOriginal.rotar();
                            if (nuevoTablero.agregarPieza(piezaOriginal)) {
                                tablero = nuevoTablero;
                                puesta = true;
                            } else {
                                piezaOriginal.rotar();
                            }
                        }
                    }
                }
                if (puesta) {
                    // Rellenar el nuevo estante con piezas compatibles
                    rellenarEstanteRapido(piezas, tablero, est, est.altura, kerf, inicioTiempo, limiteMs);
                }
            }
        }

        return tableros;
    }

    // Intentar completar el ancho del estante con piezas de altura similar (rápido y con límites)
    function rellenarEstanteRapido(piezas, tablero, est, alturaObjetivo, kerf, inicioTiempo, limiteMs) {
        const toleranciaAltura = 10; // mm
        const maxInserciones = 12;   // permitir más relleno de franja
        const maxScan = 200;         // explorar más piezas para rellenar
        let insertadas = 0;
        let escaneadas = 0;
        for (let j = 0; j < piezas.length && insertadas < maxInserciones && escaneadas < maxScan; j++) {
            if (Date.now() - inicioTiempo > limiteMs) break;
            const p = piezas[j];
            if (!p || p.colocada) continue;
            escaneadas++;

            // considerar dos orientaciones si vetalibre
            const cand = [ {w:p.ancho, h:p.alto, rot:false} ];
            if (p.puedeRotar && p.puedeRotar()) cand.push({w:p.alto, h:p.ancho, rot:true});

            for (const c of cand) {
                const alturaCompatible = Math.abs(c.h - alturaObjetivo) <= toleranciaAltura || c.h <= alturaObjetivo;
                const anchoRestante = tablero.anchoUtil - est.x;
                if (alturaCompatible && c.w <= anchoRestante) {
                    if (c.rot) p.rotar();
                    if (tablero.agregarPiezaEn(p, est.x, est.y)) {
                        est.x += c.w + kerf;
                        // mantener altura del estante como la máxima
                        est.altura = Math.max(est.altura, c.h);
                        insertadas++;
                        break;
                    } else if (c.rot) {
                        p.rotar();
                    }
                }
            }
        }
    }

    // Mostrar resultados de optimización
    function mostrarResultados(tableros) {
        // Calcular estadísticas generales
        const totalTableros = tableros.length;
        const aprovechamientoPromedio = tableros.reduce((sum, t) => sum + t.getAprovechamiento(), 0) / totalTableros;
        const desperdicioTotal = tableros.reduce((sum, t) => sum + t.getDesperdicio(), 0);
    const tapacantoTotal = calcularTapacantoTotal(tableros); // en mm

        // Actualizar estadísticas en la interfaz
        document.getElementById('tablerosUsados').textContent = totalTableros;
        document.getElementById('aprovechamiento').textContent = aprovechamientoPromedio.toFixed(1) + '%';
        document.getElementById('desperdicio').textContent = (desperdicioTotal / 1000000).toFixed(3) + ' m²';
        document.getElementById('tapacantos').textContent = (tapacantoTotal / 1000).toFixed(1) + ' m';

        // Rellenar resumen compacto
        try {
            const nombreProyecto = document.getElementById('nombreProyecto')?.value || '';
            const cliente = document.getElementById('clienteInput')?.value || '';
            const rut = document.getElementById('rutCliente')?.value || '';
            const activeTab = document.querySelector('#materialTabs button.nav-link.active');
            const matIdx = (activeTab && activeTab.id && activeTab.id.match(/material(\d+)-tab/)) ? parseInt(activeTab.id.match(/material(\d+)-tab/)[1],10) : 1;
            const selMat = document.getElementById(`tableroSelect${matIdx}`);
            const optSel = selMat ? selMat.selectedOptions[0] : null;
            const ancho = parseFloat(document.getElementById(`ancho${matIdx}`)?.value||'0');
            const alto = parseFloat(document.getElementById(`alto${matIdx}`)?.value||'0');
            const margenX = parseFloat(document.getElementById(`margenX${matIdx}`)?.value||'0');
            const margenY = parseFloat(document.getElementById(`margenX${matIdx}`)?.value||'0');
            const kerf = parseFloat(document.getElementById(`desperdicioSierra${matIdx}`)?.value||'0');
            const areaTableroM2 = (ancho*alto)/1_000_000;
            const precioM2 = optSel ? parseFloat(optSel.dataset.precio_m2||'0') : 0;
            const costoTablero = precioM2*areaTableroM2;
            const costoTableros = costoTablero*totalTableros;
            // Tapacanto: precio por metro desde el select
            const optTap = document.getElementById(`tapacantoSelect${matIdx}`)?.selectedOptions?.[0] || null;
            const precioMetroTap = optTap ? parseFloat(optTap.dataset.precio_metro||'0') : 0;
            const mlTapacanto = tapacantoTotal/1000; // mm a m
            const costoTapacanto = mlTapacanto * precioMetroTap;
            const costoTotal = (costoTableros + costoTapacanto);

            document.getElementById('resNombre').textContent = nombreProyecto || '(Sin nombre)';
            (function(){
                const f = document.getElementById('folioProyecto');
                if (f && f.value) { document.getElementById('resFolio').textContent = f.value; }
            })();
            document.getElementById('resCliente').textContent = cliente || '(Sin cliente)';
            document.getElementById('resClienteRut').textContent = rut ? `(${rut})` : '';
            document.getElementById('resMaterial').textContent = optSel ? (optSel.textContent||'Material') : 'Material';
            document.getElementById('resDim').textContent = `${ancho}×${alto} mm`;
            document.getElementById('resVetas').textContent = 'Libre según pieza';
            document.getElementById('resKerf').textContent = `${kerf} mm`;
            document.getElementById('resMargenes').textContent = `Margen: ${margenX} mm`;
            document.getElementById('resArea').textContent = `${(areaTableroM2*totalTableros).toFixed(2)} m² (${totalTableros} tableros)`;
            document.getElementById('resAprovech').textContent = `${aprovechamientoPromedio.toFixed(1)}%`;
            const areaUtilM2 = ((ancho - 2*margenX) * (alto - 2*margenX))/1_000_000;
            const sobrantesM2 = Math.max((areaTableroM2*totalTableros) - (aprovechamientoPromedio/100 * areaUtilM2 * totalTableros), 0);
            const resSob = document.getElementById('resSobrantes');
            if (resSob) resSob.textContent = `${sobrantesM2.toFixed(3)} m²`;
            // Mostrar en resumen: Nombre (Código)
            (function(){
                const sel = document.getElementById(`tapacantoSelect${matIdx}`);
                if(sel && sel.selectedOptions && sel.selectedOptions[0]){
                    const opt = sel.selectedOptions[0];
                    const nombreCompleto = (opt.textContent||'');
                    const nombre = nombreCompleto.split(' (')[0];
                    const codigo = opt.dataset.codigo || '';
                    document.getElementById('resTapacanto').textContent = codigo ? `${nombre} (${codigo})` : nombre;
                } else {
                    document.getElementById('resTapacanto').textContent = '—';
                }
            })();
            document.getElementById('resTapML').textContent = `${mlTapacanto.toFixed(2)} m`;
            document.getElementById('wrapResTapML').classList.toggle('d-none', mlTapacanto <= 0.0001);
            const costoTxt = costoTotal ? `$ ${costoTotal.toFixed(2)} (Tableros: $${costoTableros.toFixed(2)}${precioMetroTap?`, Tapacanto: $${costoTapacanto.toFixed(2)}`:''})` : '—';
            document.getElementById('resCosto').textContent = costoTxt;

            // Vetas: contar piezas con veta libre vs fija (según checkbox por fila)
            try {
                const tbody = document.getElementById('piezasTableBody');
                let libres = 0, fijas = 0;
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const qty = parseInt(tr.querySelector('td:nth-child(2) input')?.value||'1',10) || 1;
                    const chk = tr.querySelector('.veta-checkbox');
                    if (chk && chk.checked) libres += qty; else fijas += qty;
                });
                document.getElementById('resVetas').textContent = `Libre: ${libres} • Fija: ${fijas}`;
            } catch(e2) { /* noop */ }
            document.getElementById('resumenProyecto').style.display = 'block';
        } catch(e){ console.warn('No se pudo poblar el resumen:', e.message); }

    // Generar visualización solo una vez; bloquear re-render inmediato
    try{ 
        const contVis = document.getElementById('visualizacionTableros');
        if (contVis){
            if (contVis.dataset.locked === '1'){
                console.log('Render inicial ya fijado, se omite nuevo render.');
            } else {
                generarVisualizacion(tableros);
                contVis.dataset.locked = '1';
            }
        } else {
            generarVisualizacion(tableros);
        }
    }catch(_e){ generarVisualizacion(tableros); }

        // Mostrar área de resultados
        document.getElementById('resultadosOptimizacion').style.display = 'block';
        
        // Scroll hacia los resultados
        document.getElementById('resultadosOptimizacion').scrollIntoView({ 
            behavior: 'smooth' 
        });
    }

    // Descargar PDF del proyecto; si no hay resultado, intentar forzar optimización primero
    async function descargarPDF() {
        if (window._bloquearPDF) { alert('Actualizando ID/archivo. Intenta nuevamente en unos segundos.'); return; }
        const btn = document.getElementById('btnDescargarPDF');
        if (btn) { btn.disabled = true; btn.classList.add('disabled'); btn.style.cursor = 'progress'; }
        // Prioridad: el proyecto que figura en el resumen del proyecto
        const resumenEl = document.getElementById('resumenProyecto');
        let proyectoId = resumenEl ? resumenEl.getAttribute('data-proyecto-id') : null;
        if (!proyectoId) {
            const proyectoIdEl = document.getElementById('resultadosOptimizacion');
            proyectoId = proyectoIdEl ? proyectoIdEl.getAttribute('data-proyecto-id') : null;
        }
        if (!proyectoId) { alert('Primero crea y guarda un proyecto para poder exportar PDF.'); return; }
        const url = `/optimizador/exportar-pdf/${encodeURIComponent(proyectoId)}/`;
        // Mostrar toast no intrusivo
        const toast = document.getElementById('toastGenerandoPdf');
        if (toast) toast.style.display = 'block';
        // Abrir en nueva pestaña sin bloquear UI
        setTimeout(()=>{
            try {
                window.open(url, '_blank', 'noopener');
            } finally {
                setTimeout(()=>{ if (toast) toast.style.display = 'none'; }, 1500);
                setTimeout(()=>{ if (btn) { btn.disabled = false; btn.classList.remove('disabled'); btn.style.cursor = ''; } }, 1200);
            }
        }, 50);
    }

    // Imprimir el mismo PDF generado (no la pantalla), intentando forzar optimización antes
    async function imprimirPDF(){
        if (window._bloquearPDF) { alert('Actualizando folio/archivo. Intenta nuevamente en unos segundos.'); return; }
        const resumenEl = document.getElementById('resumenProyecto');
        let proyectoId = resumenEl ? resumenEl.getAttribute('data-proyecto-id') : null;
        if (!proyectoId){
            const cont = document.getElementById('resultadosOptimizacion');
            proyectoId = cont ? cont.getAttribute('data-proyecto-id') : null;
        }
        if(!proyectoId){ alert('Primero guarda el proyecto para generar el PDF.'); return; }
        const url = `/optimizador/exportar-pdf/${encodeURIComponent(proyectoId)}/`;
        // Crear iframe oculto si no existe
        let iframe = document.getElementById('printPdfIframe');
        if(!iframe){
            iframe = document.createElement('iframe');
            iframe.id = 'printPdfIframe';
            iframe.style.position = 'fixed';
            iframe.style.right = '-10000px';
            iframe.style.bottom = '0';
            iframe.style.width = '1px';
            iframe.style.height = '1px';
            iframe.style.border = '0';
            document.body.appendChild(iframe);
        }
        iframe.onload = function(){
            try { iframe.contentWindow.focus(); iframe.contentWindow.print(); } catch(e){ window.open(url,'_blank'); }
        };
        iframe.src = url;
    }

    // Hook: cuando el backend responde a optimización, si incluye 'folio', reflejarlo
    (function(){
        const origFetch = window.fetch;
        window.fetch = function(){
            return origFetch.apply(this, arguments).then(async resp=>{
                try {
                    // Clonar sólo JSON de respuestas de optimización
                    const url = (arguments && arguments[0]) ? String(arguments[0]) : '';
                    if (url.includes('/optimizador/optimizar-material')){
                        const clone = resp.clone();
                        const data = await clone.json().catch(()=>null);
                        if (data && data.folio){
                            const f = document.getElementById('folioProyecto');
                            if (f){ f.value = data.folio; }
                            const rf = document.getElementById('resFolio');
                            if (rf){ rf.textContent = data.folio; }
                        }
                    }
                } catch(_e) {}
                return resp;
            });
        }
    })();

    // Calcular total de tapacanto necesario
    function calcularTapacantoTotal(tableros) {
        let total = 0;
        tableros.forEach(tablero => {
            tablero.piezas.forEach(pieza => {
                if (pieza.tapacantos.arriba) total += pieza.ancho;
                if (pieza.tapacantos.derecha) total += pieza.alto;
                if (pieza.tapacantos.abajo) total += pieza.ancho;
                if (pieza.tapacantos.izquierda) total += pieza.alto;
            });
        });
        return total;
    }

    function generarFolio(){
        // El folio lo asigna el backend (correlativo-versión) y se carga en #folioProyecto.
        const f = document.getElementById('folioProyecto');
        return (f && f.value) ? f.value : '';
    }



    // Generar visualización SVG de los tableros (función original)
    function generarVisualizacion(tableros) {
        // Respetar el bloqueo de visualización si ya fue fijada por el primer render
        try{
            const contVis = document.getElementById('visualizacionTableros');
            if (contVis && contVis.dataset && contVis.dataset.locked === '1' && !window.__allowReRender){
                console.log('generarVisualizacion(): bloqueo activo, no se vuelve a pintar.');
                return;
            }
        }catch(_e){}
        const container = document.getElementById('visualizacionTableros');
        try { container.classList.remove('show'); } catch(_e){}
        container.innerHTML = '';
        currentTablerosVis = tableros || [];
        tableros.forEach(tablero => {
            const svgElement = crearSVGTablero(tablero);
            container.appendChild(svgElement);
        });
        // activar fade-in
        setTimeout(()=>{ try { container.classList.add('show'); } catch(_e){} }, 10);
        // Si el modo manual ya estaba activo antes de renderizar, poner cursor de movimiento
        if (modoManual) {
            document.querySelectorAll('#visualizacionTableros svg .piece-group').forEach(g=>{
                g.style.cursor = 'move';
            });
        }
    }

    // Precarga desde parámetro ?proyecto_id= para abrir en modo edición
    document.addEventListener('DOMContentLoaded', async function(){
        try{
            const params = new URLSearchParams(window.location.search);
            const pid = params.get('proyecto_id');
            if (!pid) return;
            const resumenEl = document.getElementById('resumenProyecto');
            const resCont = document.getElementById('resultadosOptimizacion');
            if (resumenEl) resumenEl.style.display = 'block';
            if (resumenEl) resumenEl.setAttribute('data-proyecto-id', String(pid));
            if (resCont) resCont.setAttribute('data-proyecto-id', String(pid));
            // Desbloquear edición inmediata de piezas al entrar en modo edición
            try { if (typeof actualizarBloqueoTabla === 'function') actualizarBloqueoTabla(); } catch(_e) {}
            // 1) Cargar datos básicos del proyecto
            try{
                const r = await fetch(`/optimizador/proyectos/preview-json/${encodeURIComponent(pid)}/`, { headers: {'X-Requested-With':'XMLHttpRequest'} });
                if (r.ok){
                    const dj = await r.json();
                    const p = dj && dj.proyecto ? dj.proyecto : null;
                    if (p){
                        const rn = document.getElementById('resNombre'); if (rn) rn.textContent = p.nombre || '';
                        const rc = document.getElementById('resCliente'); if (rc) rc.textContent = p.cliente || '';
                        // Rellenar inputs visibles
                        try{
                            const inCliente = document.getElementById('clienteInput'); if (inCliente) inCliente.value = p.cliente || '';
                            const inNombre = document.getElementById('nombreProyecto'); if (inNombre && (inNombre.value==='' || inNombre.value===inNombre.placeholder)) inNombre.value = p.nombre || '';
                            // El RUT no viene en este endpoint; se mantendrá vacío si no está cacheado
                        }catch(__e){}
                    }
                }
            }catch(_e){}
            // 2) Cargar resultado guardado y visualizarlo (rehidratar materiales)
            try{
                const r2 = await fetch(`/optimizador/exportar-salida/${encodeURIComponent(pid)}/`, { headers: {'X-Requested-With':'XMLHttpRequest'} });
                if (r2.ok){
                    const txt = await r2.text();
                    const resultado = JSON.parse(txt);
                    // Folio/ID
                    const fid = resultado.folio_proyecto || '';
                    try{ const f = document.getElementById('folioProyecto'); if (f && fid){ f.value = fid; }
                          const rf = document.getElementById('resFolio'); if (rf && fid){ rf.textContent = fid; } }catch(_e){}
                    // Configuración general por materiales (para rehidratar selects/dimensiones)
                    try{
                        const cfg = (resultado.configuracion || resultado.config || null);
                        const matsCfg = cfg && Array.isArray(cfg.materiales) ? cfg.materiales : null;
                        const matsRes = Array.isArray(resultado.materiales) ? resultado.materiales : (resultado.tableros ? [resultado] : []);
                        const totalMats = matsRes.length;
                        // Asegurar cantidad de pestañas
                        if (totalMats > 1){
                            while (contadorMateriales < totalMats){ agregarMaterial(); }
                        }
                        for (let i=0;i<totalMats;i++){
                            const idx = i+1;
                            const mcfg = matsCfg && matsCfg[i] ? (matsCfg[i].configuracion_material || matsCfg[i].config || null) : null;
                            const mRes = matsRes[i];
                            // Guardar estado por material (piezas y resultado backend)
                            try{
                                const entrada = Array.isArray(mRes.entrada) ? mRes.entrada : (Array.isArray(resultado.entrada)? resultado.entrada : []);
                                // Normalizar + agrupar por (nombre, dimensiones normalizadas, veta, tapacantos)
                                const normalizados = entrada.map(e=>{
                                    const an = parseInt(e.ancho||e.width||0,10);
                                    const al = parseInt((e.largo!=null? e.largo : (e.alto!=null? e.alto : e.height))||0,10);
                                    const v = !!e.veta_libre;
                                    const t = (typeof e.tapacantos==='object' && !Array.isArray(e.tapacantos)) ? e.tapacantos : {arriba:false,derecha:false,abajo:false,izquierda:false};
                                    return {
                                        cantidad: e.cantidad||1,
                                        nombre: (e.nombre||'').trim(),
                                        ancho: an,
                                        alto: al,
                                        veta_libre: v,
                                        tapacantos: t
                                    };
                                });
                                const agrupadasMap = new Map();
                                normalizados.forEach(it=>{
                                    const a = Math.min(it.ancho, it.alto);
                                    const b = Math.max(it.ancho, it.alto);
                                    const t = it.tapacantos||{};
                                    const kTap = `${t.arriba?1:0}${t.derecha?1:0}${t.abajo?1:0}${t.izquierda?1:0}`;
                                    const key = `${it.nombre}|${a}x${b}|v${it.veta_libre?1:0}|t${kTap}`;
                                    const prev = agrupadasMap.get(key);
                                    if (prev){ prev.cantidad += (it.cantidad||1); }
                                    else agrupadasMap.set(key, { ...it });
                                });
                                const piezas = Array.from(agrupadasMap.values());
                                materialState[idx] = materialState[idx] || {};
                                materialState[idx].piezas = piezas;
                                materialState[idx].resultado = mRes;
                                materialState[idx].configuracion_material = mcfg;
                            }catch(_e){}
                            // Aplicar configuración a cada pestaña
                            applyConfigToTab(idx);
                        }
                    }catch(_e){}
                    // Pintar primer material en pantalla si existe layout
                    const mats = Array.isArray(resultado.materiales) ? resultado.materiales : (resultado.tableros ? [resultado] : []);
                    if (mats.length){
                        const tb = construirVisualizacionDesdeBackend(mats[0]);
                        if (tb && tb.length){ document.getElementById('resultadosOptimizacion').style.display = 'block'; generarVisualizacion(tb); }
                        // Render piezas del primer material
                        const st = materialState[1]; if (st && st.piezas){ renderPiezasToDOM(st.piezas); }
                        // Re-evaluar bloqueo una vez renderizado
                        try { if (typeof actualizarBloqueoTabla === 'function') actualizarBloqueoTabla(); } catch(__e) {}
                    }
                }
            }catch(_e){}
        }catch(_e){}
    });

    // Permitir re-render manual: restaura y desbloquea visualización
    function restaurarLayout(){
        try{
            const contVis = document.getElementById('visualizacionTableros');
            if (contVis && contVis.dataset){ delete contVis.dataset.locked; }
            // Si tenemos en memoria el último layout de backend en materialState del tab activo, re-renderizar
            const activeTab = document.querySelector('#materialTabs button.nav-link.active');
            let materialIndex = 1;
            if (activeTab && activeTab.id){ const m = activeTab.id.match(/material(\d+)-tab/); if (m) materialIndex = parseInt(m[1],10); }
            const res = (materialState[materialIndex]||{}).resultado;
            if (res && Array.isArray(res.tableros)){
                const mRes = res;
                const mX = (mRes.margenes && typeof mRes.margenes.margen_x === 'number') ? mRes.margenes.margen_x : 0;
                const mY = (mRes.margenes && typeof mRes.margenes.margen_y === 'number') ? mRes.margenes.margen_y : 0;
                const margen = Math.max(mX, mY);
                const tablerosBackend = Array.isArray(mRes.tableros) ? mRes.tableros : [];
                // Numeración global por tipo para i/j al restaurar
                const _typeTotalsR = new Map();
                tablerosBackend.forEach(t=>{
                    (t.piezas||[]).forEach(p=>{
                        const a = parseInt(p.ancho||p.width||0,10); const l = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                        const k = `${(p.nombre||'').trim()}|${Math.min(a,l)}x${Math.max(a,l)}`;
                        _typeTotalsR.set(k, (_typeTotalsR.get(k)||0) + 1);
                    });
                });
                const _typeRunningR = new Map();
                const tb = tablerosBackend.map((t, idx)=>({
                    numero: (idx+1), ancho: (t.ancho || mRes.tablero_ancho_original || 0), alto: (t.largo || mRes.tablero_largo_original || 0),
                    margenOriginal: margen,
                    anchoUtil: Math.max(0, (t.ancho || mRes.tablero_ancho_original || 0) - 2*mX),
                    altoUtil: Math.max(0, (t.largo || mRes.tablero_largo_original || 0) - 2*mY),
                    kerf: (typeof mRes.desperdicio_sierra === 'number' ? mRes.desperdicio_sierra : (mRes.config && typeof mRes.config.kerf === 'number' ? mRes.config.kerf : 0)),
                    piezas: (Array.isArray(t.piezas)? t.piezas.map(p=>{
                        const aN = parseInt(p.ancho||p.width||0,10);
                        const lN = parseInt((p.largo!=null?p.largo:p.alto)||p.height||0,10);
                        const k = `${(p.nombre||'').trim()}|${Math.min(aN,lN)}x${Math.max(aN,lN)}`;
                        const run = (_typeRunningR.get(k)||0) + 1; _typeRunningR.set(k, run);
                        const tot = _typeTotalsR.get(k)||run;
                        const effW = Math.max(0, (t.ancho || mRes.tablero_ancho_original || 0) - 2*mX);
                        const effH = Math.max(0, (t.largo || mRes.tablero_largo_original || 0) - 2*mY);
                        const px = (p.x!=null? parseFloat(p.x) : 0);
                        const py = (p.y!=null? parseFloat(p.y) : 0);
                        // Normalización de coordenadas: si vienen absolutas (incluyen margen), restar margen; si no, dejarlas.
                        const candA = {x:px, y:py};
                        const candB = {x:px - mX, y:py - mY};
                        const fits = (c)=> c.x >= -1 && c.y >= -1 && (c.x + aN) <= effW + 1 && (c.y + lN) <= effH + 1;
                        const use = fits(candB) ? candB : (fits(candA) ? candA : candB);
                        return { nombre:p.nombre, x:use.x, y:use.y, ancho:aN, alto:lN, rotada:!!p.rotada, indiceUnidad:(p.indiceUnidad!=null? p.indiceUnidad : run), totalUnidades:(p.totalUnidades!=null? p.totalUnidades : tot), tapacantos:(typeof p.tapacantos==='object'?p.tapacantos:{arriba:false,derecha:false,abajo:false,izquierda:false}) };
                    }) : []),
                    getAprovechamiento(){ return (t.eficiencia_tablero!=null) ? t.eficiencia_tablero : (mRes.eficiencia||0); }
                }));
                window.__allowReRender = true; // habilitar re-render una vez
                generarVisualizacion(tb);
                window.__allowReRender = false;
            }
        }catch(e){ console.warn('No se pudo restaurar layout:', e); }
    }

    // Crear SVG para un tablero específico
    function crearSVGTablero(tablero) {
        const escala = 0.4; // Factor de escala más grande para mejor visualización
        const margenSVG = 80; // Margen para medidas alrededor del tablero
        const anchoSVG = (tablero.ancho * escala) + (margenSVG * 2);
        const altoSVG = (tablero.alto * escala) + (margenSVG * 2) + 60; // Espacio extra para información

        const div = document.createElement('div');
        div.className = 'mb-4 d-inline-block me-4';
        div.style.verticalAlign = 'top';
        
        // Información del tablero en la parte superior
        const infoDiv = document.createElement('div');
        infoDiv.className = 'text-center mb-3 small';
        
        // Generar información de cortes
        const secuenciaCortes = generarSecuenciaCortes(tablero);
        
        infoDiv.innerHTML = `
            <div class="fw-bold text-primary fs-6">Tablero ${tablero.numero}</div>
            <div class="text-muted">${tablero.getAprovechamiento().toFixed(1)}% aprovechamiento</div>
            <div class="text-success small mt-1">
                <i class="fas fa-maximize"></i> Optimizado para máximo aprovechamiento
            </div>
        `;
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', anchoSVG);
        svg.setAttribute('height', altoSVG);
        svg.setAttribute('viewBox', `0 0 ${anchoSVG} ${altoSVG}`);
        svg.style.border = '1px solid #ccc';
        svg.style.backgroundColor = '#ffffff';
        svg.style.display = 'block';

        // Calcular posición del tablero dentro del SVG
        const offsetX = margenSVG;
        const offsetY = margenSVG;
        const tableroSVGAncho = tablero.ancho * escala;
    const tableroSVGAlto = tablero.alto * escala;

    // Guardar datos de límites para modo manual (área útil)
    const mBound = tablero.margenOriginal * escala;
    svg.dataset.escala = escala;
    svg.dataset.offsetX = offsetX;
    svg.dataset.offsetY = offsetY;
    svg.dataset.margenOriginal = tablero.margenOriginal;
    svg.dataset.boundX = (offsetX + mBound);
    svg.dataset.boundY = (offsetY + mBound);
    svg.dataset.boundW = (tablero.anchoUtil * escala);
    svg.dataset.boundH = (tablero.altoUtil * escala);
    svg.dataset.kerfPx = String((tablero.kerf || 0) * escala);
    svg.dataset.tableroNum = String(tablero.numero||1);

    // Dibujar fondo del tablero
        const fondoTablero = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        fondoTablero.setAttribute('x', offsetX);
        fondoTablero.setAttribute('y', offsetY);
        fondoTablero.setAttribute('width', tableroSVGAncho);
        fondoTablero.setAttribute('height', tableroSVGAlto);
        fondoTablero.setAttribute('fill', '#f8f9fa');
        fondoTablero.setAttribute('stroke', '#666');
        fondoTablero.setAttribute('stroke-width', 2);
        svg.appendChild(fondoTablero);

        // Medidas del ancho (arriba y abajo)
    // Fondo para medida ancho arriba
    const medidaAnchoArriba = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        medidaAnchoArriba.setAttribute('x', offsetX + tableroSVGAncho / 2);
        medidaAnchoArriba.setAttribute('y', offsetY - 20);
        medidaAnchoArriba.setAttribute('text-anchor', 'middle');
        medidaAnchoArriba.setAttribute('font-family', 'Arial, sans-serif');
        medidaAnchoArriba.setAttribute('font-size', '14');
        medidaAnchoArriba.setAttribute('font-weight', 'bold');
        medidaAnchoArriba.setAttribute('fill', '#dc8b01');
        medidaAnchoArriba.textContent = `${tablero.ancho}mm`;
        svg.appendChild(medidaAnchoArriba);

        // Medida útil del ancho (con margen descontado)
        if (tablero.margenOriginal > 0) {
            const medidaAnchoUtil = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            medidaAnchoUtil.setAttribute('x', offsetX + tableroSVGAncho / 2);
            medidaAnchoUtil.setAttribute('y', offsetY - 5);
            medidaAnchoUtil.setAttribute('text-anchor', 'middle');
            medidaAnchoUtil.setAttribute('font-family', 'Arial, sans-serif');
            medidaAnchoUtil.setAttribute('font-size', '12');
            medidaAnchoUtil.setAttribute('fill', '#666');
            medidaAnchoUtil.textContent = `(${tablero.anchoUtil}mm útil)`;
            svg.appendChild(medidaAnchoUtil);
        }

        // Medidas del alto (izquierda y derecha)
    const medidaAltoIzq = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    medidaAltoIzq.setAttribute('x', offsetX - 10);
        medidaAltoIzq.setAttribute('y', offsetY + tableroSVGAlto / 2);
        medidaAltoIzq.setAttribute('text-anchor', 'end');
        medidaAltoIzq.setAttribute('dominant-baseline', 'middle');
        medidaAltoIzq.setAttribute('font-family', 'Arial, sans-serif');
        medidaAltoIzq.setAttribute('font-size', '14');
        medidaAltoIzq.setAttribute('font-weight', 'bold');
        medidaAltoIzq.setAttribute('fill', '#dc8b01');
        medidaAltoIzq.textContent = `${tablero.alto}mm`;
        svg.appendChild(medidaAltoIzq);

        // Medida útil del alto (con margen descontado)
        if (tablero.margenOriginal > 0) {
            const medidaAltoUtil = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            // Anclar al inicio y ubicar dentro del área visible del SVG para evitar recortes
            medidaAltoUtil.setAttribute('x', 8);
            medidaAltoUtil.setAttribute('y', offsetY + tableroSVGAlto / 2 + 18);
            medidaAltoUtil.setAttribute('text-anchor', 'start');
            medidaAltoUtil.setAttribute('dominant-baseline', 'middle');
            medidaAltoUtil.setAttribute('font-family', 'Arial, sans-serif');
            medidaAltoUtil.setAttribute('font-size', '12');
            medidaAltoUtil.setAttribute('fill', '#888');
            medidaAltoUtil.textContent = `(${tablero.altoUtil}mm útil)`;
            svg.appendChild(medidaAltoUtil);
        }

    // Definir patrón para áreas descartadas (margen fuera del área útil)
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
    pattern.setAttribute('id', 'discardPattern');
    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
    pattern.setAttribute('width', 8);
    pattern.setAttribute('height', 8);
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M0,0 L8,8 M8,0 L0,8');
    path.setAttribute('stroke', '#ffc107');
    path.setAttribute('stroke-width', '1');
    path.setAttribute('opacity', '0.7');
    pattern.appendChild(path);
    defs.appendChild(pattern);
    svg.appendChild(defs);

    // Dibujar área útil con borde AMARILLO punteado (ajustada al offset)
        const margenRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        margenRect.setAttribute('x', offsetX + (tablero.margenOriginal * escala));
        margenRect.setAttribute('y', offsetY + (tablero.margenOriginal * escala));
        margenRect.setAttribute('width', tablero.anchoUtil * escala);
        margenRect.setAttribute('height', tablero.altoUtil * escala);
    margenRect.setAttribute('fill', 'none');
    margenRect.setAttribute('stroke', '#ffc107');
    margenRect.setAttribute('stroke-width', '2');
    margenRect.setAttribute('stroke-dasharray', '6,3');
        svg.appendChild(margenRect);

    // Sombrear las áreas de margen como descartadas
    const m = tablero.margenOriginal * escala;
    const utilW = tablero.anchoUtil * escala;
    const utilH = tablero.altoUtil * escala;
    // Superior
    const topDiscard = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    topDiscard.setAttribute('x', offsetX);
    topDiscard.setAttribute('y', offsetY);
    topDiscard.setAttribute('width', tableroSVGAncho);
    topDiscard.setAttribute('height', m);
    topDiscard.setAttribute('fill', 'url(#discardPattern)');
    svg.appendChild(topDiscard);
    // Inferior
    const bottomDiscard = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bottomDiscard.setAttribute('x', offsetX);
    bottomDiscard.setAttribute('y', offsetY + m + utilH);
    bottomDiscard.setAttribute('width', tableroSVGAncho);
    bottomDiscard.setAttribute('height', m);
    bottomDiscard.setAttribute('fill', 'url(#discardPattern)');
    svg.appendChild(bottomDiscard);
    // Izquierda
    const leftDiscard = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    leftDiscard.setAttribute('x', offsetX);
    leftDiscard.setAttribute('y', offsetY + m);
    leftDiscard.setAttribute('width', m);
    leftDiscard.setAttribute('height', utilH);
    leftDiscard.setAttribute('fill', 'url(#discardPattern)');
    svg.appendChild(leftDiscard);
    // Derecha
    const rightDiscard = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rightDiscard.setAttribute('x', offsetX + m + utilW);
    rightDiscard.setAttribute('y', offsetY + m);
    rightDiscard.setAttribute('width', m);
    rightDiscard.setAttribute('height', utilH);
    rightDiscard.setAttribute('fill', 'url(#discardPattern)');
    svg.appendChild(rightDiscard);
        // Utilidades para modo manual y renderizado de piezas
        function rectsIntersect(a, b){
            return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
        }
        function groupRect(g){
            const baseX = parseFloat(g.dataset.x)||0;
            const baseY = parseFloat(g.dataset.y)||0;
            const tx = parseFloat(g.dataset.tx)||0;
            const ty = parseFloat(g.dataset.ty)||0;
            const w = parseFloat(g.dataset.w)||0;
            const h = parseFloat(g.dataset.h)||0;
            return { x: baseX + tx, y: baseY + ty, w, h };
        }
        function insideBounds(g){
            const r = groupRect(g);
            const bx = parseFloat(svg.dataset.boundX), by = parseFloat(svg.dataset.boundY);
            const bw = parseFloat(svg.dataset.boundW), bh = parseFloat(svg.dataset.boundH);
            return r.x >= bx && r.y >= by && (r.x + r.w) <= (bx + bw) && (r.y + r.h) <= (by + bh);
        }
        function hasCollision(g){
            const r = groupRect(g);
            const others = Array.from(svg.querySelectorAll('g.piece-group')).filter(o=>o!==g);
            return others.some(o=> rectsIntersect(r, groupRect(o)) );
        }
        // Calcular posición "snap" más cercana considerando kerf
    function snapPosition(rawX, rawY, w, h, kerfPx, selfG){
            const bx = parseFloat(svg.dataset.boundX), by = parseFloat(svg.dataset.boundY);
            const bw = parseFloat(svg.dataset.boundW), bh = parseFloat(svg.dataset.boundH);
            const threshold = Math.max(6, kerfPx); // umbral de atracción en px
            let x = rawX, y = rawY;
            // Snap a bordes del área útil
            if (Math.abs(rawX - bx) <= threshold) x = bx;
            if (Math.abs((rawX + w) - (bx + bw)) <= threshold) x = (bx + bw - w);
            if (Math.abs(rawY - by) <= threshold) y = by;
            if (Math.abs((rawY + h) - (by + bh)) <= threshold) y = (by + bh - h);
            // Snap a vecinos (lados) dejando separación kerf
            const groups = Array.from(svg.querySelectorAll('g.piece-group'));
            for (const o of groups){
                if (selfG && o === selfG) continue; // ignorar la pieza actual
                // evitar self
                // groupRect usa tx/ty actuales, por lo que reflejan la posición presente
                const gr = groupRect(o);
                // Comprobar solapamiento en eje perpendicular para activar snap
                const overlapY = !(rawY + h < gr.y || rawY > gr.y + gr.h);
                const overlapX = !(rawX + w < gr.x || rawX > gr.x + gr.w);
                // Snap horizontal izquierda de x al lado derecho del vecino + kerf (si hay solapamiento vertical)
                if (overlapY) {
                    const candX1 = gr.x + gr.w + kerfPx;
                    if (Math.abs(rawX - candX1) <= threshold) x = candX1;
                    // Snap horizontal derecha: borde derecho de pieza con borde izquierdo del vecino - kerf
                    const candX2 = gr.x - kerfPx - w;
                    if (Math.abs(rawX - candX2) <= threshold) x = candX2;
                }
                // Snap vertical (si hay solapamiento horizontal)
                if (overlapX) {
                    // Snap vertical arriba: y a abajo del vecino + kerf
                    const candY1 = gr.y + gr.h + kerfPx;
                    if (Math.abs(rawY - candY1) <= threshold) y = candY1;
                    // Snap vertical abajo: borde inferior de pieza a borde superior del vecino - kerf
                    const candY2 = gr.y - kerfPx - h;
                    if (Math.abs(rawY - candY2) <= threshold) y = candY2;
                }
            }
            // Limitar a bounds tras snap
            x = Math.max(bx, Math.min(bx + bw - w, x));
            y = Math.max(by, Math.min(by + bh - h, y));
            return {x, y};
        }
        function setValidity(g, valid){
            const rect = g.querySelector('rect');
            if (!rect) return;
            if (valid){
                rect.setAttribute('stroke', '#666');
                rect.removeAttribute('stroke-dasharray');
                g.setAttribute('opacity','1');
                g.dataset.invalid = '0';
            } else {
                rect.setAttribute('stroke', '#dc3545');
                rect.setAttribute('stroke-dasharray','4,2');
                g.setAttribute('opacity','0.55');
                g.dataset.invalid = '1';
            }
        }
        function updateValidity(g){
            const ok = insideBounds(g) && !hasCollision(g);
            setValidity(g, ok);
        }
        function limpiar(g){ while(g.firstChild) g.removeChild(g.firstChild); }
        // Mapeo de color estable por tipo de pieza
        const _colorIndexMap = new Map();
        const _tipoClave = (p)=> `${(p.nombre||'').trim()}|${Math.min(p.ancho,p.alto)}x${Math.max(p.ancho,p.alto)}`;
        function _getColorIndex(p){
            const k = _tipoClave(p);
            if(!_colorIndexMap.has(k)) _colorIndexMap.set(k, _colorIndexMap.size % colores.length);
            return _colorIndexMap.get(k);
        }

        function renderContenidoDePieza(g, pieza, x, y, w, h){
            // Rectángulo base
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', w);
            rect.setAttribute('height', h);
            // Color por tipo de pieza
            const idxColor = _getColorIndex(pieza);
            rect.setAttribute('fill', colores[idxColor]);
            rect.setAttribute('stroke', '#666');
            rect.setAttribute('stroke-width', '1.5');
            rect.setAttribute('rx', '3');
            rect.setAttribute('ry', '3');
            g.appendChild(rect);
            // Tapacantos
            dibujarTapacantosDentro(g, pieza, x, y, w, h);
            // Textos
            const relacionAspecto = h / (w||1);
            const esEstrechaVertical = (Math.min(w, h) < 26) || (relacionAspecto > 3.5);
            const nombreCompleto = pieza.totalUnidades > 1 ? `${pieza.nombre} (${pieza.indiceUnidad}/${pieza.totalUnidades})` : pieza.nombre;
            const nombreConRotacion = pieza.rotada ? `${nombreCompleto} ↻` : nombreCompleto;
            const tamNombre = Math.max(10, Math.min(18, Math.min(w/7, h/3)));
            const tamDim = Math.max(8, Math.min(14, Math.min(w/10, h/4)));
            const gText = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const cx = x + w/2, cy = y + h/2;
            if (esEstrechaVertical){ gText.setAttribute('transform', `rotate(-90 ${cx} ${cy})`); }
            const t1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t1.setAttribute('x', cx);
            t1.setAttribute('y', cy - (esEstrechaVertical ? 0 : 8));
            t1.setAttribute('text-anchor', 'middle');
            t1.setAttribute('dominant-baseline', 'middle');
            t1.setAttribute('font-family', 'Arial, sans-serif');
            t1.setAttribute('font-size', tamNombre);
            t1.setAttribute('font-weight', 'bold');
            t1.setAttribute('fill', '#333');
            t1.textContent = nombreConRotacion;
            gText.appendChild(t1);
            const t2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t2.setAttribute('x', cx);
            t2.setAttribute('y', cy + (esEstrechaVertical ? 10 : 8));
            t2.setAttribute('text-anchor', 'middle');
            t2.setAttribute('dominant-baseline', 'middle');
            t2.setAttribute('font-family', 'Arial, sans-serif');
            t2.setAttribute('font-size', tamDim);
            t2.setAttribute('fill', '#666');
            t2.textContent = `${pieza.ancho}×${pieza.alto}mm`;
            gText.appendChild(t2);
            g.appendChild(gText);
        }

        // Dibujar piezas con colores suaves y elegantes
        const colores = [
            '#F0F8FF', // Alice Blue - azul muy suave
            '#E6E6FA', // Lavender - lavanda suave
            '#F0FFF0', // Honeydew - verde muy suave
            '#FFFACD', // Lemon Chiffon - amarillo muy suave
            '#FFF0F5', // Lavender Blush - rosa muy suave
            '#F0FFFF', // Azure - cyan muy suave
            '#F5F5F5', // White Smoke - gris muy suave
            '#FDF5E6', // Old Lace - beige muy suave
            '#F8F8FF', // Ghost White - blanco azulado
            '#FAF0E6'  // Linen - lino suave
        ];
        
    tablero.piezas.forEach((pieza, index) => {
            // Posición ajustada con escala y offset
            const x = offsetX + (tablero.margenOriginal + pieza.x) * escala;
            const y = offsetY + (tablero.margenOriginal + pieza.y) * escala;
            const anchoEscalado = pieza.ancho * escala;
            const altoEscalado = pieza.alto * escala;
            
            // Grupo contenedor para habilitar arrastre y rotación opcional
            const gPiece = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gPiece.classList.add('piece-group');
            gPiece.dataset.index = index;
            gPiece.dataset.x = x; gPiece.dataset.y = y;
            gPiece.dataset.w = anchoEscalado; gPiece.dataset.h = altoEscalado;
            gPiece.dataset.tx = 0; gPiece.dataset.ty = 0;
            gPiece.dataset.canRotate = (pieza.vetaLibre || pieza.veta_libre || pieza.puedeRotar) ? '1' : '0';
            gPiece.dataset.rotada = pieza.rotada ? '1' : '0';
            if (modoManual) gPiece.style.cursor = 'move';
            // Render contenido inicial
            renderContenidoDePieza(gPiece, pieza, x, y, anchoEscalado, altoEscalado);
            // Asegurar estado visual válido por defecto (evitar transparencia)
            gPiece.removeAttribute('opacity');
            gPiece.dataset.invalid = '0';

            // Eventos de arrastre (solo en modo manual)
            gPiece.addEventListener('mousedown', (ev)=>{
                if (!modoManual) return;
                ev.preventDefault();
                dragState = { g: gPiece, startX: ev.clientX, startY: ev.clientY };
            });
            window.addEventListener('mousemove', (ev)=>{
                if (!modoManual || !dragState || dragState.g !== gPiece) return;
                const svgEl = gPiece.closest('svg');
                const boundX = parseFloat(svgEl.dataset.boundX);
                const boundY = parseFloat(svgEl.dataset.boundY);
                const boundW = parseFloat(svgEl.dataset.boundW);
                const boundH = parseFloat(svgEl.dataset.boundH);
                const kerfPx = parseFloat(svgEl.dataset.kerfPx)||0;
                const baseX = parseFloat(gPiece.dataset.x);
                const baseY = parseFloat(gPiece.dataset.y);
                const baseTX = parseFloat(gPiece.dataset.tx)||0;
                const baseTY = parseFloat(gPiece.dataset.ty)||0;
                const w = parseFloat(gPiece.dataset.w);
                const h = parseFloat(gPiece.dataset.h);
                let dx = (ev.clientX - dragState.startX);
                let dy = (ev.clientY - dragState.startY);
                let newX = baseX + baseTX + dx;
                let newY = baseY + baseTY + dy;
                // Limitar preliminarmente al área útil
                newX = Math.max(boundX, Math.min(boundX + boundW - w, newX));
                newY = Math.max(boundY, Math.min(boundY + boundH - h, newY));
                // Aplicar snapping considerando kerf y vecinos
                const snapped = snapPosition(newX, newY, w, h, kerfPx, gPiece);
                newX = snapped.x; newY = snapped.y;
                const tx = newX - baseX;
                const ty = newY - baseY;
                gPiece.setAttribute('transform', `translate(${tx},${ty})`);
                // Validación visual
                updateValidity(gPiece);
            });
            window.addEventListener('mouseup', ()=>{
                if (!modoManual || !dragState || dragState.g !== gPiece) return;
                const tr = gPiece.getAttribute('transform') || '';
                const m = tr.match(/translate\(([-\d\.]+),([ -\d\.]+)\)/);
                if (m){
                    gPiece.dataset.tx = parseFloat(m[1])||0;
                    gPiece.dataset.ty = parseFloat(m[2])||0;
                }
                dragState = null;
            });

            // Doble clic para rotar 90° (CW) usando como pivote el punto clicado
            gPiece.addEventListener('dblclick', (ev)=>{
                if (!modoManual) return;
                if (gPiece.dataset.canRotate !== '1'){ gPiece.style.cursor='not-allowed'; setTimeout(()=>{ gPiece.style.cursor = modoManual?'move':'default'; }, 300); return; }
                const svgEl = gPiece.closest('svg');
                // Convertir coordenadas del clic a coords del SVG
                let clickX = ev.clientX, clickY = ev.clientY;
                try {
                    const pt = svgEl.createSVGPoint();
                    pt.x = ev.clientX; pt.y = ev.clientY;
                    const ctm = svgEl.getScreenCTM().inverse();
                    const sp = pt.matrixTransform(ctm);
                    clickX = sp.x; clickY = sp.y;
                } catch(_e){}

                // Estado actual
                const w0 = parseFloat(gPiece.dataset.w), h0 = parseFloat(gPiece.dataset.h);
                const baseX = parseFloat(gPiece.dataset.x), baseY = parseFloat(gPiece.dataset.y);
                const tx0 = parseFloat(gPiece.dataset.tx)||0, ty0 = parseFloat(gPiece.dataset.ty)||0;
                const TLx = baseX + tx0, TLy = baseY + ty0; // top-left actual en SVG px
                // Coordenadas locales del clic dentro de la pieza
                const rx = clickX - TLx; // distancia desde TL actual al punto de clic (eje X)
                const ry = clickY - TLy; // distancia desde TL actual al punto de clic (eje Y)
                // Tras rotación 90° CW, el nuevo TL debe ser: TL' = pivot + Rcw(TL - pivot)
                // Como TL - pivot = (-rx, -ry)  => Rcw(-rx, -ry) = (-ry, rx)
                // Por lo tanto: TL' = (clickX - ry, clickY + rx)
                let TLx_new = clickX - ry;
                let TLy_new = clickY + rx;

                // Intercambiar dimensiones visuales (en píxeles)
                gPiece.dataset.w = String(h0);
                gPiece.dataset.h = String(w0);
                // Intercambiar ancho/alto reales de la pieza para el texto
                const tmp = pieza.ancho; pieza.ancho = pieza.alto; pieza.alto = tmp; pieza.rotada = !pieza.rotada;
                gPiece.dataset.rotada = pieza.rotada ? '1' : '0';
                // Re-renderizar
                limpiar(gPiece);
                renderContenidoDePieza(gPiece, pieza, baseX, baseY, parseFloat(gPiece.dataset.w), parseFloat(gPiece.dataset.h));
                // Ajustar translate para que el punto clicado quede fijo
                const txNew = TLx_new - baseX;
                const tyNew = TLy_new - baseY;
                gPiece.dataset.tx = String(txNew);
                gPiece.dataset.ty = String(tyNew);
                gPiece.setAttribute('transform', `translate(${txNew},${tyNew})`);
                updateValidity(gPiece);
            });

            svg.appendChild(gPiece);
            // Validación inicial
            updateValidity(gPiece);
        });

        // Dibujar líneas de corte CNC
        dibujarLineasCorte(svg, secuenciaCortes, tablero, offsetX, offsetY, escala);

        // Información adicional del tablero
        const infoExtra = document.createElement('div');
        infoExtra.className = 'text-center mt-2 small text-muted';
        infoExtra.innerHTML = `
            <div>Área útil: ${tablero.anchoUtil}×${tablero.altoUtil}mm</div>
            <div>Piezas colocadas: ${tablero.piezas.length}</div>
        `;
        
        div.appendChild(infoDiv);
        div.appendChild(svg);
        div.appendChild(infoExtra);
        return div;
    }

    // Guardado manual deshabilitado temporalmente
    async function guardarPosicionManual(){ return; }

    // Restaurar layout desde el resultado guardado en backend
    function restaurarLayout(){
        const idx = getActiveMaterialIndex();
        try{ renderDesdeResultadoGuardado(idx); }catch(e){ console.warn('No se pudo restaurar:', e); }
    }

    // Dibujar líneas de tapacanto DENTRO de la pieza
    function dibujarTapacantosDentro(svg, pieza, x, y, ancho, alto) {
        // Líneas de tapacanto más delgadas y sin texto del código
        const grosorLinea = 2;
        const margenInterno = 6; // Separación del borde de la pieza
        if (pieza.tapacantos.arriba) {
            const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            linea.setAttribute('x1', x + margenInterno);
            linea.setAttribute('y1', y + margenInterno);
            linea.setAttribute('x2', x + ancho - margenInterno);
            linea.setAttribute('y2', y + margenInterno);
            linea.setAttribute('stroke', '#dc3545');
            linea.setAttribute('stroke-width', grosorLinea);
            linea.setAttribute('stroke-dasharray', '8,4');
            svg.appendChild(linea);
        }
        if (pieza.tapacantos.derecha) {
            const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            linea.setAttribute('x1', x + ancho - margenInterno);
            linea.setAttribute('y1', y + margenInterno);
            linea.setAttribute('x2', x + ancho - margenInterno);
            linea.setAttribute('y2', y + alto - margenInterno);
            linea.setAttribute('stroke', '#dc3545');
            linea.setAttribute('stroke-width', grosorLinea);
            linea.setAttribute('stroke-dasharray', '8,4');
            svg.appendChild(linea);
        }
        if (pieza.tapacantos.abajo) {
            const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            linea.setAttribute('x1', x + margenInterno);
            linea.setAttribute('y1', y + alto - margenInterno);
            linea.setAttribute('x2', x + ancho - margenInterno);
            linea.setAttribute('y2', y + alto - margenInterno);
            linea.setAttribute('stroke', '#dc3545');
            linea.setAttribute('stroke-width', grosorLinea);
            linea.setAttribute('stroke-dasharray', '8,4');
            svg.appendChild(linea);
        }
        if (pieza.tapacantos.izquierda) {
            const linea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            linea.setAttribute('x1', x + margenInterno);
            linea.setAttribute('y1', y + margenInterno);
            linea.setAttribute('x2', x + margenInterno);
            linea.setAttribute('y2', y + alto - margenInterno);
            linea.setAttribute('stroke', '#dc3545');
            linea.setAttribute('stroke-width', grosorLinea);
            linea.setAttribute('stroke-dasharray', '8,4');
            svg.appendChild(linea);
        }
    }
</script>
{% if proyecto_precargado %}
{{ proyecto_precargado.resultado_optimizacion|default:"{}"|json_script:"proyResultado" }}
{{ {
        'id': proyecto_precargado.id,
        'nombre': proyecto_precargado.nombre,
        'cliente': proyecto_precargado.cliente.nombre if proyecto_precargado.cliente else '',
        'rut': proyecto_precargado.cliente.rut if proyecto_precargado.cliente else ''
}|json_script:"proyMeta" }}
<script>
// Hidratar optimizador desde proyecto precargado
(function(){
    function setIf(el, val){ if (el && val!=null && val!=='') el.value = val; }
    function ensureTabs(n){
        while (contadorMateriales < n){ agregarMaterial(); }
    }
    function selectOptionByDataCodigo(sel, codigo, fallbackByDim){
        if (!sel) return;
        let opt = null;
        if (codigo){
            opt = Array.from(sel.options).find(o=> (o.dataset && (o.dataset.codigo||o.dataset.code)) === String(codigo));
        }
        if (!opt && fallbackByDim && fallbackByDim.ancho && fallbackByDim.alto){
            const {ancho, alto} = fallbackByDim;
            opt = Array.from(sel.options).find(o=> Number(o.dataset?.ancho)===Number(ancho) && Number(o.dataset?.alto)===Number(alto));
        }
        if (!opt){
            opt = Array.from(sel.options).find(o=> o.value && o.value !== '');
        }
        if (opt) sel.value = opt.value;
    }
    // Adaptar resultado del backend a la estructura esperada por el visualizador
    function adaptarResultadoATableros(res){
        if (!res || !Array.isArray(res.tableros)) return [];
        const mX = (res.margenes && typeof res.margenes.margen_x === 'number') ? res.margenes.margen_x : 0;
        const mY = (res.margenes && typeof res.margenes.margen_y === 'number') ? res.margenes.margen_y : 0;
        const margen = Math.max(mX, mY);
        return res.tableros.map((t, idx)=>{
            // Crear objeto con interfaz mínima requerida por crearSVGTablero
            const tb = {
                numero: (idx+1),
                ancho: (t.ancho || (res.material && res.material.ancho_usado) || res.tablero_ancho_original || 0),
                alto: (t.largo || (res.material && res.material.largo_usado) || res.tablero_largo_original || 0),
                margenOriginal: margen,
                anchoUtil: Math.max(0, (t.ancho || (res.material && res.material.ancho_usado) || res.tablero_ancho_original || 0) - 2*mX),
                altoUtil: Math.max(0, (t.largo || (res.material && res.material.largo_usado) || res.tablero_largo_original || 0) - 2*mY),
                kerf: (typeof res.desperdicio_sierra === 'number' ? res.desperdicio_sierra : (res.config && typeof res.config.kerf === 'number' ? res.config.kerf : 0)),
                piezas: [],
                getAprovechamiento(){ return (t.eficiencia_tablero!=null) ? t.eficiencia_tablero : (res.eficiencia||0); }
            };
            // Mapear piezas
            const piezas = Array.isArray(t.piezas) ? t.piezas : [];
            tb.piezas = piezas.map(p=>({
                nombre: p.nombre,
                x: (p.x!=null? p.x : 0),
                y: (p.y!=null? p.y : 0),
                ancho: p.ancho,
                alto: (p.largo!=null? p.largo : p.alto),
                rotada: !!p.rotada,
                tapacantos: (typeof p.tapacantos === 'object' && !Array.isArray(p.tapacantos)) ? p.tapacantos : {arriba:false, derecha:false, abajo:false, izquierda:false}
            }));
            return tb;
        });
    }
    function calcularTapacantoTotalDesdeResultado(res){
        let total = 0; // mm
        if (!res || !Array.isArray(res.tableros)) return total;
        res.tableros.forEach(t=>{
            (t.piezas||[]).forEach(p=>{
                const tC = (typeof p.tapacantos === 'object' && !Array.isArray(p.tapacantos)) ? p.tapacantos : {};
                if (tC.arriba) total += p.ancho;
                if (tC.derecha) total += (p.largo!=null? p.largo : p.alto);
                if (tC.abajo) total += p.ancho;
                if (tC.izquierda) total += (p.largo!=null? p.largo : p.alto);
            });
        });
        return total;
    }
    function poblarResumenDesdeResultado(res){
        try{
            const totalTableros = (res.tableros||[]).length;
            const aprovech = (typeof res.eficiencia === 'number') ? res.eficiencia : (
                totalTableros ? (res.tableros.reduce((s,t)=> s + (t.eficiencia_tablero||0), 0)/totalTableros) : 0
            );
            // áreas vienen en m² según backend
            const areaTotalM2 = (typeof res.area_total === 'number') ? res.area_total : 0;
            const areaUsadaM2 = (typeof res.area_utilizada === 'number') ? res.area_utilizada : 0;
            const desperdicioM2 = Math.max(areaTotalM2 - areaUsadaM2, 0);
            const tapTotalMM = calcularTapacantoTotalDesdeResultado(res);

            document.getElementById('tablerosUsados').textContent = totalTableros;
            document.getElementById('aprovechamiento').textContent = `${aprovech.toFixed(1)}%`;
            document.getElementById('desperdicio').textContent = `${desperdicioM2.toFixed(3)} m²`;
            document.getElementById('tapacantos').textContent = `${(tapTotalMM/1000).toFixed(1)} m`;

            // Rellenar resumen compacto reutilizando los campos actuales
            const activeTab = document.querySelector('#materialTabs button.nav-link.active');
            const matIdx = (activeTab && activeTab.id && activeTab.id.match(/material(\d+)-tab/)) ? parseInt(activeTab.id.match(/material(\d+)-tab/)[1],10) : 1;
            const selMat = document.getElementById(`tableroSelect${matIdx}`);
            const optSel = selMat ? selMat.selectedOptions[0] : null;
            const ancho = parseFloat(document.getElementById(`ancho${matIdx}`)?.value||'0');
            const alto = parseFloat(document.getElementById(`alto${matIdx}`)?.value||'0');
            const margenX = parseFloat(document.getElementById(`margenX${matIdx}`)?.value||'0');
            const margenY = parseFloat(document.getElementById(`margenX${matIdx}`)?.value||'0');
            const kerf = parseFloat(document.getElementById(`desperdicioSierra${matIdx}`)?.value||'0');
            const nombreProyecto = document.getElementById('nombreProyecto')?.value || '';
            const cliente = document.getElementById('clienteInput')?.value || '';
            const rut = document.getElementById('rutCliente')?.value || '';
            const areaTableroM2 = (ancho*alto)/1_000_000;

            document.getElementById('resNombre').textContent = nombreProyecto || '(Sin nombre)';
            (function(){
                const f = document.getElementById('folioProyecto');
                if (f && f.value) { document.getElementById('resFolio').textContent = f.value; }
            })();
            document.getElementById('resCliente').textContent = cliente || '(Sin cliente)';
            document.getElementById('resClienteRut').textContent = rut ? `(${rut})` : '';
            document.getElementById('resMaterial').textContent = optSel ? (optSel.textContent||'Material') : 'Material';
            document.getElementById('resDim').textContent = `${ancho}×${alto} mm`;
            document.getElementById('resVetas').textContent = 'Libre según pieza';
            document.getElementById('resKerf').textContent = `${kerf} mm`;
            document.getElementById('resMargenes').textContent = `Margen: ${margenX} mm`;
            document.getElementById('resArea').textContent = `${(areaTableroM2*totalTableros).toFixed(2)} m² (${totalTableros} tableros)`;
            document.getElementById('resAprovech').textContent = `${aprovech.toFixed(1)}%`;
            const areaUtilM2 = ((ancho - 2*margenX) * (alto - 2*margenX))/1_000_000;
            const sobrantesM2 = Math.max((areaTableroM2*totalTableros) - (aprovech/100 * areaUtilM2 * totalTableros), 0);
            const resSob = document.getElementById('resSobrantes');
            if (resSob) resSob.textContent = `${sobrantesM2.toFixed(3)} m²`;
            // Tapacanto nombre (Código)
            (function(){
                const sel = document.getElementById(`tapacantoSelect${matIdx}`);
                if(sel && sel.selectedOptions && sel.selectedOptions[0]){
                    const opt = sel.selectedOptions[0];
                    const nombreCompleto = (opt.textContent||'');
                    const nombre = nombreCompleto.split(' (')[0];
                    const codigo = opt.dataset.codigo || '';
                    document.getElementById('resTapacanto').textContent = codigo ? `${nombre} (${codigo})` : nombre;
                } else {
                    document.getElementById('resTapacanto').textContent = '—';
                }
            })();
            const mlTxt = (tapTotalMM/1000);
            document.getElementById('resTapML').textContent = `${mlTxt.toFixed(2)} m`;
            document.getElementById('wrapResTapML').classList.toggle('d-none', mlTxt <= 0.0001);
            document.getElementById('resumenProyecto').style.display = 'block';
        }catch(e){ console.warn('No se pudo poblar resumen desde resultado:', e); }
    }
    // Derivar filas de piezas agregadas desde el resultado guardado
    function derivarPiezasDesdeResultado(res){
        const agg = new Map();
        (res.tableros||[]).forEach(t=>{
            (t.piezas||[]).forEach(p=>{
                const ancho = p.ancho;
                const alto = (p.largo!=null? p.largo : p.alto);
                const tC = (typeof p.tapacantos === 'object' && !Array.isArray(p.tapacantos)) ? p.tapacantos : {arriba:false, derecha:false, abajo:false, izquierda:false};
                const key = JSON.stringify({n:p.nombre, a:ancho, h:alto, tc:tC});
                const cur = agg.get(key) || {cantidad:0, nombre:p.nombre, ancho:ancho, alto:alto, veta_libre:false, tapacantos:tC};
                cur.cantidad += 1;
                agg.set(key, cur);
            });
        });
        return Array.from(agg.values());
    }
    function renderDesdeResultadoGuardado(matIndex){
        const st = materialState[matIndex];
        if (!st || !st.resultado) return;
        const tableros = adaptarResultadoATableros(st.resultado);
        if (tableros.length){
            try{ generarVisualizacion(tableros); }catch(e){ console.warn('No se pudo generar visualización desde resultado:', e); }
            const cont = document.getElementById('resultadosOptimizacion');
            if (cont) cont.style.display = 'block';
            poblarResumenDesdeResultado(st.resultado);
        }
        // Si no hay piezas en estado, intentar usar entrada original; si no existe, derivarlas
        if (!st.piezas || !st.piezas.length){
            const entrada = Array.isArray(st.resultado.entrada) ? st.resultado.entrada : null;
            if (entrada){
                // Mapear a formato de filas esperado por renderPiezasToDOM
                st.piezas = entrada.map(e=>({
                    cantidad: e.cantidad ?? 1,
                    nombre: e.nombre || '',
                    ancho: e.ancho,
                    alto: e.largo ?? e.alto,
                    veta_libre: !!e.veta_libre,
                    tapacantos: (typeof e.tapacantos==='object' && !Array.isArray(e.tapacantos)) ? e.tapacantos : {arriba:false,derecha:false,abajo:false,izquierda:false}
                }));
            } else {
                st.piezas = derivarPiezasDesdeResultado(st.resultado);
            }
            if (getActiveMaterialIndex() === matIndex){
                renderPiezasToDOM(st.piezas);
            }
        }
    }
    document.addEventListener('DOMContentLoaded', ()=>{
        try{
            const metaEl = document.getElementById('proyMeta');
            const resEl = document.getElementById('proyResultado');
            const meta = metaEl ? JSON.parse(metaEl.textContent) : null;
            const resultado = resEl ? JSON.parse(resEl.textContent||'{}') : null;
            if (!meta) return;
            // Setear proyecto id en resultados
            const resDiv = document.getElementById('resultadosOptimizacion');
            if (resDiv) resDiv.setAttribute('data-proyecto-id', meta.id);
            // Setear encabezado proyecto/cliente
            setIf(document.getElementById('nombreProyecto'), meta.nombre||'');
            setIf(document.getElementById('clienteInput'), meta.cliente||'');
            setIf(document.getElementById('rutCliente'), meta.rut||'');
            if (meta.rut) { const rut = document.getElementById('rutCliente'); if(rut) rut.disabled = true; }
            // Materiales
            const materiales = (resultado && resultado.materiales) ? resultado.materiales : (resultado? [resultado] : []);
            if (!materiales.length) return;
            ensureTabs(materiales.length);
            materiales.forEach((m, idx)=>{
                const i = idx+1;
                // Dimensiones y márgenes
                setIf(document.getElementById(`ancho${i}`), m.tablero_ancho_usado || m.tablero_ancho_original || '');
                setIf(document.getElementById(`alto${i}`), m.tablero_largo_usado || m.tablero_largo_original || '');
                const mx = (m.margenes && (m.margenes.margen_x!=null)) ? m.margenes.margen_x : '';
                const my = (m.margenes && (m.margenes.margen_y!=null)) ? m.margenes.margen_y : '';
                setIf(document.getElementById(`margenX${i}`), mx);
                setIf(document.getElementById(`margenY${i}`), my);
                setIf(document.getElementById(`desperdicioSierra${i}`), m.desperdicio_sierra|| (m.config && m.config.kerf));
                // Material (si viene el código del material)
                try{
                    const selMat = document.getElementById(`tableroSelect${i}`);
                    const codMat = (m.material && (m.material.codigo||m.material.code)) || m.material_codigo || '';
                    const dims = {ancho: (m.tablero_ancho_usado||m.tablero_ancho_original), alto: (m.tablero_largo_usado||m.tablero_largo_original)};
                    selectOptionByDataCodigo(selMat, codMat, dims);
                }catch(_e){}
                // Tapacanto
                const tap = m.tapacanto || resultado.tapacanto || {};
                selectOptionByDataCodigo(document.getElementById(`tapacantoSelect${i}`), tap.codigo||'');
                // Guardar resultado base en materialState para posible reuso
                materialState[i] = materialState[i]||{};
                materialState[i].resultado = m;
                // Pre-derivar piezas agregadas
                try{ materialState[i].piezas = derivarPiezasDesdeResultado(m); }catch(e){}
            });
            // Render inicial del material activo desde resultado guardado
            const activo = getActiveMaterialIndex();
            renderDesdeResultadoGuardado(activo);
        }catch(err){ console.warn('No se pudo hidratar proyecto:', err); }
    });
    // Al cambiar de pestaña, si hay resultado guardado para esa pestaña, renderizarlo sin requerir optimización
    document.addEventListener('DOMContentLoaded', ()=>{
        const tabs = document.querySelectorAll('#materialTabs button.nav-link');
        tabs.forEach(btn=>{
            btn.addEventListener('shown.bs.tab', ()=>{
                const idx = getActiveMaterialIndex();
                // animación de salida rápida
                try { document.getElementById('visualizacionTableros').classList.remove('show'); } catch(_e){}
                renderDesdeResultadoGuardado(idx);
                // Recalcular estado de botones de tapacanto en la pestaña activa
                try {
                    const evt = new Event('change');
                    const selTap = document.getElementById(`tapacantoSelect${idx}`);
                    const selTab = document.getElementById(`tableroSelect${idx}`);
                    if (selTap) selTap.dispatchEvent(evt);
                    if (selTab) selTab.dispatchEvent(evt);
                } catch(_e){}
            });
        });
    });
})();
</script>
{% endif %}
<style>
.is-invalid { border-color:#dc3545 !important; }
</style>

<style>
    /* Estilos para botones de tapacanto */
    .btn-tapacanto {
        width: 24px;
        height: 24px;
        border: none;
        background-color: transparent;
        color: var(--text-secondary-light);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 18px;
        margin: 1px;
    }
    
    /* Botón para todos los lados */
    .btn-tapacanto.btn-all {
        background-color: var(--bs-dark) !important;
        color: white !important;
        border: 1px solid var(--bs-dark) !important;
    }
    
    .btn-tapacanto.btn-all:hover {
        background-color: var(--bs-secondary) !important;
        border-color: var(--bs-secondary) !important;
    }
    
    .btn-tapacanto.btn-all.active {
        background-color: var(--bs-warning) !important;
        color: var(--bs-dark) !important;
        border-color: var(--bs-warning) !important;
        transform: scale(1.1);
    }
    
    /* Botones direccionales */
    .btn-tapacanto.btn-direction.active {
        color: var(--primary-700);
        transform: scale(1.1);
        text-shadow: 0 0 3px var(--primary-600);
    }
    
    .btn-tapacanto:hover {
        transform: scale(1.2);
        color: var(--primary-600);
    }
    
    .btn-tapacanto.btn-all:hover {
        color: var(--warning-600);
        transform: scale(1.2);
    }
    
    .btn-tapacanto.btn-direction:hover {
        color: var(--primary-600);
        transform: scale(1.2);
    }
    
    /* Layout de botones de tapacanto en línea horizontal */
    .tapacanto-controls {
        display: flex;
        gap: 2px;
        justify-content: center;
        align-items: center;
        width: 100%;
    }
    
    /* Estilo para botón de eliminar */
    .btn-delete {
        width: 24px;
        height: 24px;
        border: none;
        background-color: transparent;
        color: var(--danger-600);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 18px;
    }
    
    .btn-delete:hover {
        color: var(--danger-700);
        transform: scale(1.2);
        text-shadow: 0 0 3px var(--danger-600);
    }
    
    /* Estilo para toda el área de agregar (clickeable) */
    .table-add-row {
        background-color: #f8f9fa;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
    }
    
    .table-add-row:hover {
        background-color: #e9ecef;
    }
    
    .table-add-row:active {
        background-color: #dee2e6;
    }
    
    .add-row-hover td {
        padding: 12px 8px;
        border: none;
        vertical-align: middle;
    }
    
    .add-row-hover .text-muted {
        font-style: italic;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .table-add-row:hover .text-muted {
        opacity: 1;
        color: #495057;
    }
    
    /* Forzar anchos específicos de columnas */
    .table th:nth-child(1), .table td:nth-child(1) { width: 50px !important; max-width: 50px !important; min-width: 50px !important; text-align: center !important; }
    .table th:nth-child(2), .table td:nth-child(2) { width: 110px !important; max-width: 110px !important; min-width: 110px !important; text-align: center !important; }
    .table th:nth-child(3), .table td:nth-child(3) { min-width: 150px !important; }
    .table th:nth-child(4), .table td:nth-child(4) { width: 120px !important; max-width: 120px !important; min-width: 120px !important; text-align: center !important; }
    .table th:nth-child(5), .table td:nth-child(5) { width: 120px !important; max-width: 120px !important; min-width: 120px !important; text-align: center !important; }
    .table th:nth-child(6), .table td:nth-child(6) { width: 50px !important; max-width: 50px !important; min-width: 50px !important; text-align: center !important; }
    .table th:nth-child(7), .table td:nth-child(7) { width: 180px !important; max-width: 180px !important; min-width: 180px !important; text-align: center !important; }
    .table th:nth-child(8), .table td:nth-child(8) { width: 50px !important; max-width: 50px !important; min-width: 50px !important; text-align: center !important; }

    /* Estilos para inputs de columnas numéricas */
    .table td:nth-child(2) input, /* Cantidad */
    .table td:nth-child(4) input, /* Ancho */
    .table td:nth-child(5) input  /* Alto */ {
        text-align: center;
        font-weight: 500;
        width: 100% !important;
        box-sizing: border-box;
        padding: 4px 2px !important;
        font-size: 13px;
    }
    
    /* Input de pieza */
    .table td:nth-child(3) input { /* Pieza */
        width: 100%;
        padding: 4px 8px !important;
        font-size: 13px;
    }
    
    /* Mejorar aspecto de las pestañas */
    .nav-tabs .nav-link {
        border-radius: 8px 8px 0 0;
    }
    
    .nav-tabs .nav-link.active {
        background-color: var(--white);
        border-bottom-color: var(--white);
    }
    
    /* Estilo para campos en edición */
    .border-warning {
        border-color: var(--warning-main) !important;
        box-shadow: 0 0 0 0.2rem var(--warning-focus);
    }
    
    /* Mejorar la tabla */
    .table {
        table-layout: fixed !important;
        width: 100% !important;
    }

    .table th {
        background-color: var(--bg-color);
        border-color: var(--border-color);
        font-weight: 600;
        font-size: 12px;
        padding: 8px 4px !important;
        white-space: nowrap;
    }
    
    .table td {
        border-color: var(--border-color);
        vertical-align: middle;
        padding: 6px 4px !important;
    }
    
    .table-hover tbody tr:hover {
        background-color: var(--primary-50);
    }
    
    /* Botones pequeños */
    .btn-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    /* Mejorar inputs pequeños */
    .form-control-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    /* Mejorar el aspecto de los campos deshabilitados */
    .form-control:disabled,
    .form-select:disabled {
        background-color: var(--bg-color);
        opacity: 0.7;
    }
    
    /* Estilos para el datalist de clientes */
    #clienteInput {
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m1 1 6 6-6 6'/%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.75rem center;
        background-size: 16px 12px;
    }
    
    /* Estilo para destacar la opción "Nuevo Cliente" */
    option[value="[NUEVO CLIENTE]"] {
        font-weight: bold;
        color: var(--success-main);
    }
</style>
<style>
@keyframes shakeX { 10%, 90% { transform: translateX(-1px); } 20%, 80% { transform: translateX(2px); } 30%, 50%, 70% { transform: translateX(-4px);} 40%, 60% { transform: translateX(4px);} }
.shake { animation: shakeX 0.4s ease; }
</style>
{% endblock %}