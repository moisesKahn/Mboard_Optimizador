{% load static %}
<!DOCTYPE html>
<html lang="es" data-theme="light">
  {% include "partials/head.html" %}
  <!-- Fuerza seteo de cookie CSRF y expone token vía meta -->
  <meta name="csrf-token" content="{{ csrf_token }}" />
  <style>
    html, body { height: 100%; }
    body { overflow: hidden; }
    .op-wrapper { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr 360px; grid-template-rows: auto 1fr; grid-template-areas: 'toolbar toolbar' 'canvas sidebar'; }
    .op-toolbar { grid-area: toolbar; display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #fff; border-bottom: 1px solid #eee; }
    .op-canvas { grid-area: canvas; position: relative; background: #fafafa; }
    .op-sidebar { grid-area: sidebar; display: flex; flex-direction: column; border-left: 1px solid #eee; background: #fff; }
    .op-stats { padding: 10px 12px; border-bottom: 1px solid #eee; }
    .op-list { padding: 0 12px 12px 12px; overflow: auto; }
    .op-btn { border: 1px solid #ddd; background: #fff; border-radius: 6px; padding: 6px 10px; }
    .op-btn:active { transform: translateY(1px); }
    .chip { display:inline-block; padding:2px 8px; border-radius:10px; font-size:12px; margin-right:6px; background:#f1f3f5; }
    .piece-highlight rect { filter: drop-shadow(0 0 0.5px rgba(0,0,0,.4)); stroke-width: 2; }
    .list-highlight { background: #fffbe6; }
    .piece-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index: 20; }
    .piece-modal { background: #fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.3); width: min(90vw, 760px); max-width: 760px; }
    .piece-modal .hdr { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; border-bottom: 1px solid #eee; }
    .piece-modal .cnt { padding: 10px; }
    .piece-modal .btn-close { border:none; background:transparent; font-size:22px; line-height:1; cursor:pointer; }
    /* Ocultar/mostrar sidebar */
    .op-wrapper.sidebar-hidden { grid-template-columns: 1fr 0; }
    .op-wrapper.sidebar-hidden .op-sidebar { display: none; }
    /* Transición suave de color en piezas para sensación de fluidez */
    g[data-pieza] rect { transition: fill .15s ease, fill-opacity .15s ease; }
  </style>
  <body>
    <div class="op-wrapper">
      <div class="op-toolbar">
        <a href="{% url 'operador_home' %}" class="op-btn">← Volver</a>
        <div class="vr mx-2"></div>
  <strong>{{ proyecto.public_id|default:proyecto.id }}</strong>
  <span>· {{ proyecto.nombre }}</span>
        <div class="vr mx-2"></div>
    <label class="me-1 small text-muted">Tablero</label>
    <select id="selTablero" class="form-select form-select-sm" style="width:auto;"></select>
    <div class="vr mx-2"></div>
    <!-- Controles de zoom: [-] [porcentaje] [+] -->
    <button id="btnZoomOut" class="op-btn" type="button" title="Alejar">-</button>
    <span id="zoomPct" class="chip" title="Nivel de zoom">100%</span>
    <button id="btnZoomIn" class="op-btn" type="button" title="Acercar">+</button>
    <!-- Botón cuadrar: restablecer vista al inicio, centrado y tablero completo -->
  <button id="btnZoomReset" class="op-btn" type="button" title="Ajustar vista (centrar y refrescar visualizador)">Ajustar vista</button>
    <div class="vr mx-2"></div>
    <!-- Acciones del operador -->
    <button id="btnMarcarTodas" class="op-btn" type="button" title="Marcar todas las piezas como cortadas">Marcar todas cortadas</button>
    <button id="btnCompletar" class="op-btn" type="button" title="Completar proyecto y volver a la lista" style="display:none;">Completar proyecto</button>
    <button id="btnToggleSidebar" class="op-btn ms-auto" type="button" title="Ocultar/mostrar panel">Panel ▸</button>
  <div class="small text-muted ms-2">Atajos: + / - / 0 · ← → cambia tablero</div>
      </div>
      <div class="op-canvas" id="canvasHost">
        <div class="w-100 h-100 d-flex align-items-center justify-content-center text-muted">Cargando diseño…</div>
      </div>
      <div class="op-sidebar">
        <div class="op-stats small" id="statsBox">
          <div><strong>Material:</strong> <span id="stMaterial">—</span></div>
          <div><strong>Tablero:</strong> <span id="stSize">—</span> · <span id="stEff">—</span> de aprovechamiento</div>
          <div><strong>Útil (márgenes):</strong> <span id="stUtil">—</span> (<span id="stMargins">mx=?, my=?</span>)</div>
          <div><strong>Piezas:</strong> <span id="stPieces">—</span> · <strong>Cortes:</strong> V:<span id="stCutV">0</span> H:<span id="stCutH">0</span></div>
          <div><strong>Tapacanto ML:</strong> <span id="stML">—</span></div>
        </div>
        <div class="op-list" id="listaPiezas"></div>
      </div>
    </div>

    <script>
    (async function(){
      const proyectoId = parseInt('{{ proyecto.id }}', 10);
      const host = document.getElementById('canvasHost');
      const selTab = document.getElementById('selTablero');
      const list = document.getElementById('listaPiezas');
      const stMaterial = document.getElementById('stMaterial');
      const stSize = document.getElementById('stSize');
      const stEff = document.getElementById('stEff');
      const stUtil = document.getElementById('stUtil');
      const stMargins = document.getElementById('stMargins');
      const stPieces = document.getElementById('stPieces');
      const stCutV = document.getElementById('stCutV');
      const stCutH = document.getElementById('stCutH');
      const stML = document.getElementById('stML');

      function getCookie(name){
        const v = document.cookie.split('; ').find(r=>r.startsWith(name+'='));
        return v ? decodeURIComponent(v.split('=')[1]) : '';
      }
      function getCsrf(){
        return getCookie('csrftoken') || (document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '');
      }

  const resp = await fetch(`/api/operador/proyectos/${proyectoId}`, {credentials:'same-origin'});
      if(!resp.ok){ host.innerHTML = '<div class="w-100 h-100 d-flex align-items-center justify-content-center text-danger">No hay resultado.</div>'; return; }
      const data = await resp.json();
      const tableros = data.tableros||[];
      const meta = data.meta||{};
  const proyectoMeta = data.proyecto||{};

      stMaterial.textContent = meta.material || '—';
      selTab.innerHTML = tableros.map((t,i)=>`<option value="${i}">Tablero ${t.num}</option>`).join('');
      let idx = 0;

      // SVG setup
      host.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width','100%'); svg.setAttribute('height','100%');
  // Cursor: por defecto, según zoom
  svg.style.cursor = 'default';
  // Evitar gestos de pinch nativos que hagan zoom del viewport del navegador en móviles
  svg.setAttribute('touch-action','none');
  // Margen superior deseado en modo ajuste: responsivo al alto del host (6% del alto), con límites
  const FIT_PAD_MIN = 32, FIT_PAD_MAX = 80;
  // Escala tipográfica global del visor (85% de la actual)
  const FONT_SCALE = 0.85;
  function fs(px){ return String(Math.round(px*FONT_SCALE)); }
  // Permitir alejar por debajo del FIT hasta el 50%
  const MIN_ZOOM_FACTOR = 0.5; // 50% de la escala base
  function getFitPad(){
    const r = host.getBoundingClientRect();
    const h = (r && r.height) ? r.height : vbSize().h;
    const pad = Math.round(h * 0.06); // 6% del alto
    return Math.max(FIT_PAD_MIN, Math.min(FIT_PAD_MAX, pad));
  }
  const ALWAYS_CENTER = false; // permitir movimiento libre de la cámara por arrastre
  function setViewBoxToHost(){
    // Usar medidas reales del host; si está minimizado/oculto, no tocar el viewBox
    const w0 = host.clientWidth || host.getBoundingClientRect().width;
    const h0 = host.clientHeight || host.getBoundingClientRect().height;
    if(!w0 || !h0 || w0 < 10 || h0 < 10){
      return false; // no modificar mientras no haya tamaño válido
    }
    const w = Math.floor(w0);
    const h = Math.floor(h0);
    svg.setAttribute('viewBox',`0 0 ${w} ${h}`);
    return true;
  }
  setViewBoxToHost();
      const g = document.createElementNS(svgNS, 'g');
      svg.appendChild(g); host.appendChild(svg);
  let scale = 1, baseScale = 1, dx = 0, dy = 0; let dragging=false, lx=0, ly=0;
  // Animación de cámara
  let animFrame = 0;
  // Soporte pinch-to-zoom
  let pinch = {active:false, d0:0, s0:1, cx:0, cy:0};
  // Forzar centrado exacto en el siguiente apply (usado tras cambios de tamaño)
  let forceCenterNext = false;
  // Bounds del TABLERO (no de todo el <g>), para centrar/clamp sin considerar textos externos
  let boardBounds = {x:0,y:0,width:1,height:1};
  // BBox completo del grupo (incluye textos y cortes)
  let contentBounds = {x:0,y:0,width:1,height:1};
  // BBox a usar para el ajuste (fit) y centrado visual: incluye etiquetas externas
  let fitBounds = {x:0,y:0,width:1,height:1};
  // Consideramos "base" cualquier valor <= baseScale (con pequeña tolerancia)
  function atBaseZoom(){ return baseScale>0 ? (scale <= baseScale * (1+1e-3)) : (scale <= baseScale); }
  function vbSize(){ const vb=(svg.getAttribute('viewBox')||'0 0 100 100').split(/\s+/); return {w: parseFloat(vb[2]||'100'), h: parseFloat(vb[3]||'100')}; }
      function updateCursor(){
        if(dragging) { svg.style.cursor = 'grabbing'; return; }
        svg.style.cursor = atBaseZoom() ? 'default' : 'grab';
      }
  function zoomPercent(){ return Math.round((scale/baseScale)*100); }
  function updateZoomUI(){ const sp = document.getElementById('zoomPct'); if(sp){ sp.textContent = `${zoomPercent()}%`; } }
      function ensureBoardInView(){
        // Solo garantizamos vista completa cuando estamos en el zoom base (fit).
        if(!atBaseZoom()) return;
        const {w:vw, h:vh} = vbSize();
        const bx = dx + boardBounds.x*scale;
        const by = dy + boardBounds.y*scale;
        const bw = boardBounds.width*scale;
        const bh = boardBounds.height*scale;
        const padTol = 2; // tolerancia mínima de borde
        const out = (bx < -padTol) || (by < -padTol) || (bx + bw > vw + padTol) || (by + bh > vh + padTol);
        if(out){
          const pad = getFitPad();
          dx = (vw - boardBounds.width*scale)/2 - boardBounds.x*scale;
          dy = pad - boardBounds.y*scale;
        }
      }
      function clamp(board){
        const {w:vw, h:vh} = vbSize();
        // Límites de pan del TABLERO (para no salirnos del área útil)
        const bxB = boardBounds.x, byB = boardBounds.y, bwB = boardBounds.width, bhB = boardBounds.height;
        const dxMin = vw - (bxB + bwB) * scale;
        const dxMax = -bxB * scale;
        const dyMin = vh - (byB + bhB) * scale;
        const dyMax = -byB * scale;
        // ¿Forzamos centrado puntual? (por resize/reset)
        const atBase = atBaseZoom();
        if(forceCenterNext || atBase){
          // Centrar horizontalmente y fijar margen superior mínimo
          const bw = boardBounds.width;
          const pad = getFitPad();
          dx = (vw - bw*scale)/2 - boardBounds.x*scale;
          dy = pad - boardBounds.y*scale;
          if(forceCenterNext) forceCenterNext = false;
        } else {
          dx = Math.max(dxMin, Math.min(dxMax, dx));
          dy = Math.max(dyMin, Math.min(dyMax, dy));
        }
      }
      function apply(board){
        clamp(board||{});
        if(!isFinite(scale) || scale <= 0) scale = 1;
        ensureBoardInView();
        g.setAttribute('transform', `translate(${dx},${dy}) scale(${scale})`);
        updateCursor();
        updateZoomUI();
      }

      function stateColor(st){
        // Colores requeridos: cortada verde vivo, pendiente gris; otros estados mantienen diferenciación
        return st==='cortada' ? '#28A745' : st==='pendiente' ? '#6C757D' : st==='en_corte' ? '#0D6EFD' : st==='descartada' ? '#DC3545' : '#6C757D';
      }

      function mlTapacanto(board){
        let mm = 0; for(const p of (board.piezas||[])){
          const tc = p.tapacantos||{};
          if(tc.arriba) mm += (p.ancho||0);
          if(tc.abajo) mm += (p.ancho||0);
          if(tc.derecha) mm += (p.largo||0);
          if(tc.izquierda) mm += (p.largo||0);
        }
        return (mm/1000).toFixed(2) + ' m';
      }

      function tapsLabel(tc){
        if(!tc) return '—';
        const parts = [];
        if(tc.arriba) parts.push('A');
        if(tc.derecha) parts.push('D');
        if(tc.abajo) parts.push('B');
        if(tc.izquierda) parts.push('I');
        return parts.length? parts.join(',') : '—';
      }

      function inferCutLines(board){
        const xs = new Set(), ys = new Set();
        for(const p of (board.piezas||[])){
          const x1 = (p.x||0), x2=(p.x||0)+(p.ancho||0);
          const y1 = (p.y||0), y2=(p.y||0)+(p.largo||0);
          xs.add(x1); xs.add(x2); ys.add(y1); ys.add(y2);
        }
        const v = Array.from(xs).sort((a,b)=>a-b); const h = Array.from(ys).sort((a,b)=>a-b);
        return {v:harden(v), h:harden(h)};
        function harden(arr){ const out=[]; let prev=null; const EPS=0.01; for(const x of arr){ if(prev===null || Math.abs(x-prev)>EPS){ out.push(x); prev=x; } } return out; }
      }

      function recalcBase(board){
        const PAD=48; const {w:vw, h:vh} = vbSize();
        // Recalcular bbox completo para referencia, pero el ajuste base usa SOLO el tablero
        contentBounds = g.getBBox();
        fitBounds = contentBounds;
        const bw = Math.max(1, boardBounds.width || (board.ancho_mm||1));
        const bh = Math.max(1, boardBounds.height || (board.largo_mm||1));
        const availW = Math.max(50, vw - PAD*2);
        const availH = Math.max(50, vh - PAD*2);
        baseScale = Math.min(availW/bw, availH/bh);
        if(!isFinite(baseScale) || baseScale <= 0) baseScale = 0.01; // fallback seguro
      }
      function recenter(board, keepScale=true){
        recalcBase(board);
        if(!keepScale) scale = baseScale; else scale = Math.max(scale, baseScale);
        const {w:vw, h:vh} = vbSize();
        // Centrar horizontalmente y mantener un margen superior mínimo
  const bw = boardBounds.width;
  const pad = getFitPad();
  dx = (vw - bw*scale)/2 - boardBounds.x*scale;
  dy = pad - boardBounds.y*scale;
        apply(board);
      }
      function fit(board){ recenter(board, false); }

          function computeFitTransform(board){
            // Calcula transform objetivo para fit sin aplicarlo inmediatamente
            recalcBase(board);
            const sc = baseScale;
            const {w:vw, h:vh} = vbSize();
            const bw = boardBounds.width;
            const pad = getFitPad();
            const tx = (vw - bw*sc)/2 - boardBounds.x*sc;
            const ty = pad - boardBounds.y*sc;
            return {scale: sc, dx: tx, dy: ty};
          }

          function animateTo(board, target, ms=180){
            if(animFrame) cancelAnimationFrame(animFrame);
            const s0 = scale, x0 = dx, y0 = dy;
            const s1 = target.scale, x1 = target.dx, y1 = target.dy;
            const t0 = performance.now();
            const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3);
            function step(t){
              const p = Math.min(1, (t - t0) / ms);
              const e = easeOutCubic(p);
              scale = s0 + (s1 - s0) * e;
              dx = x0 + (x1 - x0) * e;
              dy = y0 + (y1 - y0) * e;
              apply(board);
              if(p < 1) animFrame = requestAnimationFrame(step);
            }
            animFrame = requestAnimationFrame(step);
          }

          // Preserva el punto central del contenido y el nivel de zoom relativo
          // al cambiar el tamaño del contenedor (resize ventana o toggle del panel)
          function preserveViewOnContainerChange(board){
            // Ajustar viewBox al tamaño del host y recalcular escala base del TABLERO
            setViewBoxToHost();
            recalcBase(board);
            // Forzar FIT y re-centrado con margen superior mínimo en el próximo apply
            scale = baseScale;
            forceCenterNext = true;
            apply(board);
          }

      function renderList(board){
        const piezas = board.piezas||[];
        if(!piezas.length){ list.innerHTML = '<div class="text-muted">Sin piezas.</div>'; return; }
        list.innerHTML = piezas.map(p=>{
          const st=p.estado||'pendiente';
          return `<div class="d-flex justify-content-between align-items-center py-1 border-bottom small" data-row="${p.pieza_id}">
            <div>
              <div><strong>${p.nombre||p.pieza_id}</strong></div>
              <div class="text-muted">${p.ancho}×${p.largo} mm · (${p.x},${p.y})</div>
            </div>
            <div class="d-flex align-items-center gap-2">
              <span class="d-inline-block rounded-circle" style="width:10px;height:10px;background:${stateColor(st)}"></span>
              <select class="form-select form-select-sm" style="min-width:130px" data-pieza="${p.pieza_id}">
                <option value="pendiente" ${st==='pendiente'?'selected':''}>Pendiente</option>
                <option value="en_corte" ${st==='en_corte'?'selected':''}>En corte</option>
                <option value="cortada" ${st==='cortada'?'selected':''}>Cortada</option>
                <option value="descartada" ${st==='descartada'?'selected':''}>Descartada</option>
              </select>
            </div>
          </div>`
        }).join('');
        // hover de lista a pieza
        list.querySelectorAll('[data-row]').forEach(row=>{
          const pid=row.getAttribute('data-row');
          row.addEventListener('mouseenter',()=>{
            const grp = g.querySelector(`g[data-pieza="${CSS.escape(pid)}"]`); grp?.classList.add('piece-highlight');
            row.classList.add('list-highlight');
          });
          row.addEventListener('mouseleave',()=>{
            const grp = g.querySelector(`g[data-pieza="${CSS.escape(pid)}"]`); grp?.classList.remove('piece-highlight');
            row.classList.remove('list-highlight');
          });
        });
        list.querySelectorAll('select[data-pieza]').forEach(sel=>{
          sel.addEventListener('change', async (e)=>{
            const pid=e.target.getAttribute('data-pieza'); const estado=e.target.value;
            try{
              const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/${encodeURIComponent(pid)}`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado})});
              if(!r.ok) throw new Error('err');
              const dot = list.querySelector(`[data-row="${pid}"] span.rounded-circle`); if(dot) dot.style.background = stateColor(estado);
              const rect = document.getElementById(`piece-${pid}`); if(rect) rect.setAttribute('fill', stateColor(estado));
            }catch(err){ alert('No se pudo guardar el estado.'); }
          });
        });
      }

      function renderBoard(board){
        while(g.firstChild) g.removeChild(g.firstChild);
        // tablero
        const w=board.ancho_mm||2440, h=board.largo_mm||1830;
        const tb = document.createElementNS(svgNS,'rect'); tb.setAttribute('x','0'); tb.setAttribute('y','0'); tb.setAttribute('width',String(w)); tb.setAttribute('height',String(h)); tb.setAttribute('fill','#fff'); tb.setAttribute('stroke','#333'); tb.setAttribute('stroke-width','2'); g.appendChild(tb);
        // Actualizar límites del tablero para centrar/clamp correctos
        boardBounds = {x:0, y:0, width:w, height:h};
        // medidas del tablero
  // Medidas del tablero por FUERA del tablero
  const topTxt = document.createElementNS(svgNS,'text'); topTxt.setAttribute('x', String(w/2)); topTxt.setAttribute('y', String(-12)); topTxt.setAttribute('text-anchor','middle'); topTxt.setAttribute('font-size', fs(24)); topTxt.setAttribute('fill','#444'); topTxt.textContent = `${w} mm`; g.appendChild(topTxt);
  const leftTxt = document.createElementNS(svgNS,'text'); leftTxt.setAttribute('x', String(-12)); leftTxt.setAttribute('y', String(h/2)); leftTxt.setAttribute('text-anchor','middle'); leftTxt.setAttribute('font-size', fs(24)); leftTxt.setAttribute('fill','#444'); leftTxt.setAttribute('transform', `rotate(-90 -12 ${h/2})`); leftTxt.textContent = `${h} mm`; g.appendChild(leftTxt);
  // Sombreado de márgenes (fuera del área útil) para resaltar banda a recortar
  try{
    const mx = Number(meta.margen_x);
    const my = Number(meta.margen_y);
    if(Number.isFinite(mx) && Number.isFinite(my) && (mx>0 || my>0)){
      const overColor = '#FFC107';
      const overOpacity = 0.18;
      const addRect = (x,y,wid,hei) => {
        if(wid>0 && hei>0){
          const r = document.createElementNS(svgNS,'rect');
          r.setAttribute('x', String(x));
          r.setAttribute('y', String(y));
          r.setAttribute('width', String(wid));
          r.setAttribute('height', String(hei));
          r.setAttribute('fill', overColor);
          r.setAttribute('fill-opacity', String(overOpacity));
          r.setAttribute('stroke','none');
          g.appendChild(r);
        }
      };
      // top
      addRect(0, 0, w, Math.max(0, my));
      // bottom
      addRect(0, Math.max(0, h - my), w, Math.max(0, my));
      // left
      addRect(0, Math.max(0, my), Math.max(0, mx), Math.max(0, h - 2*my));
      // right
      addRect(Math.max(0, w - mx), Math.max(0, my), Math.max(0, mx), Math.max(0, h - 2*my));
    }
  }catch(_e){}
  // piezas
        for(const p of (board.piezas||[])){
          const group = document.createElementNS(svgNS,'g');
          group.setAttribute('data-pieza', p.pieza_id);
          group.style.cursor = 'pointer';
          const x = (p.x||0), y=(p.y||0), pw=(p.ancho||0), ph=(p.largo||0);

          const rc=document.createElementNS(svgNS,'rect');
          rc.setAttribute('id',`piece-${p.pieza_id}`);
          rc.setAttribute('x',String(x)); rc.setAttribute('y',String(y)); rc.setAttribute('width',String(pw)); rc.setAttribute('height',String(ph));
          rc.setAttribute('fill',stateColor(p.estado||'pendiente'));
          rc.setAttribute('fill-opacity','0.35');
          rc.setAttribute('stroke','#222'); rc.setAttribute('stroke-width','1.2');
          group.appendChild(rc);

          // Etiquetas dentro de la pieza
          const padding = 6;
          const canShow = (pw >= 60 && ph >= 40);
          if(canShow){
            const nameText = document.createElementNS(svgNS,'text');
            nameText.setAttribute('x', String(x + pw/2));
            nameText.setAttribute('y', String(y + ph/2));
            nameText.setAttribute('text-anchor','middle');
            nameText.setAttribute('dominant-baseline','middle');
            nameText.setAttribute('font-size', fs(30));
            nameText.setAttribute('font-weight','bold');
            nameText.setAttribute('fill','#111');
            nameText.textContent = p.nombre || p.pieza_id;
            group.appendChild(nameText);

            // ancho: en la parte superior centrado
            const wText = document.createElementNS(svgNS,'text');
            wText.setAttribute('x', String(x + pw/2));
            wText.setAttribute('y', String(y + padding + 22));
            wText.setAttribute('text-anchor','middle');
            wText.setAttribute('font-size', fs(20));
            wText.setAttribute('fill','#111');
            wText.textContent = `${p.ancho} mm`;
            group.appendChild(wText);

            // largo: en el lado derecho, vertical
            const lText = document.createElementNS(svgNS,'text');
            const cx = x + pw - 6, cy = y + ph/2;
            lText.setAttribute('x', String(cx));
            lText.setAttribute('y', String(cy));
            lText.setAttribute('text-anchor','middle');
            lText.setAttribute('font-size', fs(20));
            lText.setAttribute('fill','#111');
            lText.setAttribute('transform', `rotate(-90 ${cx} ${cy})`);
            lText.textContent = `${p.largo} mm`;
            group.appendChild(lText);

            // tapacanto abreviado
            const tcText = document.createElementNS(svgNS,'text');
            tcText.setAttribute('x', String(x + pw/2));
            tcText.setAttribute('y', String(y + ph - padding - 6));
            tcText.setAttribute('text-anchor','middle');
            tcText.setAttribute('font-size', fs(18));
            tcText.setAttribute('fill','#111');
            tcText.textContent = `TC: ${tapsLabel(p.tapacantos)}`;
            group.appendChild(tcText);
          }

          // hover resaltado cruzado
          group.addEventListener('mouseenter',()=>{
            group.classList.add('piece-highlight');
            const row=list.querySelector(`[data-row="${p.pieza_id}"]`);
            row?.classList.add('list-highlight');
          });
          group.addEventListener('mouseleave',()=>{
            group.classList.remove('piece-highlight');
            const row=list.querySelector(`[data-row="${p.pieza_id}"]`);
            row?.classList.remove('list-highlight');
          });

          // Click: flujo pieza -> en_corte con zoom a la pieza, segundo click -> cortada y volver a vista normal
          group.addEventListener('click',()=>{
            focusOrTogglePiece(p);
          });
          g.appendChild(group);
        }
        // Margen útil en amarillo (si hay márgenes)
        const mx = Number(meta.margen_x);
        const my = Number(meta.margen_y);
        if(Number.isFinite(mx) && Number.isFinite(my) && (mx>0 || my>0)){
          const usable = document.createElementNS(svgNS,'rect');
          usable.setAttribute('x', String(mx));
          usable.setAttribute('y', String(my));
          usable.setAttribute('width', String(Math.max(w-2*mx,0)));
          usable.setAttribute('height', String(Math.max(h-2*my,0)));
          usable.setAttribute('fill','none');
          usable.setAttribute('stroke','#FFC107');
          usable.setAttribute('stroke-width','2');
          usable.setAttribute('stroke-dasharray','6 4');
          g.appendChild(usable);
        }
        // cortes: si vienen, usarlos; si no, inferir
        const cortes = Array.isArray(board.cortes)&&board.cortes.length? board.cortes : null;
        if(cortes){
          for(const c of cortes){
            const ln=document.createElementNS(svgNS,'line');
            if(c.tipo==='vertical'){
              ln.setAttribute('x1',String(c.posicion)); ln.setAttribute('x2',String(c.posicion)); ln.setAttribute('y1','0'); ln.setAttribute('y2',String(h));
            } else if(c.tipo==='horizontal'){
              ln.setAttribute('x1','0'); ln.setAttribute('x2',String(w)); ln.setAttribute('y1',String(c.posicion)); ln.setAttribute('y2',String(c.posicion));
            } else { continue; }
            ln.setAttribute('stroke','#666'); ln.setAttribute('stroke-width','1.6'); ln.setAttribute('stroke-dasharray','6 5');
            g.appendChild(ln);
          }
        }
        // Bounding box completo (incluye textos/cortes) y vista inicial centrada
        contentBounds = g.getBBox();
        fit(board);
      }

      // Estado de zoom focal de pieza
      let focusedPiece = null; // pieza_id o null
      const pendingByPiece = new Map();
      async function setPieceState(piezaId, estado){
        // Persistencia asíncrona; no bloquea la UI
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/${encodeURIComponent(piezaId)}`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado})});
          if(!r.ok) throw new Error(await r.text());
        }catch(err){
          // Fallback: marcar error en consola y permitir reintento manual (no revertimos para mantener fluidez)
          console.error('Persistencia de pieza falló:', err);
          alert('No se pudo guardar la pieza. Intenta nuevamente.');
        } finally {
          pendingByPiece.delete(piezaId);
        }
      }
      function updatePieceUI(pid, estado){
        const dot = list.querySelector(`[data-row="${pid}"] span.rounded-circle`); if(dot) dot.style.background = stateColor(estado);
        const sel = list.querySelector(`select[data-pieza="${pid}"]`); if(sel) sel.value = estado;
        const rect = document.getElementById(`piece-${pid}`); if(rect) rect.setAttribute('fill', stateColor(estado));
      }
      function pieceZoom(board, p){
        const {w:vw, h:vh} = vbSize();
        const PAD = 40;
        const pw = p.ancho||1, ph = p.largo||1;
        // Escala para encajar la pieza con padding
        const sc = Math.min((vw - PAD*2)/pw, (vh - PAD*2)/ph);
        const targetScale = Math.max(sc, baseScale*MIN_ZOOM_FACTOR);
        // Centrar pieza
        const cx = p.x + pw/2, cy = p.y + ph/2;
        const targetDx = vw/2 - cx*targetScale;
        const targetDy = vh/2 - cy*targetScale;
        animateTo(board, {scale: targetScale, dx: targetDx, dy: targetDy}, 200);
      }
      function pieceUnzoom(board){
        const t = computeFitTransform(board);
        animateTo(board, t, 200);
      }
      async function focusOrTogglePiece(p){
        const board = tableros[idx]||{};
        const pid = p.pieza_id;
        const row=list.querySelector(`[data-row="${pid}"]`);
        row?.scrollIntoView({block:'nearest'});
        row?.classList.add('list-highlight'); setTimeout(()=>row?.classList.remove('list-highlight'),700);
        if(pendingByPiece.get(pid)) return; // evitar spam
        if(focusedPiece !== pid){
          // Optimista: actualizar UI inmediato y animar zoom
          p.estado = 'en_corte';
          updatePieceUI(pid, 'en_corte');
          focusedPiece = pid;
          pieceZoom(board, p);
          pendingByPiece.set(pid, true);
          setPieceState(pid, 'en_corte');
        } else {
          // Segundo click: marcar cortada y volver
          p.estado = 'cortada';
          updatePieceUI(pid, 'cortada');
          focusedPiece = null;
          pieceUnzoom(board);
          pendingByPiece.set(pid, true);
          setPieceState(pid, 'cortada');
        }
      }

      function updateStats(board){
        const w=board.ancho_mm||0, h=board.largo_mm||0; stSize.textContent = `${w}×${h} mm`;
        const mx = meta.margen_x ?? '?', my= meta.margen_y ?? '?'; stMargins.textContent = `mx=${mx}, my=${my}`;
        // útil (si se conocen márgenes)
        if(Number.isFinite(mx) && Number.isFinite(my)) stUtil.textContent = `${Math.max(w-2*mx,0)}×${Math.max(h-2*my,0)} mm`; else stUtil.textContent = '—';
        // eficiencia tablero si existe
        const eff = (board.eficiencia!=null)? Number(board.eficiencia).toFixed(1)+'%' : '—'; stEff.textContent = eff;
        stPieces.textContent = (board.piezas||[]).length;
        // cortes
        let v=0,hc=0; if(Array.isArray(board.cortes)&&board.cortes.length){ v = board.cortes.filter(c=>c.tipo==='vertical').length; hc = board.cortes.filter(c=>c.tipo==='horizontal').length; } else { const inf = inferCutLines(board); v = Math.max(inf.v.length-2,0); hc = Math.max(inf.h.length-2,0); }
        stCutV.textContent = String(v); stCutH.textContent = String(hc);
        stML.textContent = mlTapacanto(board);
      }

      // Interacción
  svg.addEventListener('wheel',(e)=>{ e.preventDefault(); const d = e.deltaY<0?1.1:0.9; const prev=scale; const board = tableros[idx]||{}; scale = Math.max(baseScale*MIN_ZOOM_FACTOR, Math.min(8, scale*d));
        // Zoom anclado al centro del viewport
        const rect=host.getBoundingClientRect(); const cx = rect.width/2, cy = rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse());
        dx = svgPt.x - (svgPt.x - dx) * (scale/prev); dy = svgPt.y - (svgPt.y - dy) * (scale/prev);
        apply(board);
      },{passive:false});
  svg.addEventListener('mousedown',(e)=>{
    if(atBaseZoom()) { dragging=false; svg.style.cursor='default'; return; }
    dragging=true; lx=e.clientX; ly=e.clientY; svg.style.cursor='grabbing';
  });
  window.addEventListener('mouseup',()=>{ dragging=false; updateCursor(); });
  window.addEventListener('mousemove',(e)=>{ if(!dragging) return; dx += (e.clientX-lx); dy += (e.clientY-ly); lx=e.clientX; ly=e.clientY; apply(tableros[idx]||{}); });
  document.getElementById('btnZoomIn').addEventListener('click',()=>{ scale=Math.min(8,scale*1.2); const board=tableros[idx]||{}; const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse()); const prev=scale/1.2; dx = svgPt.x - (svgPt.x - dx) * (scale/prev); dy = svgPt.y - (svgPt.y - dy) * (scale/prev); apply(board); });
  document.getElementById('btnZoomOut').addEventListener('click',()=>{ const board=tableros[idx]||{}; const prev=scale; scale=Math.max(baseScale*MIN_ZOOM_FACTOR,scale/1.2); const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse()); dx = svgPt.x - (svgPt.x - dx) * (scale/prev); dy = svgPt.y - (svgPt.y - dy) * (scale/prev); apply(board); });
  document.getElementById('btnZoomReset').addEventListener('click',()=>{
    // Ajustar vista: refresca el visualizador del tablero actual, centrando y re-ajustando sin recargar toda la página
    const board = tableros[idx]||{};
    renderBoard(board);
    renderList(board);
    updateStats(board);
    updateCompletarVisibility();
    updateCursor();
  });

  // Gestos táctiles: pan con 1 dedo (si zoom > base), pinch con 2 dedos para zoom
  svg.addEventListener('touchstart',(e)=>{
    if(e.touches.length===1){
      if(atBaseZoom()) return; // no pan al zoom base
      dragging=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY;
    } else if(e.touches.length===2){
      pinch.active=true;
      const t1=e.touches[0], t2=e.touches[1];
      pinch.d0 = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      pinch.s0 = scale;
      pinch.cx = (t1.clientX + t2.clientX)/2; pinch.cy = (t1.clientY + t2.clientY)/2;
    }
  }, {passive:false});
  svg.addEventListener('touchmove',(e)=>{
    if(pinch.active && e.touches.length===2){
      e.preventDefault();
      const t1=e.touches[0], t2=e.touches[1];
      const d = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const prev=scale;
  scale = Math.max(baseScale*MIN_ZOOM_FACTOR, Math.min(8, pinch.s0 * (d / Math.max(1, pinch.d0))));
      const pt=svg.createSVGPoint(); pt.x=pinch.cx; pt.y=pinch.cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse());
      dx = svgPt.x - (svgPt.x - dx) * (scale/prev);
      dy = svgPt.y - (svgPt.y - dy) * (scale/prev);
      apply(tableros[idx]||{});
    } else if(dragging && e.touches.length===1){
      e.preventDefault();
      const tx=e.touches[0].clientX, ty=e.touches[0].clientY;
      dx += (tx - lx); dy += (ty - ly); lx=tx; ly=ty; apply(tableros[idx]||{});
    }
  }, {passive:false});
  svg.addEventListener('touchend',()=>{ if(pinch.active && event.touches && event.touches.length<2) pinch.active=false; dragging=false; updateCursor(); }, {passive:true});
  // Observa cambios reales de tamaño del host, más fiable que window.resize
  let lastHostSize = {w:0,h:0};
  function preserveWhenReady(board, tries=10){
    const r = host.getBoundingClientRect();
    if((r.width<10 || r.height<10) && tries>0){ setTimeout(()=>preserveWhenReady(board, tries-1), 60); return; }
  preserveViewOnContainerChange(board);
  }
  const ro = new ResizeObserver(entries=>{
    for(const e of entries){
      const cr = e.contentRect;
      if(Math.abs(cr.width - lastHostSize.w) > 1 || Math.abs(cr.height - lastHostSize.h) > 1){
        lastHostSize = {w:cr.width, h:cr.height};
        preserveWhenReady(tableros[idx]||{});
      }
    }
  });
  ro.observe(host);
  // Fallback por si el navegador no soporta ResizeObserver (no debería ser el caso)
  window.addEventListener('resize', ()=>{ preserveWhenReady(tableros[idx]||{}); });
      document.getElementById('btnToggleSidebar').addEventListener('click',()=>{
        const wrap = document.querySelector('.op-wrapper');
        const btn = document.getElementById('btnToggleSidebar');
        const isHidden = wrap.classList.toggle('sidebar-hidden');
        btn.textContent = isHidden ? 'Panel ◂' : 'Panel ▸';
        // Re-centrar manteniendo escala al cambiar el ancho disponible
        // Esperar a que la grilla recalcule el layout; lanzar varias veces para garantizar el estado final
        requestAnimationFrame(()=>preserveWhenReady(tableros[idx]||{}));
        setTimeout(()=>preserveWhenReady(tableros[idx]||{}), 60);
        setTimeout(()=>preserveWhenReady(tableros[idx]||{}), 140);
      });
      function updateCompletarVisibility(){
        const btn = document.getElementById('btnCompletar');
        if(!btn) return;
        const isLast = (idx === Math.max(0, tableros.length - 1));
        btn.style.display = isLast ? 'inline-block' : 'none';
      }
      selTab.addEventListener('change',()=>{ idx=parseInt(selTab.value,10)||0; renderBoard(tableros[idx]||{}); renderList(tableros[idx]||{}); updateStats(tableros[idx]||{}); updateCompletarVisibility(); });
  window.addEventListener('keydown',(e)=>{ const board=tableros[idx]||{}; if(e.key==='+'){ const prev=scale; scale=Math.min(8,scale*1.1); const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse()); dx = svgPt.x - (svgPt.x - dx) * (scale/prev); dy = svgPt.y - (svgPt.y - dy) * (scale/prev); apply(board); } else if(e.key==='-'){ const prev=scale; scale=Math.max(baseScale*MIN_ZOOM_FACTOR,scale/1.1); const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const svgPt=pt.matrixTransform(svg.getScreenCTM().inverse()); dx = svgPt.x - (svgPt.x - dx) * (scale/prev); dy = svgPt.y - (svgPt.y - dy) * (scale/prev); apply(board); } else if(e.key==='0'){ fit(board); } else if(e.key==='ArrowRight'){ idx=Math.min(tableros.length-1, idx+1); selTab.value=String(idx); selTab.dispatchEvent(new Event('change')); } else if(e.key==='ArrowLeft'){ idx=Math.max(0, idx-1); selTab.value=String(idx); selTab.dispatchEvent(new Event('change')); } else if(e.key==='s' || e.key==='S'){ const box=document.getElementById('statsBox'); box.style.display = (box.style.display==='none')? 'block' : 'none'; } });

      // Inicialización
      renderBoard(tableros[idx]||{}); renderList(tableros[idx]||{}); updateStats(tableros[idx]||{});
      updateZoomUI();
      updateCompletarVisibility();

      // Al iniciar edición, marcar proyecto EN PROCESO si no está completado
      try{
        if(proyectoMeta && proyectoMeta.estado !== 'completado' && proyectoMeta.estado !== 'en_proceso'){
          await fetch(`/api/operador/proyectos/${proyectoId}/estado`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado:'en_proceso'})});
        }
      }catch(_e){}

      // Handler: marcar todas como cortadas
      document.getElementById('btnMarcarTodas').addEventListener('click', async ()=>{
        if(!confirm('¿Marcar todas las piezas de este proyecto como CORTADAS?')) return;
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/marcar-todas`, {method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado:'cortada'})});
          let jr = {};
          try { jr = await r.clone().json(); } catch(_) { try { jr = {message: await r.text()}; } catch(__) { jr = {}; } }
          if(!r.ok){ alert(jr && jr.message ? jr.message : 'No se pudo marcar.'); return; }
          // Refrescar UI local: setear a cortada
          for(const t of tableros){ for(const p of (t.piezas||[])){ p.estado = 'cortada'; } }
          renderList(tableros[idx]||{});
          // Colorear rects actuales
          (tableros[idx]?.piezas||[]).forEach(p=>{ const rect=document.getElementById(`piece-${p.pieza_id}`); if(rect) rect.setAttribute('fill', stateColor('cortada')); });
          alert('Todas las piezas marcadas como cortadas.');
        }catch(_e){ alert('Error al marcar todas como cortadas.'); }
      });

      // Handler: completar proyecto (sólo en último tablero visible)
      document.getElementById('btnCompletar').addEventListener('click', async ()=>{
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/completar`, {method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}});
          const jr = await r.json().catch(()=>({}));
          if(!r.ok){
            const msg = jr && jr.message ? jr.message : 'No se pudo completar el proyecto.';
            alert(msg);
            return;
          }
          // Volver a la lista del operador
          window.location.href = '{% url "operador_home" %}';
        }catch(_e){ alert('Error al completar el proyecto.'); }
      });
    })();
    </script>

    {% include "partials/scripts.html" %}
  </body>
  </html>
