{% load static %}
<!DOCTYPE html>
<html lang="es" data-theme="light">
  {% include "partials/head.html" %}
  <!-- Fuerza seteo de cookie CSRF y expone token vía meta -->
  <meta name="csrf-token" content="{{ csrf_token }}" />
  <style>
    html, body { height: 100%; }
    body { overflow: hidden; }
    .op-wrapper { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr 360px; grid-template-rows: auto 1fr; grid-template-areas: 'toolbar toolbar' 'canvas sidebar'; }
    .op-toolbar { grid-area: toolbar; display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #fff; border-bottom: 1px solid #eee; }
    .op-canvas { grid-area: canvas; position: relative; background: #fafafa; }
  .op-sidebar { grid-area: sidebar; display: flex; flex-direction: column; border-left: 1px solid #eee; background: #fff; min-height: 0; overflow: hidden; }
  .op-stats { padding: 10px 12px; border-bottom: 1px solid #eee; }
  .op-list { padding: 0 12px 12px 12px; overflow: auto; flex: 1 1 auto; min-height: 0; }
    .op-btn { border: 1px solid #ddd; background: #fff; border-radius: 6px; padding: 6px 10px; }
    .op-btn:active { transform: translateY(1px); }
    .chip { display:inline-block; padding:2px 8px; border-radius:10px; font-size:12px; margin-right:6px; background:#f1f3f5; }
    .piece-highlight rect { filter: drop-shadow(0 0 0.5px rgba(0,0,0,.4)); stroke-width: 2; }
    .list-highlight { background: #fffbe6; }
    .piece-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index: 20; }
  .piece-modal { background: #fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.3); width: 95vw; max-width: 1280px; height: 90vh; display:flex; flex-direction:column; }
    .piece-modal .hdr { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; border-bottom: 1px solid #eee; }
    .piece-modal .cnt { padding: 10px; position: relative; overflow:auto; flex:1; padding-bottom: 12px; }
    .piece-modal .btn-close { border:none; background:transparent; font-size:22px; line-height:1; cursor:pointer; }
  .pz-overview { position:absolute; right:12px; bottom:12px; width:260px; height:180px; background:transparent; border:none; border-radius:0; box-shadow:none; padding:0; z-index: 1; }
  .piece-modal .ftr { display:flex; justify-content:flex-end; gap:8px; padding: 10px 14px; border-top:1px solid #eee; background:#fff; }
    /* Ocultar/mostrar sidebar */
    .op-wrapper.sidebar-hidden { grid-template-columns: 1fr 0; }
    .op-wrapper.sidebar-hidden .op-sidebar { display: none; }
    /* Transición suave de color en piezas para sensación de fluidez */
    g[data-pieza] rect { transition: fill .15s ease, fill-opacity .15s ease; }
  </style>
  <body>
    <div class="op-wrapper">
      <div class="op-toolbar">
        <a href="{% url 'operador_home' %}" class="op-btn">← Volver</a>
        <div class="vr mx-2"></div>
  <strong>{{ proyecto.public_id|default:proyecto.id }}</strong>
  <span>· {{ proyecto.nombre }}</span>
        <div class="vr mx-2"></div>
    <label class="me-1 small text-muted">Tablero</label>
    <select id="selTablero" class="form-select form-select-sm" style="width:auto;"></select>
    <div class="vr mx-2"></div>
    <!-- Controles de zoom: [-] [porcentaje] [+] -->
    <button id="btnZoomOut" class="op-btn" type="button" title="Alejar">-</button>
    <span id="zoomPct" class="chip" title="Nivel de zoom">100%</span>
    <button id="btnZoomIn" class="op-btn" type="button" title="Acercar">+</button>
    <!-- Botón cuadrar: restablecer vista al inicio, centrado y tablero completo -->
  <button id="btnZoomReset" class="op-btn" type="button" title="Ajustar vista (centrar y refrescar visualizador)">Ajustar vista</button>
    <div class="vr mx-2"></div>
    <!-- Acciones del operador -->
    <button id="btnMarcarTodas" class="op-btn" type="button" title="Marcar todas las piezas como cortadas">Marcar todas cortadas</button>
    <button id="btnCompletar" class="op-btn" type="button" title="Completar proyecto y volver a la lista" style="display:none;">Completar proyecto</button>
    <button id="btnToggleSidebar" class="op-btn ms-auto" type="button" title="Ocultar/mostrar panel">Panel ▸</button>
  <div class="small text-muted ms-2">Atajos: + / - / 0 · ← → cambia tablero</div>
      </div>
      <div class="op-canvas" id="canvasHost">
        <div class="w-100 h-100 d-flex align-items-center justify-content-center text-muted">Cargando diseño…</div>
      </div>
      <div class="op-sidebar">
        <div class="op-stats small" id="statsBox">
          <div><strong>Material:</strong> <span id="stMaterial">—</span></div>
          <div><strong>Tablero:</strong> <span id="stSize">—</span> · <span id="stEff">—</span> de aprovechamiento</div>
          <div><strong>Útil (márgenes):</strong> <span id="stUtil">—</span> (<span id="stMargins">mx=?, my=?</span>)</div>
          <div><strong>Piezas:</strong> <span id="stPieces">—</span> · <strong>Cortes:</strong> V:<span id="stCutV">0</span> H:<span id="stCutH">0</span></div>
          <div><strong>Tapacanto ML:</strong> <span id="stML">—</span></div>
        </div>
        <div class="op-list" id="listaPiezas"></div>
      </div>
    </div>

    <script>
    (async function(){
      const proyectoId = parseInt('{{ proyecto.id }}', 10);
      const host = document.getElementById('canvasHost');
      const selTab = document.getElementById('selTablero');
      const list = document.getElementById('listaPiezas');
      const stMaterial = document.getElementById('stMaterial');
      const stSize = document.getElementById('stSize');
      const stEff = document.getElementById('stEff');
      const stUtil = document.getElementById('stUtil');
      const stMargins = document.getElementById('stMargins');
      const stPieces = document.getElementById('stPieces');
      const stCutV = document.getElementById('stCutV');
      const stCutH = document.getElementById('stCutH');
      const stML = document.getElementById('stML');

      function getCookie(name){
        const v = document.cookie.split('; ').find(r=>r.startsWith(name+'='));
        return v ? decodeURIComponent(v.split('=')[1]) : '';
      }
      function getCsrf(){
        return getCookie('csrftoken') || (document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '');
      }

  const resp = await fetch(`/api/operador/proyectos/${proyectoId}`, {credentials:'same-origin'});
      if(!resp.ok){ host.innerHTML = '<div class="w-100 h-100 d-flex align-items-center justify-content-center text-danger">No hay resultado.</div>'; return; }
      const data = await resp.json();
      const tableros = data.tableros||[];
      const meta = data.meta||{};
  const proyectoMeta = data.proyecto||{};

      stMaterial.textContent = meta.material || '—';
      selTab.innerHTML = tableros.map((t,i)=>`<option value="${i}">Tablero ${t.num}</option>`).join('');
      let idx = 0;

      // SVG setup
      host.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width','100%'); svg.setAttribute('height','100%');
  // Cursor: por defecto, según zoom
  svg.style.cursor = 'default';
  // Evitar gestos de pinch nativos que hagan zoom del viewport del navegador en móviles
  svg.setAttribute('touch-action','none');
  // Margen superior deseado en modo ajuste: responsivo al alto del host (6% del alto), con límites
  const FIT_PAD_MIN = 32, FIT_PAD_MAX = 80;
  // Padding fijo cuando el modo es 'top'
  const FIT_TOP_PAD = 16;   // menor margen superior para aprovechar más alto
  const FIT_BOTTOM_PAD = 16; // pequeño colchón inferior para asegurar tablero completo visible
  const FIT_LEFT_PAD = 24;   // separar ligeramente del borde izquierdo
  const FIT_RIGHT_PAD = 16;  // colchón derecho
  // Escala tipográfica global del visor (85% de la actual)
  const FONT_SCALE = 0.85;
  function fs(px){ return String(Math.round(px*FONT_SCALE)); }
  // Permitir alejar por debajo del FIT hasta el 50%
  const MIN_ZOOM_FACTOR = 0.5; // 50% de la escala base
  // Factor del FIT base: 1.0 = encajar exacto; 0.66 = que se vea como ~66% del encaje
  const BASE_FIT_FACTOR = 0.66;
  // Sobrepaneo cuando hay zoom: permitir mover el tablero fuera del visor
  // en un porcentaje del viewport (en unidades de contenido). 1.0 = 100% del viewport.
  const OVERPAN_FACTOR = 1.0;
  // Paneo totalmente libre cuando hay zoom (> base). Si es true, no se aplica clamp fuera del fit.
  const FREE_PAN_WHEN_ZOOMED = true;
  // Padding alrededor al hacer zoom a una pieza
  const PIECE_ZOOM_PAD = 32;
  // Modo vertical de encaje: 'top' (anclado arriba), 'top-pad' (arriba con padding responsivo) o 'center'
  const FIT_VERTICAL_MODE = 'top';
  function getFitPad(){
    const r = host.getBoundingClientRect();
    const h = (r && r.height) ? r.height : vbSize().h;
    const pad = Math.round(h * 0.06); // 6% del alto
    return Math.max(FIT_PAD_MIN, Math.min(FIT_PAD_MAX, pad));
  }
  const ALWAYS_CENTER = false; // permitir movimiento libre de la cámara por arrastre
  function setViewBoxToHost(){
    // Usar medidas reales del host; si está minimizado/oculto, no tocar el viewBox
    const w0 = host.clientWidth || host.getBoundingClientRect().width;
    const h0 = host.clientHeight || host.getBoundingClientRect().height;
    if(!w0 || !h0 || w0 < 10 || h0 < 10){
      return false; // no modificar mientras no haya tamaño válido
    }
    const w = Math.floor(w0);
    const h = Math.floor(h0);
    svg.setAttribute('viewBox',`0 0 ${w} ${h}`);
    return true;
  }
  setViewBoxToHost();
      const g = document.createElementNS(svgNS, 'g');
      svg.appendChild(g); host.appendChild(svg);
  let scale = 1, baseScale = 1, dx = 0, dy = 0; let dragging=false, lx=0, ly=0;
  // Animación de cámara
  let animFrame = 0;
  // Soporte pinch-to-zoom
  let pinch = {active:false, d0:0, s0:1, cx:0, cy:0};
  // Evitar re-centrado automático una vez (por paneo con rueda al zoom base)
  let suppressCenterOnce = false;
  // Forzar centrado exacto en el siguiente apply (usado tras cambios de tamaño)
  let forceCenterNext = false;
  // Bounds del TABLERO (no de todo el <g>), para centrar/clamp sin considerar textos externos
  let boardBounds = {x:0,y:0,width:1,height:1};
  // BBox completo del grupo (incluye textos y cortes)
  let contentBounds = {x:0,y:0,width:1,height:1};
  // BBox a usar para el ajuste (fit) y centrado visual: incluye etiquetas externas
  let fitBounds = {x:0,y:0,width:1,height:1};
  // Consideramos "base" cualquier valor <= baseScale (con pequeña tolerancia)
  function atBaseZoom(){ return baseScale>0 ? (scale <= baseScale * (1+1e-3)) : (scale <= baseScale); }
  function vbSize(){ const vb=(svg.getAttribute('viewBox')||'0 0 100 100').split(/\s+/); return {w: parseFloat(vb[2]||'100'), h: parseFloat(vb[3]||'100')}; }
      function updateCursor(){
        if(dragging) { svg.style.cursor = 'grabbing'; return; }
        svg.style.cursor = atBaseZoom() ? 'default' : 'grab';
      }
  function zoomPercent(){ return Math.round((scale/baseScale)*100); }
  function updateZoomUI(){ const sp = document.getElementById('zoomPct'); if(sp){ sp.textContent = `${zoomPercent()}%`; } }
      function fitTransformForScale(sc){
        // Importante: dx/dy están en UNIDADES DE CONTENIDO porque el transform es translate(dx,dy) scale(sc)
        // El viewport visible en contenido es vw/sc × vh/sc
        const {w:vw, h:vh} = vbSize();
        const bw = boardBounds.width, bh = boardBounds.height;
  // Anclar horizontalmente el TABLERO al margen izquierdo con padding
  const tx = (FIT_LEFT_PAD/sc) - boardBounds.x;
        if(FIT_VERTICAL_MODE === 'center'){
          const ty = (vh/sc - bh)/2 - boardBounds.y; // centrado vertical
          return {dx: tx, dy: ty};
        } else if (FIT_VERTICAL_MODE === 'top' || FIT_VERTICAL_MODE === 'top-pad'){
          const padTop = (FIT_VERTICAL_MODE === 'top') ? FIT_TOP_PAD : getFitPad();
          const ty = (padTop/sc) - boardBounds.y; // anclado arriba con padding en contenido
          return {dx: tx, dy: ty};
        } else {
          // Fallback a centrado si el modo es desconocido
          const ty = (vh/sc - bh)/2 - boardBounds.y;
          return {dx: tx, dy: ty};
        }
      }
      function ensureBoardInView(){
        // Solo garantizamos vista completa cuando estamos en el zoom base (fit).
        if(!atBaseZoom()) return;
        const {w:vw, h:vh} = vbSize();
        // Calcular bordes en pantalla correctamente: screen = scale * (content + translate)
        const left = scale * (boardBounds.x + dx);
        const top = scale * (boardBounds.y + dy);
        const right = left + boardBounds.width * scale;
        const bottom = top + boardBounds.height * scale;
        const padTol = 2; // tolerancia mínima de borde
        const out = (left < -padTol) || (top < -padTol) || (right > vw + padTol) || (bottom > vh + padTol);
        if(out){
          const t = fitTransformForScale(scale);
          dx = t.dx; dy = t.dy;
        }
      }
      function clamp(board){
        const {w:vw, h:vh} = vbSize();
        // dx/dy en UNIDADES DE CONTENIDO (translate antes que scale)
        // Mantener el tablero dentro del viewport: condiciones en contenido
        const bx = boardBounds.x, by = boardBounds.y, bw = boardBounds.width, bh = boardBounds.height;
        // Límites básicos (sin sobrepaneo)
        let dxMin = -bx;                             // left >= 0 => bx + dx >= 0
        let dxMax = (vw/scale) - (bx + bw);          // right <= vw => bx + bw + dx <= vw/scale
        let dyMin = -by;
        let dyMax = (vh/scale) - (by + bh);
        // ¿Forzamos centrado puntual? (por resize/reset)
        const atBase = atBaseZoom();
        if(forceCenterNext || (atBase && !suppressCenterOnce)){
          const t = fitTransformForScale(scale);
          dx = t.dx; dy = t.dy;
          if(forceCenterNext) forceCenterNext = false;
        } else {
          if(!atBase && FREE_PAN_WHEN_ZOOMED){
            // Sin límites al pan fuera del encaje (el usuario puede moverse libremente)
            // No ajustar dx/dy aquí
          } else {
          // Si NO estamos en zoom base, permitir sobrepaneo para mover libremente
          if(!atBase){
            const overX = OVERPAN_FACTOR * (vw/scale);
            const overY = OVERPAN_FACTOR * (vh/scale);
            dxMin -= overX; dxMax += overX;
            dyMin -= overY; dyMax += overY;
          }
          dx = Math.max(dxMin, Math.min(dxMax, dx));
          dy = Math.max(dyMin, Math.min(dyMax, dy));
          }
        }
        if(suppressCenterOnce) suppressCenterOnce = false;
      }
      function apply(board){
        clamp(board||{});
        if(!isFinite(scale) || scale <= 0) scale = 1;
        if(!isFinite(dx)) dx = 0; if(!isFinite(dy)) dy = 0;
        ensureBoardInView();
  // Orden: translate primero y luego scale (dx/dy en contenido)
  g.setAttribute('transform', `translate(${dx},${dy}) scale(${scale})`);
        updateCursor();
        updateZoomUI();
      }

      function stateColor(st){
        // Colores requeridos: cortada verde vivo, pendiente gris; otros estados mantienen diferenciación
        return st==='cortada' ? '#28A745' : st==='pendiente' ? '#6C757D' : st==='en_corte' ? '#0D6EFD' : st==='descartada' ? '#DC3545' : '#6C757D';
      }

      function mlTapacanto(board){
        let mm = 0; for(const p of (board.piezas||[])){
          const tc = p.tapacantos||{};
          if(tc.arriba) mm += (p.ancho||0);
          if(tc.abajo) mm += (p.ancho||0);
          if(tc.derecha) mm += (p.largo||0);
          if(tc.izquierda) mm += (p.largo||0);
        }
        return (mm/1000).toFixed(2) + ' m';
      }

      function tapsLabel(tc){
        if(!tc) return '—';
        const parts = [];
        if(tc.arriba) parts.push('A');
        if(tc.derecha) parts.push('D');
        if(tc.abajo) parts.push('B');
        if(tc.izquierda) parts.push('I');
        return parts.length? parts.join(',') : '—';
      }

      // Dibuja líneas de tapacanto en los bordes indicados
      function drawTapacantosLines(parent, x, y, w, h, tc, opts){
        if(!tc) return;
        const o = opts||{};
        const color = o.color || '#DC3545';
        const strokeWidth = o.strokeWidth || 3; // más grueso para claridad
        const dash = o.dash || '8 5';
        const offset = Math.max(0, o.offset || 0);
        // Mantener la línea separada del borde de la pieza
        const offX = Math.min(offset, Math.max(0, w) * 0.10);
        const offY = Math.min(offset, Math.max(0, h) * 0.10);
        const add = (x1,y1,x2,y2)=>{
          const ln = document.createElementNS(svgNS,'line');
          ln.setAttribute('x1', String(x1)); ln.setAttribute('y1', String(y1));
          ln.setAttribute('x2', String(x2)); ln.setAttribute('y2', String(y2));
          ln.setAttribute('stroke', color);
          ln.setAttribute('stroke-width', String(strokeWidth));
          ln.setAttribute('stroke-dasharray', dash);
          ln.setAttribute('stroke-linecap', 'round');
          parent.appendChild(ln);
        };
        try{
          if(tc.arriba)    add(x, y + offY, x+w, y + offY);
          if(tc.abajo)     add(x, y+h - offY, x+w, y+h - offY);
          if(tc.izquierda) add(x + offX, y, x + offX, y+h);
          if(tc.derecha)   add(x+w - offX, y, x+w - offX, y+h);
        }catch(_e){}
      }

      function inferCutLines(board){
        const xs = new Set(), ys = new Set();
        for(const p of (board.piezas||[])){
          const x1 = (p.x||0), x2=(p.x||0)+(p.ancho||0);
          const y1 = (p.y||0), y2=(p.y||0)+(p.largo||0);
          xs.add(x1); xs.add(x2); ys.add(y1); ys.add(y2);
        }
        const v = Array.from(xs).sort((a,b)=>a-b); const h = Array.from(ys).sort((a,b)=>a-b);
        return {v:harden(v), h:harden(h)};
        function harden(arr){ const out=[]; let prev=null; const EPS=0.01; for(const x of arr){ if(prev===null || Math.abs(x-prev)>EPS){ out.push(x); prev=x; } } return out; }
      }

  function recalcBase(board){
        // Padding horizontal/vertical para el encaje base
        // Prioriza el ALTO visible; si el ancho limita más, se respeta también.
        const {w:vw, h:vh} = vbSize();
        const PAD_LEFT = FIT_LEFT_PAD; // margen izquierdo fijo
        const PAD_RIGHT = FIT_RIGHT_PAD; // margen derecho fijo
        let PAD_TOP = 16, PAD_BOTTOM = 16;
        if (FIT_VERTICAL_MODE === 'center') {
          PAD_TOP = 16; PAD_BOTTOM = 16;
        } else if (FIT_VERTICAL_MODE === 'top') {
          PAD_TOP = FIT_TOP_PAD; PAD_BOTTOM = FIT_BOTTOM_PAD; // anclado arriba con margen superior y pequeño fondo
        } else if (FIT_VERTICAL_MODE === 'top-pad') {
          const p = getFitPad(); PAD_TOP = p; PAD_BOTTOM = 8;
        }
        // Recalcular bbox completo para referencia, pero el ajuste base usa SOLO el tablero
        contentBounds = g.getBBox();
        fitBounds = contentBounds;
        const bw = Math.max(1, boardBounds.width || (board.ancho_mm||1));
        const bh = Math.max(1, boardBounds.height || (board.largo_mm||1));
  const availW = Math.max(50, vw - PAD_LEFT - PAD_RIGHT);
        const availH = Math.max(50, vh - PAD_TOP - PAD_BOTTOM);
        // Referencia principal: el ALTO visible; si el ancho es el limitante extremo, se respeta
        const scaleH = availH / bh;
        const scaleW = availW / bw;
        // Priorizar que el tablero sea ligeramente menor que el alto visible y además reducirlo
        // para que el 100% se perciba como ~66% del encaje clásico (más espacio alrededor)
        baseScale = Math.min(scaleH, scaleW) * BASE_FIT_FACTOR;
        if(!isFinite(baseScale) || baseScale <= 0) baseScale = 0.01; // fallback seguro
      }
      function recenter(board, keepScale=true){
        recalcBase(board);
        if(!keepScale) scale = baseScale; else scale = Math.max(scale, baseScale);
        const t = fitTransformForScale(scale);
        dx = t.dx; dy = t.dy; apply(board);
      }
      function fit(board){ recenter(board, false); }

          function computeFitTransform(board){
            // Calcula transform objetivo para fit sin aplicarlo inmediatamente
            recalcBase(board);
            const sc = baseScale;
            const t = fitTransformForScale(sc);
            return {scale: sc, dx: t.dx, dy: t.dy};
          }

          function animateTo(board, target, ms=180){
            if(animFrame) cancelAnimationFrame(animFrame);
            const s0 = scale, x0 = dx, y0 = dy;
            const s1 = target.scale, x1 = target.dx, y1 = target.dy;
            const t0 = performance.now();
            const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3);
            function step(t){
              const p = Math.min(1, (t - t0) / ms);
              const e = easeOutCubic(p);
              scale = s0 + (s1 - s0) * e;
              dx = x0 + (x1 - x0) * e;
              dy = y0 + (y1 - y0) * e;
              apply(board);
              if(p < 1) animFrame = requestAnimationFrame(step);
            }
            animFrame = requestAnimationFrame(step);
          }

          // Preserva el punto central del contenido y el nivel de zoom relativo
          // al cambiar el tamaño del contenedor (resize ventana o toggle del panel)
          function preserveViewOnContainerChange(board){
            // Ajustar viewBox al tamaño del host y recalcular escala base del TABLERO
            setViewBoxToHost();
            recalcBase(board);
            // Forzar FIT y re-centrado con margen superior mínimo en el próximo apply
            scale = baseScale;
            forceCenterNext = true;
            apply(board);
          }

      function renderList(board){
        const piezas = board.piezas||[];
        if(!piezas.length){ list.innerHTML = '<div class="text-muted">Sin piezas.</div>'; return; }
        list.innerHTML = piezas.map(p=>{
          const st=p.estado||'pendiente';
          return `<div class="d-flex justify-content-between align-items-center py-1 border-bottom small" data-row="${p.pieza_id}">
            <div>
              <div><strong>${p.nombre||p.pieza_id}</strong></div>
              <div class="text-muted">${p.ancho}×${p.largo} mm · (${p.x},${p.y})</div>
            </div>
            <div class="d-flex align-items-center gap-2">
              <span class="d-inline-block rounded-circle" style="width:10px;height:10px;background:${stateColor(st)}"></span>
              <select class="form-select form-select-sm" style="min-width:130px" data-pieza="${p.pieza_id}">
                <option value="pendiente" ${st==='pendiente'?'selected':''}>Pendiente</option>
                <option value="en_corte" ${st==='en_corte'?'selected':''}>En corte</option>
                <option value="cortada" ${st==='cortada'?'selected':''}>Cortada</option>
                <option value="descartada" ${st==='descartada'?'selected':''}>Descartada</option>
              </select>
            </div>
          </div>`
        }).join('');
        // hover de lista a pieza
        list.querySelectorAll('[data-row]').forEach(row=>{
          const pid=row.getAttribute('data-row');
          row.addEventListener('mouseenter',()=>{
            const grp = g.querySelector(`g[data-pieza="${CSS.escape(pid)}"]`); grp?.classList.add('piece-highlight');
            row.classList.add('list-highlight');
          });
          row.addEventListener('mouseleave',()=>{
            const grp = g.querySelector(`g[data-pieza="${CSS.escape(pid)}"]`); grp?.classList.remove('piece-highlight');
            row.classList.remove('list-highlight');
          });
        });
        list.querySelectorAll('select[data-pieza]').forEach(sel=>{
          sel.addEventListener('change', async (e)=>{
            const pid=e.target.getAttribute('data-pieza'); const estado=e.target.value;
            try{
              const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/${encodeURIComponent(pid)}`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado})});
              if(!r.ok) throw new Error('err');
              const dot = list.querySelector(`[data-row="${pid}"] span.rounded-circle`); if(dot) dot.style.background = stateColor(estado);
              const rect = document.getElementById(`piece-${pid}`); if(rect) rect.setAttribute('fill', stateColor(estado));
            }catch(err){ alert('No se pudo guardar el estado.'); }
          });
        });
      }

      function renderBoard(board){
        while(g.firstChild) g.removeChild(g.firstChild);
        // tablero
        const w=board.ancho_mm||2440, h=board.largo_mm||1830;
        const tb = document.createElementNS(svgNS,'rect'); tb.setAttribute('x','0'); tb.setAttribute('y','0'); tb.setAttribute('width',String(w)); tb.setAttribute('height',String(h)); tb.setAttribute('fill','#fff'); tb.setAttribute('stroke','#333'); tb.setAttribute('stroke-width','2'); g.appendChild(tb);
        // Actualizar límites del tablero para centrar/clamp correctos
        boardBounds = {x:0, y:0, width:w, height:h};
        // medidas del tablero
  // Medidas del tablero por FUERA del tablero
  const topTxt = document.createElementNS(svgNS,'text'); topTxt.setAttribute('x', String(w/2)); topTxt.setAttribute('y', String(-12)); topTxt.setAttribute('text-anchor','middle'); topTxt.setAttribute('font-size', fs(30)); topTxt.setAttribute('fill','#444'); topTxt.textContent = `${w} mm`; g.appendChild(topTxt);
  const leftTxt = document.createElementNS(svgNS,'text'); leftTxt.setAttribute('x', String(-12)); leftTxt.setAttribute('y', String(h/2)); leftTxt.setAttribute('text-anchor','middle'); leftTxt.setAttribute('font-size', fs(30)); leftTxt.setAttribute('fill','#444'); leftTxt.setAttribute('transform', `rotate(-90 -12 ${h/2})`); leftTxt.textContent = `${h} mm`; g.appendChild(leftTxt);
  // Sombreado de márgenes (fuera del área útil) para resaltar banda a recortar
  try{
    const mx = Number(meta.margen_x);
    const my = Number(meta.margen_y);
    if(Number.isFinite(mx) && Number.isFinite(my) && (mx>0 || my>0)){
      const overColor = '#FFC107';
      const overOpacity = 0.18;
      const addRect = (x,y,wid,hei) => {
        if(wid>0 && hei>0){
          const r = document.createElementNS(svgNS,'rect');
          r.setAttribute('x', String(x));
          r.setAttribute('y', String(y));
          r.setAttribute('width', String(wid));
          r.setAttribute('height', String(hei));
          r.setAttribute('fill', overColor);
          r.setAttribute('fill-opacity', String(overOpacity));
          r.setAttribute('stroke','none');
          g.appendChild(r);
        }
      };
      // top
      addRect(0, 0, w, Math.max(0, my));
      // bottom
      addRect(0, Math.max(0, h - my), w, Math.max(0, my));
      // left
      addRect(0, Math.max(0, my), Math.max(0, mx), Math.max(0, h - 2*my));
      // right
      addRect(Math.max(0, w - mx), Math.max(0, my), Math.max(0, mx), Math.max(0, h - 2*my));
    }
  }catch(_e){}
  // piezas
        for(const p of (board.piezas||[])){
          const group = document.createElementNS(svgNS,'g');
          group.setAttribute('data-pieza', p.pieza_id);
          group.style.cursor = 'pointer';
          const x = (p.x||0), y=(p.y||0), pw=(p.ancho||0), ph=(p.largo||0);

          const rc=document.createElementNS(svgNS,'rect');
          rc.setAttribute('id',`piece-${p.pieza_id}`);
          rc.setAttribute('x',String(x)); rc.setAttribute('y',String(y)); rc.setAttribute('width',String(pw)); rc.setAttribute('height',String(ph));
          rc.setAttribute('fill',stateColor(p.estado||'pendiente'));
          rc.setAttribute('fill-opacity','0.35');
          rc.setAttribute('stroke','#222'); rc.setAttribute('stroke-width','1.2');
          group.appendChild(rc);

          // Tapacantos: línea punteada roja, gruesa y separada del borde
          drawTapacantosLines(group, x, y, pw, ph, p.tapacantos||{}, { offset: 4, strokeWidth: 3.2, dash: '8 5' });

          // Etiquetas dentro de la pieza
          const padding = 6;
          const canShow = (pw >= 60 && ph >= 40);
          if(canShow){
            const nameText = document.createElementNS(svgNS,'text');
            const ncx = x + pw/2, ncy = y + ph/2;
            nameText.setAttribute('x', String(ncx));
            nameText.setAttribute('y', String(ncy));
            nameText.setAttribute('text-anchor','middle');
            nameText.setAttribute('dominant-baseline','middle');
            nameText.setAttribute('font-size', fs(30));
            nameText.setAttribute('font-weight','bold');
            nameText.setAttribute('fill','#111');
            // Orientar el nombre según el lado más largo y mantenerlo centrado
            if (ph >= pw) {
              nameText.setAttribute('transform', `rotate(-90 ${ncx} ${ncy})`);
            }
            nameText.textContent = p.nombre || p.pieza_id;
            group.appendChild(nameText);

            // Tamaños dinámicos, priorizando legibilidad sin desbordar
            const fsm = Math.min(42, Math.max(18, Math.min(pw, ph) / 5));

            // ancho: en la parte superior centrado
            const wText = document.createElementNS(svgNS,'text');
            wText.setAttribute('x', String(x + pw/2));
            wText.setAttribute('y', String(y + padding + fsm * 0.9));
            wText.setAttribute('text-anchor','middle');
            wText.setAttribute('font-size', fs(fsm));
            wText.setAttribute('fill','#111');
            wText.textContent = `${p.ancho} mm`;
            group.appendChild(wText);

            // largo: en el lado derecho, vertical
            const lText = document.createElementNS(svgNS,'text');
            const cx = x + pw - 6, cy = y + ph/2;
            lText.setAttribute('x', String(cx));
            lText.setAttribute('y', String(cy));
            lText.setAttribute('text-anchor','middle');
            lText.setAttribute('font-size', fs(fsm));
            lText.setAttribute('fill','#111');
            lText.setAttribute('transform', `rotate(-90 ${cx} ${cy})`);
            lText.textContent = `${p.largo} mm`;
            group.appendChild(lText);

            // tapacanto abreviado
            const tcText = document.createElementNS(svgNS,'text');
            tcText.setAttribute('x', String(x + pw/2));
            tcText.setAttribute('y', String(y + ph - padding - Math.max(6, fsm * 0.4)));
            tcText.setAttribute('text-anchor','middle');
            tcText.setAttribute('font-size', fs(Math.max(18, fsm * 0.85)));
            tcText.setAttribute('fill','#111');
            tcText.textContent = `TC: ${tapsLabel(p.tapacantos)}`;
            group.appendChild(tcText);
          }

          // hover resaltado cruzado
          group.addEventListener('mouseenter',()=>{
            group.classList.add('piece-highlight');
            const row=list.querySelector(`[data-row="${p.pieza_id}"]`);
            row?.classList.add('list-highlight');
          });
          group.addEventListener('mouseleave',()=>{
            group.classList.remove('piece-highlight');
            const row=list.querySelector(`[data-row="${p.pieza_id}"]`);
            row?.classList.remove('list-highlight');
          });

          // Click: abrir modal con info; si está presionado Ctrl, NO abrir (se usa para mover)
          group.addEventListener('click',(ev)=>{
            onPieceClick(ev, p);
          });
          g.appendChild(group);
        }
        // Margen útil en amarillo (si hay márgenes)
        const mx = Number(meta.margen_x);
        const my = Number(meta.margen_y);
        if(Number.isFinite(mx) && Number.isFinite(my) && (mx>0 || my>0)){
          const usable = document.createElementNS(svgNS,'rect');
          usable.setAttribute('x', String(mx));
          usable.setAttribute('y', String(my));
          usable.setAttribute('width', String(Math.max(w-2*mx,0)));
          usable.setAttribute('height', String(Math.max(h-2*my,0)));
          usable.setAttribute('fill','none');
          usable.setAttribute('stroke','#FFC107');
          usable.setAttribute('stroke-width','2');
          usable.setAttribute('stroke-dasharray','6 4');
          g.appendChild(usable);
        }
        // cortes: si vienen, usarlos; si no, inferir
        const cortes = Array.isArray(board.cortes)&&board.cortes.length? board.cortes : null;
        if(cortes){
          for(const c of cortes){
            const ln=document.createElementNS(svgNS,'line');
            if(c.tipo==='vertical'){
              ln.setAttribute('x1',String(c.posicion)); ln.setAttribute('x2',String(c.posicion)); ln.setAttribute('y1','0'); ln.setAttribute('y2',String(h));
            } else if(c.tipo==='horizontal'){
              ln.setAttribute('x1','0'); ln.setAttribute('x2',String(w)); ln.setAttribute('y1',String(c.posicion)); ln.setAttribute('y2',String(c.posicion));
            } else { continue; }
            ln.setAttribute('stroke','#666'); ln.setAttribute('stroke-width','1.6'); ln.setAttribute('stroke-dasharray','6 5');
            g.appendChild(ln);
          }
        }
        // Bounding box completo (incluye textos/cortes) y vista inicial centrada
        contentBounds = g.getBBox();
        // Ajuste inicial estándar (comportamiento original)
        fit(board);
      }

  // Modal e interacción de pieza
  let modalEl = null; let modalPid = null; // estado del modal de pieza
  let modalChangedToEnCorte = false; // si pusimos en 'en_corte' al abrir
  let modalWasCut = false; // si se marcó como cortada dentro del modal
  function getPieceById(pid){
    try{
      const board = tableros[idx] || {};
      return (board.piezas||[]).find(pp=>pp.pieza_id===pid) || null;
    }catch(_e){ return null; }
  }
  const pendingByPiece = new Map();
      async function setPieceState(piezaId, estado){
        // Persistencia asíncrona; no bloquea la UI
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/${encodeURIComponent(piezaId)}`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado})});
          if(!r.ok) throw new Error(await r.text());
        }catch(err){
          // Fallback: marcar error en consola y permitir reintento manual (no revertimos para mantener fluidez)
          console.error('Persistencia de pieza falló:', err);
          alert('No se pudo guardar la pieza. Intenta nuevamente.');
        } finally {
          pendingByPiece.delete(piezaId);
        }
      }
      function updatePieceUI(pid, estado){
        const dot = list.querySelector(`[data-row="${pid}"] span.rounded-circle`); if(dot) dot.style.background = stateColor(estado);
        const sel = list.querySelector(`select[data-pieza="${pid}"]`); if(sel) sel.value = estado;
        const rect = document.getElementById(`piece-${pid}`); if(rect) rect.setAttribute('fill', stateColor(estado));
      }
      function closePieceModal(){
        // Si al abrir pusimos 'en_corte' y NO terminó en 'cortada', volver a 'pendiente'
        if(modalPid && modalChangedToEnCorte && !modalWasCut){
          const piece = getPieceById(modalPid);
          if(piece && piece.estado !== 'cortada'){
            piece.estado = 'pendiente';
            updatePieceUI(modalPid, 'pendiente');
            pendingByPiece.set(modalPid,true);
            setPieceState(modalPid, 'pendiente');
          }
        }
        if(modalEl){ modalEl.remove(); }
        modalEl=null; modalPid=null; modalChangedToEnCorte=false; modalWasCut=false;
      }
      function showPieceModal(p){
        closePieceModal();
        modalPid = p.pieza_id;
        modalChangedToEnCorte=false; modalWasCut=false;
        // Al abrir: si no está cortada, pasar a 'en_corte'
        if((p.estado||'pendiente') !== 'cortada'){
          p.estado = 'en_corte';
          updatePieceUI(p.pieza_id, 'en_corte');
          pendingByPiece.set(p.pieza_id,true); setPieceState(p.pieza_id,'en_corte');
          modalChangedToEnCorte = true;
        }
        const backdrop = document.createElement('div');
        backdrop.className = 'piece-modal-backdrop';
        const modal = document.createElement('div');
        modal.className = 'piece-modal';
        modal.innerHTML = `
          <div class="hdr">
            <strong>Pieza: ${p.nombre || p.pieza_id}</strong>
            <button class="btn-close" aria-label="Cerrar">×</button>
          </div>
          <div class="cnt">
            <div style="display:flex; gap:16px; align-items:stretch; height:100%;">
              <div id="pzPreview" style="flex:2 1 520px; min-width:420px; min-height:420px; height: calc(70vh); border:1px solid #eee; border-radius:8px; background:#fff;">
                <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet"></svg>
              </div>
              <div style="flex:1 1 300px; min-width:280px; display:flex; flex-direction:column; gap:8px;">
                <div><strong>Dimensiones:</strong> ${p.ancho}×${p.largo} mm</div>
                <div><strong>Posición:</strong> (${p.x}, ${p.y})</div>
                <div><strong>Tapacantos:</strong> ${tapsLabel(p.tapacantos)}</div>
                <div><strong>Estado:</strong> <span id="pzEstado">${p.estado||'pendiente'}</span></div>
              </div>
            </div>
            <div class="pz-overview">
              <div class="small text-muted" style="margin-bottom:4px;">Vista del tablero</div>
              <svg id="pzMiniBoard" width="100%" height="140" viewBox="0 0 200 140" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
          </div>
          <div class="ftr">
            <button id="btnBackBoard" class="op-btn">Volver al tablero</button>
            <button id="btnMarkCut" class="op-btn" style="background:#0d6efd;color:#fff;border-color:#0d6efd;">Marcar como cortada</button>
          </div>`;
        backdrop.appendChild(modal);
        document.body.appendChild(backdrop);
        // Render preview de la pieza (completa y grande con etiquetas dentro)
        try{
          const svgPrev = modal.querySelector('#pzPreview svg');
          const pw = Math.max(1, p.ancho||1), ph = Math.max(1, p.largo||1);
          // Dejamos más espacio alrededor para ubicar etiquetas por fuera sin recortes
          const pad = 14; const vw=100, vh=100;
          const sc = Math.min((vw-2*pad)/pw, (vh-2*pad)/ph);
          const dx = (vw - pw*sc)/2, dy = (vh - ph*sc)/2;
          svgPrev.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
          while(svgPrev.firstChild) svgPrev.removeChild(svgPrev.firstChild);
          const gPrev = document.createElementNS('http://www.w3.org/2000/svg','g');
          gPrev.setAttribute('transform', `translate(${dx},${dy}) scale(${sc})`);
          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('x','0'); rect.setAttribute('y','0');
          rect.setAttribute('width', String(pw)); rect.setAttribute('height', String(ph));
          rect.setAttribute('fill', stateColor(p.estado||'pendiente'));
          rect.setAttribute('fill-opacity','0.35'); rect.setAttribute('stroke','#222'); rect.setAttribute('stroke-width','0.8');
          rect.setAttribute('id','pzRect');
          gPrev.appendChild(rect);

          // Tapacantos en modal: mismas líneas, más separadas y visibles
          const offModal = Math.max(4, Math.min(pw, ph) * 0.03);
          drawTapacantosLines(gPrev, 0, 0, pw, ph, p.tapacantos||{}, { offset: offModal, strokeWidth: 3.2, dash: '8 5' });
          // Nombre centrado, orientado por lado más largo
          const name = document.createElementNS('http://www.w3.org/2000/svg','text');
          const ncx = pw/2, ncy = ph/2; name.setAttribute('x', String(ncx)); name.setAttribute('y', String(ncy));
          name.setAttribute('text-anchor','middle'); name.setAttribute('dominant-baseline','middle');
          name.setAttribute('font-size', String(Math.max(10, Math.min(pw,ph)/10))); name.setAttribute('font-weight','bold'); name.setAttribute('fill','#111');
          if(ph >= pw){ name.setAttribute('transform', `rotate(-90 ${ncx} ${ncy})`); }
          name.textContent = p.nombre || p.pieza_id; gPrev.appendChild(name);
          // Etiquetas de medidas y tapacanto (GRANDES y por FUERA de la pieza, sin tocarla)
          const fsMeasureVal = Math.max(14, Math.min(pw, ph) / 5);
          // Gap en unidades de pieza (mm), proporcional
          const gapMMBase = Math.max((pad * 0.6) / Math.max(1e-6, sc), Math.min(pw, ph) * 0.025);
          // Evitar recortes: limitar posiciones por el padding disponible en contenido
          const padC = pad / Math.max(1e-6, sc);
          const maxTopGap = Math.max(0, padC - fsMeasureVal*0.60);
          const maxSideGap = Math.max(0, padC - fsMeasureVal*0.60);
          const topGap = Math.min(gapMMBase + fsMeasureVal*0.20, maxTopGap);
          const sideGap = Math.min(gapMMBase + fsMeasureVal*0.20, maxSideGap);
          // Ancho arriba, centrado, por fuera con margen adicional según tamaño de fuente
          const topTxt = document.createElementNS('http://www.w3.org/2000/svg','text');
          topTxt.setAttribute('x', String(pw/2)); topTxt.setAttribute('y', String(-topGap)); topTxt.setAttribute('text-anchor','middle');
          topTxt.setAttribute('dominant-baseline','hanging');
          topTxt.setAttribute('font-size', String(fsMeasureVal)); topTxt.setAttribute('font-weight','bold'); topTxt.setAttribute('fill','#111');
          topTxt.textContent = `${p.ancho} mm`; gPrev.appendChild(topTxt);
          // Largo a la derecha, vertical, por fuera con margen adicional
          const rightTxt = document.createElementNS('http://www.w3.org/2000/svg','text');
          const rx = pw + sideGap, ry = ph/2; rightTxt.setAttribute('x', String(rx)); rightTxt.setAttribute('y', String(ry)); rightTxt.setAttribute('text-anchor','middle');
          rightTxt.setAttribute('font-size', String(fsMeasureVal)); rightTxt.setAttribute('font-weight','bold'); rightTxt.setAttribute('fill','#111'); rightTxt.setAttribute('transform', `rotate(-90 ${rx} ${ry})`);
          rightTxt.textContent = `${p.largo} mm`; gPrev.appendChild(rightTxt);
          // Tapacantos debajo, centrado, por fuera con margen suficiente
          const fsTapVal = Math.max(12, Math.min(pw, ph)/9);
          const tcTxt = document.createElementNS('http://www.w3.org/2000/svg','text');
          const maxBottomGap = Math.max(0, padC - fsTapVal*0.60);
          const bottomGap = Math.min(gapMMBase + fsTapVal*0.25, maxBottomGap);
          tcTxt.setAttribute('x', String(pw/2)); tcTxt.setAttribute('y', String(ph + bottomGap)); tcTxt.setAttribute('text-anchor','middle');
          tcTxt.setAttribute('font-size', String(fsTapVal)); tcTxt.setAttribute('fill','#111'); tcTxt.textContent = `TC: ${tapsLabel(p.tapacantos)}`; gPrev.appendChild(tcTxt);
          svgPrev.appendChild(gPrev);
        }catch(_e){}
        // Render minimapa del tablero con pieza resaltada
        try{
          const board = tableros[idx] || {};
          const svgMini = modal.querySelector('#pzMiniBoard');
          if(svgMini){ renderMiniBoard(svgMini, board, p.pieza_id); }
        }catch(_e){}
        // Eventos
        modal.querySelector('.btn-close')?.addEventListener('click', closePieceModal);
        backdrop.addEventListener('click',(e)=>{ if(e.target===backdrop) closePieceModal(); });
        modal.querySelector('#btnBackBoard')?.addEventListener('click',()=>{ closePieceModal(); });
        modal.querySelector('#btnMarkCut')?.addEventListener('click',()=>{
          const pid = p.pieza_id; p.estado='cortada'; updatePieceUI(pid,'cortada'); pendingByPiece.set(pid,true); setPieceState(pid,'cortada'); modalWasCut=true; closePieceModal();
        });
        // Click en la pieza dentro del modal: marcar como cortada (equivalente al botón)
        try{
          const rectPrev = modal.querySelector('#pzRect');
          rectPrev?.addEventListener('click',()=>{
            const pid = p.pieza_id; p.estado='cortada'; updatePieceUI(pid,'cortada'); pendingByPiece.set(pid,true); setPieceState(pid,'cortada'); modalWasCut=true; closePieceModal();
          });
        }catch(_e){}
        modalEl = backdrop;
      }
      function renderMiniBoard(svgEl, board, selectedPid){
        const w = Math.max(1, board.ancho_mm||1), h = Math.max(1, board.largo_mm||1);
        const pad = 6; const vw = 200, vh = 140;
        svgEl.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
        while(svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);
        const sc = Math.min((vw-2*pad)/w, (vh-2*pad)/h);
        const dx = (vw - w*sc)/2, dy = (vh - h*sc)/2;
        const gM = document.createElementNS('http://www.w3.org/2000/svg','g');
        gM.setAttribute('transform', `translate(${dx},${dy}) scale(${sc})`);
        // board
        const br = document.createElementNS('http://www.w3.org/2000/svg','rect');
        br.setAttribute('x','0'); br.setAttribute('y','0'); br.setAttribute('width', String(w)); br.setAttribute('height', String(h));
        br.setAttribute('fill','#fff'); br.setAttribute('stroke','#444'); br.setAttribute('stroke-width','1');
        gM.appendChild(br);
        // pieces
        for(const pp of (board.piezas||[])){
          const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
          r.setAttribute('x', String(pp.x||0)); r.setAttribute('y', String(pp.y||0)); r.setAttribute('width', String(pp.ancho||0)); r.setAttribute('height', String(pp.largo||0));
          const isSel = (pp.pieza_id === selectedPid);
          r.setAttribute('fill', isSel ? '#0D6EFD' : '#B0D4FF');
          r.setAttribute('fill-opacity', isSel ? '0.55' : '0.35');
          r.setAttribute('stroke', isSel ? '#0B5ED7' : '#666'); r.setAttribute('stroke-width', isSel ? '2' : '1');
          gM.appendChild(r);
        }
        svgEl.appendChild(gM);
      }
      function onPieceClick(ev, p){
        // Si Ctrl/Cmd está presionado, interpretamos como intención de mover y NO abrimos modal
        if(ev && (ev.ctrlKey || ev.metaKey)) return;
        // Si ya hay modal abierto para esta pieza, marca cortada
        if(modalEl && modalPid === p.pieza_id){
          const pid = p.pieza_id; p.estado='cortada'; updatePieceUI(pid,'cortada'); pendingByPiece.set(pid,true); setPieceState(pid,'cortada'); closePieceModal();
          return;
        }
        // Abrir modal con info
        const row=list.querySelector(`[data-row="${p.pieza_id}"]`);
        row?.scrollIntoView({block:'nearest'}); row?.classList.add('list-highlight'); setTimeout(()=>row?.classList.remove('list-highlight'),700);
        showPieceModal(p);
      }

      function updateStats(board){
        const w=board.ancho_mm||0, h=board.largo_mm||0; stSize.textContent = `${w}×${h} mm`;
        const mx = meta.margen_x ?? '?', my= meta.margen_y ?? '?'; stMargins.textContent = `mx=${mx}, my=${my}`;
        // útil (si se conocen márgenes)
        if(Number.isFinite(mx) && Number.isFinite(my)) stUtil.textContent = `${Math.max(w-2*mx,0)}×${Math.max(h-2*my,0)} mm`; else stUtil.textContent = '—';
        // eficiencia tablero si existe
        const eff = (board.eficiencia!=null)? Number(board.eficiencia).toFixed(1)+'%' : '—'; stEff.textContent = eff;
        stPieces.textContent = (board.piezas||[]).length;
        // cortes
        let v=0,hc=0; if(Array.isArray(board.cortes)&&board.cortes.length){ v = board.cortes.filter(c=>c.tipo==='vertical').length; hc = board.cortes.filter(c=>c.tipo==='horizontal').length; } else { const inf = inferCutLines(board); v = Math.max(inf.v.length-2,0); hc = Math.max(inf.h.length-2,0); }
        stCutV.textContent = String(v); stCutH.textContent = String(hc);
        stML.textContent = mlTapacanto(board);
      }

      // Interacción
  svg.addEventListener('wheel',(e)=>{ 
        const board = tableros[idx]||{};
        // Ignorar eventos antes de tener escala base y bounds válidos
        if(!boardBounds || !isFinite(boardBounds.width) || !isFinite(boardBounds.height) || boardBounds.width<=0 || baseScale<=0){ return; }
  // Zoom solo con Ctrl/Cmd; si no, la rueda no actúa sobre el visor (no pan)
        if(e.ctrlKey || e.metaKey){
          e.preventDefault();
          const factor = e.deltaY<0?1.1:0.9; 
          const prev=scale; 
          const newScale = Math.max(baseScale*MIN_ZOOM_FACTOR, Math.min(8, prev*factor));
          // Zoom anclado al cursor (dx/dy en contenido):
          // Mantener p bajo el cursor: (p + dx')*new = (p + dx)*prev => dx' = r*dx + (r-1)*p, r=prev/new
          const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
          if(ctm){
            const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY; const p=pt.matrixTransform(ctm.inverse());
            const r = prev / newScale;
            dx = r*dx + (r - 1)*p.x;
            dy = r*dy + (r - 1)*p.y;
          }
          scale = newScale;
          apply(board);
        } else {
          // Sin Ctrl: no hacemos nada (la página no se desplaza porque el body está oculto)
          return;
        }
      },{passive:false});
  svg.addEventListener('mousedown',(e)=>{
    const isMid = (e.button===1);
    const allowPan = isMid || e.ctrlKey || e.metaKey; // mover solo con botón medio o con Ctrl
    if(!allowPan){ dragging=false; updateCursor(); return; }
    e.preventDefault();
    dragging=true; lx=e.clientX; ly=e.clientY; svg.style.cursor='grabbing';
  });
  window.addEventListener('mouseup',()=>{ dragging=false; updateCursor(); });
  window.addEventListener('mousemove',(e)=>{ if(!dragging) return; dx += (e.clientX-lx)/Math.max(1e-6, scale); dy += (e.clientY-ly)/Math.max(1e-6, scale); lx=e.clientX; ly=e.clientY; apply(tableros[idx]||{}); });
  document.getElementById('btnZoomIn').addEventListener('click',()=>{ 
    const board=tableros[idx]||{}; 
    const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
    const prev=scale; const newScale=Math.min(8,prev*1.2);
    if(ctm){ const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const p=pt.matrixTransform(ctm.inverse()); const r=prev/newScale; dx = r*dx + (r-1)*p.x; dy = r*dy + (r-1)*p.y; }
    scale=newScale; apply(board); 
  });
  document.getElementById('btnZoomOut').addEventListener('click',()=>{ 
    const board=tableros[idx]||{}; 
    const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
    const prev=scale; const newScale=Math.max(baseScale*MIN_ZOOM_FACTOR,prev/1.2);
    if(ctm){ const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const p=pt.matrixTransform(ctm.inverse()); const r=prev/newScale; dx = r*dx + (r-1)*p.x; dy = r*dy + (r-1)*p.y; }
    scale=newScale; apply(board); 
  });
  document.getElementById('btnZoomReset').addEventListener('click',()=>{
    // Ajustar vista: refresca el visualizador del tablero actual, centrando y re-ajustando sin recargar toda la página
    const board = tableros[idx]||{};
    renderBoard(board);
    renderList(board);
    updateStats(board);
    updateCompletarVisibility();
    updateCursor();
  });

  // Gestos táctiles: pan con 1 dedo (si zoom > base), pinch con 2 dedos para zoom
  svg.addEventListener('touchstart',(e)=>{
    if(e.touches.length===1){
      if(atBaseZoom()) return; // no pan al zoom base
      dragging=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY;
    } else if(e.touches.length===2){
      pinch.active=true;
      const t1=e.touches[0], t2=e.touches[1];
      pinch.d0 = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      pinch.s0 = scale;
      pinch.cx = (t1.clientX + t2.clientX)/2; pinch.cy = (t1.clientY + t2.clientY)/2;
    }
  }, {passive:false});
  svg.addEventListener('touchmove',(e)=>{
    if(pinch.active && e.touches.length===2){
      e.preventDefault();
      const t1=e.touches[0], t2=e.touches[1];
  const d = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
  const prev=scale;
  const newScale = Math.max(baseScale*MIN_ZOOM_FACTOR, Math.min(8, pinch.s0 * (d / Math.max(1, pinch.d0))));
  const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
  const pt=svg.createSVGPoint(); pt.x=pinch.cx; pt.y=pinch.cy; const p=ctm ? pt.matrixTransform(ctm.inverse()) : {x:0,y:0};
  {
    const r = prev / newScale;
    dx = r*dx + (r - 1)*p.x;
    dy = r*dy + (r - 1)*p.y;
  }
  scale = newScale;
      apply(tableros[idx]||{});
    } else if(dragging && e.touches.length===1){
      e.preventDefault();
      const tx=e.touches[0].clientX, ty=e.touches[0].clientY;
      dx += (tx - lx)/Math.max(1e-6, scale); dy += (ty - ly)/Math.max(1e-6, scale); lx=tx; ly=ty; apply(tableros[idx]||{});
    }
  }, {passive:false});
  svg.addEventListener('touchend',()=>{ if(pinch.active && event.touches && event.touches.length<2) pinch.active=false; dragging=false; updateCursor(); }, {passive:true});
  // Observa cambios reales de tamaño del host, más fiable que window.resize
  let lastHostSize = {w:0,h:0};
  function preserveWhenReady(board, tries=10){
    const r = host.getBoundingClientRect();
    if((r.width<10 || r.height<10) && tries>0){ setTimeout(()=>preserveWhenReady(board, tries-1), 60); return; }
  preserveViewOnContainerChange(board);
  }
  const ro = new ResizeObserver(entries=>{
    for(const e of entries){
      const cr = e.contentRect;
      if(Math.abs(cr.width - lastHostSize.w) > 1 || Math.abs(cr.height - lastHostSize.h) > 1){
        lastHostSize = {w:cr.width, h:cr.height};
        preserveWhenReady(tableros[idx]||{});
      }
    }
  });
  ro.observe(host);
  // Fallback por si el navegador no soporta ResizeObserver (no debería ser el caso)
  window.addEventListener('resize', ()=>{ preserveWhenReady(tableros[idx]||{}); });
      document.getElementById('btnToggleSidebar').addEventListener('click',()=>{
        const wrap = document.querySelector('.op-wrapper');
        const btn = document.getElementById('btnToggleSidebar');
        const isHidden = wrap.classList.toggle('sidebar-hidden');
        btn.textContent = isHidden ? 'Panel ◂' : 'Panel ▸';
        // Re-centrar manteniendo escala al cambiar el ancho disponible
        // Esperar a que la grilla recalcule el layout; lanzar varias veces para garantizar el estado final
        requestAnimationFrame(()=>preserveWhenReady(tableros[idx]||{}));
        setTimeout(()=>preserveWhenReady(tableros[idx]||{}), 60);
        setTimeout(()=>preserveWhenReady(tableros[idx]||{}), 140);
      });
      function updateCompletarVisibility(){
        const btn = document.getElementById('btnCompletar');
        if(!btn) return;
        const isLast = (idx === Math.max(0, tableros.length - 1));
        btn.style.display = isLast ? 'inline-block' : 'none';
      }
      selTab.addEventListener('change',()=>{ 
        idx=parseInt(selTab.value,10)||0; 
        renderBoard(tableros[idx]||{}); 
        renderList(tableros[idx]||{}); 
  updateStats(tableros[idx]||{}); 
  updateCompletarVisibility();
      });
  window.addEventListener('keydown',(e)=>{ 
    const board=tableros[idx]||{}; 
    if(e.key==='+'){
      const prev=scale; const newScale=Math.min(8,scale*1.1);
      const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
      if(ctm){ const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const p=pt.matrixTransform(ctm.inverse()); const r=prev/newScale; dx = r*dx + (r-1)*p.x; dy = r*dy + (r-1)*p.y; }
      scale = newScale; apply(board);
    } else if(e.key==='-'){
      const prev=scale; const newScale=Math.max(baseScale*MIN_ZOOM_FACTOR,scale/1.1);
      const ctm = (g.getScreenCTM && g.getScreenCTM()) || svg.getScreenCTM();
      if(ctm){ const rect=host.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; const pt=svg.createSVGPoint(); pt.x=cx; pt.y=cy; const p=pt.matrixTransform(ctm.inverse()); const r=prev/newScale; dx = r*dx + (r-1)*p.x; dy = r*dy + (r-1)*p.y; }
      scale = newScale; apply(board);
    } else if(e.key==='0'){
      fit(board);
    } else if(e.key==='ArrowRight'){
      idx=Math.min(tableros.length-1, idx+1); selTab.value=String(idx); selTab.dispatchEvent(new Event('change'));
    } else if(e.key==='ArrowLeft'){
      idx=Math.max(0, idx-1); selTab.value=String(idx); selTab.dispatchEvent(new Event('change'));
    } else if(e.key==='s' || e.key==='S'){
      const box=document.getElementById('statsBox'); box.style.display = (box.style.display==='none')? 'block' : 'none';
    }
  });

      // Inicialización
      renderBoard(tableros[idx]||{}); renderList(tableros[idx]||{}); updateStats(tableros[idx]||{});
      updateZoomUI();
      updateCompletarVisibility();

      // Al iniciar edición, marcar proyecto EN PROCESO si no está completado
      try{
        if(proyectoMeta && proyectoMeta.estado !== 'completado' && proyectoMeta.estado !== 'en_proceso'){
          await fetch(`/api/operador/proyectos/${proyectoId}/estado`,{method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado:'en_proceso'})});
        }
      }catch(_e){}

      // Handler: marcar todas como cortadas
      document.getElementById('btnMarcarTodas').addEventListener('click', async ()=>{
        if(!confirm('¿Marcar todas las piezas de este proyecto como CORTADAS?')) return;
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/piezas/marcar-todas`, {method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify({estado:'cortada'})});
          let jr = {};
          try { jr = await r.clone().json(); } catch(_) { try { jr = {message: await r.text()}; } catch(__) { jr = {}; } }
          if(!r.ok){ alert(jr && jr.message ? jr.message : 'No se pudo marcar.'); return; }
          // Refrescar UI local: setear a cortada
          for(const t of tableros){ for(const p of (t.piezas||[])){ p.estado = 'cortada'; } }
          renderList(tableros[idx]||{});
          // Colorear rects actuales
          (tableros[idx]?.piezas||[]).forEach(p=>{ const rect=document.getElementById(`piece-${p.pieza_id}`); if(rect) rect.setAttribute('fill', stateColor('cortada')); });
          alert('Todas las piezas marcadas como cortadas.');
        }catch(_e){ alert('Error al marcar todas como cortadas.'); }
      });

      // Handler: completar proyecto (sólo en último tablero visible)
      document.getElementById('btnCompletar').addEventListener('click', async ()=>{
        try{
          const r = await fetch(`/api/operador/proyectos/${proyectoId}/completar`, {method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}});
          const jr = await r.json().catch(()=>({}));
          if(!r.ok){
            const msg = jr && jr.message ? jr.message : 'No se pudo completar el proyecto.';
            alert(msg);
            return;
          }
          // Volver a la lista del operador
          window.location.href = '{% url "operador_home" %}';
        }catch(_e){ alert('Error al completar el proyecto.'); }
      });
    })();
    </script>

    {% include "partials/scripts.html" %}
  </body>
  </html>
